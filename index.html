<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>game</title>
<script>
	require = function() {
    function r(e, n, t) {
        function o(i, f) {
            if (!n[i]) {
                if (!e[i]) {
                    var c = "function" == typeof require && require;
                    if (!f && c) return c(i, !0);
                    if (u) return u(i, !0);
                    var a = new Error("Cannot find module '" + i + "'");
                    throw a.code = "MODULE_NOT_FOUND", a;
                }
                var p = n[i] = {
                    exports: {}
                };
                e[i][0].call(p.exports, function(r) {
                    var n = e[i][1][r];
                    return o(n || r);
                }, p, p.exports, r, e, n, t);
            }
            return n[i].exports;
        }
        for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);
        return o;
    }
    return r;
}()({
    "@akashic/akashic-engine": [ function(require, module, exports) {
        (function() {
            "use strict";
            var g, __extends = this && this.__extends || function(d, b) {
                function __() {
                    this.constructor = d;
                }
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
                d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
            !function(g) {
                var AssetLoadErrorType;
                !function(AssetLoadErrorType) {
                    AssetLoadErrorType[AssetLoadErrorType.Unspecified = 0] = "Unspecified", AssetLoadErrorType[AssetLoadErrorType.RetryLimitExceeded = 1] = "RetryLimitExceeded", 
                    AssetLoadErrorType[AssetLoadErrorType.NetworkError = 2] = "NetworkError", AssetLoadErrorType[AssetLoadErrorType.ClientError = 3] = "ClientError", 
                    AssetLoadErrorType[AssetLoadErrorType.ServerError = 4] = "ServerError";
                }(AssetLoadErrorType = g.AssetLoadErrorType || (g.AssetLoadErrorType = {}));
            }(g || (g = {}));
            var g;
            !function(g) {
                var ExceptionFactory;
                !function(ExceptionFactory) {
                    function createAssertionError(message, cause) {
                        var e = new Error(message);
                        return e.name = "AssertionError", e.cause = cause, e;
                    }
                    function createTypeMismatchError(methodName, expected, actual, cause) {
                        var message = "Type mismatch on " + methodName + ", expected type is " + expected;
                        if (arguments.length > 2) try {
                            var actualString;
                            actualString = actual && actual.constructor && actual.constructor.name ? actual.constructor.name : typeof actual, 
                            message += ", actual type is " + (actualString.length > 40 ? actualString.substr(0, 40) : actualString);
                        } catch (ex) {}
                        message += ".";
                        var e = new Error(message);
                        return e.name = "TypeMismatchError", e.cause = cause, e.expected = expected, e.actual = actual, 
                        e;
                    }
                    function createAssetLoadError(message, retriable, type, cause) {
                        void 0 === retriable && (retriable = !0), void 0 === type && (type = g.AssetLoadErrorType.Unspecified);
                        var e = new Error(message);
                        return e.name = "AssetLoadError", e.cause = cause, e.retriable = retriable, e.type = type, 
                        e;
                    }
                    ExceptionFactory.createAssertionError = createAssertionError, ExceptionFactory.createTypeMismatchError = createTypeMismatchError, 
                    ExceptionFactory.createAssetLoadError = createAssetLoadError;
                }(ExceptionFactory = g.ExceptionFactory || (g.ExceptionFactory = {}));
            }(g || (g = {}));
            var g;
            !function(g) {
                var ResourceFactory = function() {
                    function ResourceFactory() {}
                    return ResourceFactory.prototype.createSurfaceAtlas = function(width, height) {
                        return new g.SurfaceAtlas(this.createSurface(width, height));
                    }, ResourceFactory;
                }();
                g.ResourceFactory = ResourceFactory;
            }(g || (g = {}));
            var g;
            !function(g) {
                var RequireCachedValue = function() {
                    function RequireCachedValue(value) {
                        this._value = value;
                    }
                    return RequireCachedValue.prototype._cachedValue = function() {
                        return this._value;
                    }, RequireCachedValue;
                }();
                g.RequireCachedValue = RequireCachedValue;
            }(g || (g = {}));
            var g;
            !function(g) {
                var RandomGenerator = function() {
                    function RandomGenerator(seed) {
                        this.seed = seed, this[0] = this;
                    }
                    return RandomGenerator;
                }();
                g.RandomGenerator = RandomGenerator;
            }(g || (g = {}));
            var g;
            !function(g) {
                var Asset = function() {
                    function Asset(id, path) {
                        this.id = id, this.originalPath = path, this.path = this._assetPathFilter(path), 
                        this.onDestroyed = new g.Trigger();
                    }
                    return Asset.prototype.destroy = function() {
                        this.onDestroyed.fire(this), this.id = void 0, this.originalPath = void 0, this.path = void 0, 
                        this.onDestroyed.destroy(), this.onDestroyed = void 0;
                    }, Asset.prototype.destroyed = function() {
                        return void 0 === this.id;
                    }, Asset.prototype.inUse = function() {
                        return !1;
                    }, Asset.prototype._assetPathFilter = function(path) {
                        return path;
                    }, Asset;
                }();
                g.Asset = Asset;
                var ImageAsset = function(_super) {
                    function ImageAsset(id, assetPath, width, height) {
                        var _this = _super.call(this, id, assetPath) || this;
                        return _this.width = width, _this.height = height, _this;
                    }
                    return __extends(ImageAsset, _super), ImageAsset;
                }(Asset);
                g.ImageAsset = ImageAsset;
                var VideoAsset = function(_super) {
                    function VideoAsset(id, assetPath, width, height, system, loop, useRealSize) {
                        var _this = _super.call(this, id, assetPath, width, height) || this;
                        return _this.realWidth = 0, _this.realHeight = 0, _this._system = system, _this._loop = loop, 
                        _this._useRealSize = useRealSize, _this;
                    }
                    return __extends(VideoAsset, _super), VideoAsset.prototype.play = function(loop) {
                        return this.getPlayer().play(this), this.getPlayer();
                    }, VideoAsset.prototype.stop = function() {
                        this.getPlayer().stop();
                    }, VideoAsset.prototype.destroy = function() {
                        this._system = void 0, _super.prototype.destroy.call(this);
                    }, VideoAsset;
                }(ImageAsset);
                g.VideoAsset = VideoAsset;
                var AudioAsset = function(_super) {
                    function AudioAsset(id, assetPath, duration, system, loop, hint) {
                        var _this = _super.call(this, id, assetPath) || this;
                        return _this.duration = duration, _this.loop = loop, _this.hint = hint, _this._system = system, 
                        _this.data = void 0, _this;
                    }
                    return __extends(AudioAsset, _super), AudioAsset.prototype.play = function() {
                        var player = this._system.createPlayer();
                        return player.play(this), this._lastPlayedPlayer = player, player;
                    }, AudioAsset.prototype.stop = function() {
                        for (var players = this._system.findPlayers(this), i = 0; i < players.length; ++i) players[i].stop();
                    }, AudioAsset.prototype.inUse = function() {
                        return this._system.findPlayers(this).length > 0;
                    }, AudioAsset.prototype.destroy = function() {
                        this._system && this.stop(), this.data = void 0, this._system = void 0, this._lastPlayedPlayer = void 0, 
                        _super.prototype.destroy.call(this);
                    }, AudioAsset;
                }(Asset);
                g.AudioAsset = AudioAsset;
                var TextAsset = function(_super) {
                    function TextAsset(id, assetPath) {
                        var _this = _super.call(this, id, assetPath) || this;
                        return _this.data = void 0, _this;
                    }
                    return __extends(TextAsset, _super), TextAsset.prototype.destroy = function() {
                        this.data = void 0, _super.prototype.destroy.call(this);
                    }, TextAsset;
                }(Asset);
                g.TextAsset = TextAsset;
                var ScriptAsset = function(_super) {
                    function ScriptAsset() {
                        return null !== _super && _super.apply(this, arguments) || this;
                    }
                    return __extends(ScriptAsset, _super), ScriptAsset.prototype.destroy = function() {
                        this.script = void 0, _super.prototype.destroy.call(this);
                    }, ScriptAsset;
                }(Asset);
                g.ScriptAsset = ScriptAsset;
            }(g || (g = {}));
            var g;
            !function(g) {
                function normalizeAudioSystemConfMap(confMap) {
                    confMap = confMap || {};
                    var systemDefaults = {
                        music: {
                            loop: !0,
                            hint: {
                                streaming: !0
                            }
                        },
                        sound: {
                            loop: !1,
                            hint: {
                                streaming: !1
                            }
                        }
                    };
                    for (var key in systemDefaults) key in confMap || (confMap[key] = systemDefaults[key]);
                    return confMap;
                }
                var AssetLoadingInfo = function() {
                    function AssetLoadingInfo(asset, handler) {
                        this.asset = asset, this.handlers = [ handler ], this.errorCount = 0, this.loading = !1;
                    }
                    return AssetLoadingInfo;
                }(), AssetManager = function() {
                    function AssetManager(game, conf, audioSystemConfMap, moduleMainScripts) {
                        this.game = game, this.configuration = this._normalize(conf || {}, normalizeAudioSystemConfMap(audioSystemConfMap)), 
                        this._assets = {}, this._liveAssetVirtualPathTable = {}, this._liveAbsolutePathTable = {}, 
                        this._moduleMainScripts = moduleMainScripts ? moduleMainScripts : {}, this._refCounts = {}, 
                        this._loadings = {};
                    }
                    return AssetManager.prototype.destroy = function() {
                        for (var assetIds = Object.keys(this._refCounts), i = 0; i < assetIds.length; ++i) this._releaseAsset(assetIds[i]);
                        this.game = void 0, this.configuration = void 0, this._assets = void 0, this._liveAssetVirtualPathTable = void 0, 
                        this._liveAbsolutePathTable = void 0, this._refCounts = void 0, this._loadings = void 0;
                    }, AssetManager.prototype.destroyed = function() {
                        return void 0 === this.game;
                    }, AssetManager.prototype.retryLoad = function(asset) {
                        if (!this._loadings.hasOwnProperty(asset.id)) throw g.ExceptionFactory.createAssertionError("AssetManager#retryLoad: invalid argument.");
                        var loadingInfo = this._loadings[asset.id];
                        if (loadingInfo.errorCount > AssetManager.MAX_ERROR_COUNT) {
                            if (!this.configuration[asset.id]) return;
                            throw g.ExceptionFactory.createAssertionError("AssetManager#retryLoad: too many retrying.");
                        }
                        loadingInfo.loading || (loadingInfo.loading = !0, asset._load(this));
                    }, AssetManager.prototype.globalAssetIds = function() {
                        var ret = [], conf = this.configuration;
                        for (var p in conf) conf.hasOwnProperty(p) && conf[p].global && ret.push(p);
                        return ret;
                    }, AssetManager.prototype.requestAsset = function(assetIdOrConf, handler) {
                        var loadingInfo, assetId = "string" == typeof assetIdOrConf ? assetIdOrConf : assetIdOrConf.id, waiting = !1;
                        if (this._assets.hasOwnProperty(assetId)) ++this._refCounts[assetId], handler._onAssetLoad(this._assets[assetId]); else if (this._loadings.hasOwnProperty(assetId)) loadingInfo = this._loadings[assetId], 
                        loadingInfo.handlers.push(handler), ++this._refCounts[assetId], waiting = !0; else {
                            var a = this._createAssetFor(assetIdOrConf);
                            loadingInfo = new AssetLoadingInfo(a, handler), this._loadings[assetId] = loadingInfo, 
                            this._refCounts[assetId] = 1, waiting = !0, loadingInfo.loading = !0, a._load(this);
                        }
                        return waiting;
                    }, AssetManager.prototype.unrefAsset = function(assetOrId) {
                        var assetId = "string" == typeof assetOrId ? assetOrId : assetOrId.id;
                        --this._refCounts[assetId] > 0 || this._releaseAsset(assetId);
                    }, AssetManager.prototype.requestAssets = function(assetIdOrConfs, handler) {
                        for (var waitingCount = 0, i = 0, len = assetIdOrConfs.length; len > i; ++i) this.requestAsset(assetIdOrConfs[i], handler) && ++waitingCount;
                        return waitingCount;
                    }, AssetManager.prototype.unrefAssets = function(assetOrIds) {
                        for (var i = 0, len = assetOrIds.length; len > i; ++i) this.unrefAsset(assetOrIds[i]);
                    }, AssetManager.prototype._normalize = function(configuration, audioSystemConfMap) {
                        var ret = {};
                        if (!(configuration instanceof Object)) throw g.ExceptionFactory.createAssertionError("AssetManager#_normalize: invalid arguments.");
                        for (var p in configuration) if (configuration.hasOwnProperty(p)) {
                            var conf = Object.create(configuration[p]);
                            if (!conf.path) throw g.ExceptionFactory.createAssertionError("AssetManager#_normalize: No path given for: " + p);
                            if (!conf.virtualPath) throw g.ExceptionFactory.createAssertionError("AssetManager#_normalize: No virtualPath given for: " + p);
                            if (!conf.type) throw g.ExceptionFactory.createAssertionError("AssetManager#_normalize: No type given for: " + p);
                            if ("image" === conf.type) {
                                if ("number" != typeof conf.width) throw g.ExceptionFactory.createAssertionError("AssetManager#_normalize: wrong width given for the image asset: " + p);
                                if ("number" != typeof conf.height) throw g.ExceptionFactory.createAssertionError("AssetManager#_normalize: wrong height given for the image asset: " + p);
                            }
                            if ("audio" === conf.type) {
                                void 0 === conf.duration && (conf.duration = 0);
                                var audioSystemConf = audioSystemConfMap[conf.systemId];
                                void 0 === conf.loop && (conf.loop = !!audioSystemConf && !!audioSystemConf.loop), 
                                void 0 === conf.hint && (conf.hint = audioSystemConf ? audioSystemConf.hint : {});
                            }
                            if ("video" === conf.type && !conf.useRealSize) {
                                if ("number" != typeof conf.width) throw g.ExceptionFactory.createAssertionError("AssetManager#_normalize: wrong width given for the video asset: " + p);
                                if ("number" != typeof conf.height) throw g.ExceptionFactory.createAssertionError("AssetManager#_normalize: wrong height given for the video asset: " + p);
                                conf.useRealSize = !1;
                            }
                            conf.global || (conf.global = !1), ret[p] = conf;
                        }
                        return ret;
                    }, AssetManager.prototype._createAssetFor = function(idOrConf) {
                        var id, uri, conf;
                        if ("string" == typeof idOrConf) id = idOrConf, conf = this.configuration[id], uri = this.configuration[id].path; else {
                            var dynConf = idOrConf;
                            id = dynConf.id, conf = dynConf, uri = dynConf.uri;
                        }
                        var resourceFactory = this.game.resourceFactory;
                        if (!conf) throw g.ExceptionFactory.createAssertionError("AssetManager#_createAssetFor: unknown asset ID: " + id);
                        switch (conf.type) {
                          case "image":
                            return resourceFactory.createImageAsset(id, uri, conf.width, conf.height);

                          case "audio":
                            var system = conf.systemId ? this.game.audio[conf.systemId] : this.game.audio[this.game.defaultAudioSystemId];
                            return resourceFactory.createAudioAsset(id, uri, conf.duration, system, conf.loop, conf.hint);

                          case "text":
                            return resourceFactory.createTextAsset(id, uri);

                          case "script":
                            return resourceFactory.createScriptAsset(id, uri);

                          case "video":
                            return resourceFactory.createVideoAsset(id, uri, conf.width, conf.height, new g.VideoSystem(), conf.loop, conf.useRealSize);

                          default:
                            throw g.ExceptionFactory.createAssertionError("AssertionError#_createAssetFor: unknown asset type " + conf.type + " for asset ID: " + id);
                        }
                    }, AssetManager.prototype._releaseAsset = function(assetId) {
                        var path, asset = this._assets[assetId] || this._loadings[assetId] && this._loadings[assetId].asset;
                        if (asset) if (path = asset.path, asset.inUse()) if (asset instanceof g.AudioAsset) asset._system.requestDestroy(asset); else {
                            if (!(asset instanceof g.VideoAsset)) throw g.ExceptionFactory.createAssertionError("AssetManager#unrefAssets: Unsupported in-use " + asset.id);
                            asset.destroy();
                        } else asset.destroy();
                        if (delete this._refCounts[assetId], delete this._loadings[assetId], delete this._assets[assetId], 
                        this.configuration[assetId]) {
                            var virtualPath = this.configuration[assetId].virtualPath;
                            virtualPath && this._liveAssetVirtualPathTable.hasOwnProperty(virtualPath) && delete this._liveAssetVirtualPathTable[virtualPath], 
                            path && this._liveAbsolutePathTable.hasOwnProperty(path) && delete this._liveAbsolutePathTable[path];
                        }
                    }, AssetManager.prototype._countLoadingAsset = function() {
                        return Object.keys(this._loadings).length;
                    }, AssetManager.prototype._onAssetError = function(asset, error) {
                        if (!this.destroyed() && !asset.destroyed()) {
                            var loadingInfo = this._loadings[asset.id], hs = loadingInfo.handlers;
                            loadingInfo.loading = !1, ++loadingInfo.errorCount, loadingInfo.errorCount > AssetManager.MAX_ERROR_COUNT && error.retriable && (error = g.ExceptionFactory.createAssetLoadError("Retry limit exceeded", !1, g.AssetLoadErrorType.RetryLimitExceeded, error)), 
                            error.retriable || delete this._loadings[asset.id];
                            for (var i = 0; i < hs.length; ++i) hs[i]._onAssetError(asset, error, this);
                        }
                    }, AssetManager.prototype._onAssetLoad = function(asset) {
                        if (!this.destroyed() && !asset.destroyed()) {
                            var loadingInfo = this._loadings[asset.id];
                            if (loadingInfo.loading = !1, delete this._loadings[asset.id], this._assets[asset.id] = asset, 
                            this.configuration[asset.id]) {
                                var virtualPath = this.configuration[asset.id].virtualPath;
                                if (this._liveAssetVirtualPathTable.hasOwnProperty(virtualPath)) {
                                    if (this._liveAssetVirtualPathTable[virtualPath].path !== asset.path) throw g.ExceptionFactory.createAssertionError("AssetManager#_onAssetLoad(): duplicated asset path");
                                } else this._liveAssetVirtualPathTable[virtualPath] = asset;
                                this._liveAbsolutePathTable.hasOwnProperty(asset.path) || (this._liveAbsolutePathTable[asset.path] = virtualPath);
                            }
                            for (var hs = loadingInfo.handlers, i = 0; i < hs.length; ++i) hs[i]._onAssetLoad(asset);
                        }
                    }, AssetManager;
                }();
                AssetManager.MAX_ERROR_COUNT = 3, g.AssetManager = AssetManager;
            }(g || (g = {}));
            var g;
            !function(g) {
                function _require(game, path, currentModule) {
                    var targetScriptAsset, resolvedPath, resolvedVirtualPath, basedir = currentModule ? currentModule._dirname : game.assetBase, liveAssetVirtualPathTable = game._assetManager._liveAssetVirtualPathTable, moduleMainScripts = game._assetManager._moduleMainScripts;
                    if (-1 === path.indexOf("/") && game._assetManager._assets.hasOwnProperty(path) && (targetScriptAsset = game._assetManager._assets[path]), 
                    /^\.\/|^\.\.\/|^\//.test(path)) {
                        if (resolvedPath = g.PathUtil.resolvePath(basedir, path), game._scriptCaches.hasOwnProperty(resolvedPath)) return game._scriptCaches[resolvedPath]._cachedValue();
                        if (game._scriptCaches.hasOwnProperty(resolvedPath + ".js")) return game._scriptCaches[resolvedPath + ".js"]._cachedValue();
                        if (currentModule) {
                            if (!currentModule._virtualDirname) throw g.ExceptionFactory.createAssertionError("g._require: require from DynamicAsset is not supported");
                            resolvedVirtualPath = g.PathUtil.resolvePath(currentModule._virtualDirname, path);
                        } else {
                            if ("./" !== path.substring(0, 2)) throw g.ExceptionFactory.createAssertionError("g._require: entry point must start with './'");
                            resolvedVirtualPath = path.substring(2);
                        }
                        targetScriptAsset || (targetScriptAsset = g.Util.findAssetByPathAsFile(resolvedVirtualPath, liveAssetVirtualPathTable)), 
                        targetScriptAsset || (targetScriptAsset = g.Util.findAssetByPathAsDirectory(resolvedVirtualPath, liveAssetVirtualPathTable));
                    } else if (moduleMainScripts[path] && (targetScriptAsset = game._assetManager._liveAssetVirtualPathTable[moduleMainScripts[path]]), 
                    !targetScriptAsset) {
                        var dirs = currentModule ? currentModule.paths : [];
                        dirs.push("node_modules");
                        for (var i = 0; i < dirs.length; ++i) {
                            var dir = dirs[i];
                            if (resolvedVirtualPath = g.PathUtil.resolvePath(dir, path), targetScriptAsset = g.Util.findAssetByPathAsFile(resolvedVirtualPath, liveAssetVirtualPathTable)) break;
                            if (targetScriptAsset = g.Util.findAssetByPathAsDirectory(resolvedVirtualPath, liveAssetVirtualPathTable)) break;
                        }
                    }
                    if (targetScriptAsset) {
                        if (game._scriptCaches.hasOwnProperty(targetScriptAsset.path)) return game._scriptCaches[targetScriptAsset.path]._cachedValue();
                        if (targetScriptAsset instanceof g.ScriptAsset) {
                            var context = new g.ScriptAssetContext(game, targetScriptAsset);
                            return game._scriptCaches[targetScriptAsset.path] = context, context._executeScript(currentModule);
                        }
                        if (targetScriptAsset instanceof g.TextAsset && targetScriptAsset && ".json" === g.PathUtil.resolveExtname(path)) {
                            var cache = game._scriptCaches[targetScriptAsset.path] = new g.RequireCachedValue(JSON.parse(targetScriptAsset.data));
                            return cache._cachedValue();
                        }
                    }
                    throw g.ExceptionFactory.createAssertionError("g._require: can not find module: " + path);
                }
                g._require = _require;
                var Module = function() {
                    function Module(game, id, path) {
                        var _this = this, dirname = g.PathUtil.resolveDirname(path), virtualPath = game._assetManager._liveAbsolutePathTable[path], virtualDirname = virtualPath ? g.PathUtil.resolveDirname(virtualPath) : void 0, _g = Object.create(g, {
                            game: {
                                value: game,
                                enumerable: !0
                            },
                            filename: {
                                value: path,
                                enumerable: !0
                            },
                            dirname: {
                                value: dirname,
                                enumerable: !0
                            },
                            module: {
                                value: this,
                                writable: !0,
                                enumerable: !0,
                                configurable: !0
                            }
                        });
                        this.id = id, this.filename = path, this.exports = {}, this.parent = null, this.loaded = !1, 
                        this.children = [], this.paths = virtualDirname ? g.PathUtil.makeNodeModulePaths(virtualDirname) : [], 
                        this._dirname = dirname, this._virtualDirname = virtualDirname, this._g = _g, this.require = function(path) {
                            return "g" === path ? _g : g._require(game, path, _this);
                        };
                    }
                    return Module;
                }();
                g.Module = Module;
            }(g || (g = {}));
            var g;
            !function(g) {
                var ScriptAssetContext = function() {
                    function ScriptAssetContext(game, asset) {
                        this._game = game, this._asset = asset, this._module = new g.Module(game, asset.path, asset.path), 
                        this._g = this._module._g, this._started = !1;
                    }
                    return ScriptAssetContext.prototype._cachedValue = function() {
                        if (!this._started) throw g.ExceptionFactory.createAssertionError("ScriptAssetContext#_cachedValue: not executed yet.");
                        return this._module.exports;
                    }, ScriptAssetContext.prototype._executeScript = function(currentModule) {
                        return this._started ? this._module.exports : (currentModule && (this._module.parent = currentModule, 
                        currentModule.children.push(this._module)), this._started = !0, this._asset.execute(this._g), 
                        this._module.loaded = !0, this._module.exports);
                    }, ScriptAssetContext;
                }();
                g.ScriptAssetContext = ScriptAssetContext;
            }(g || (g = {}));
            var g;
            !function(g) {
                var PlainMatrix = function() {
                    function PlainMatrix(widthOrSrc, height, scaleX, scaleY, angle) {
                        void 0 === widthOrSrc ? (this._modified = !1, this._matrix = [ 1, 0, 0, 1, 0, 0 ]) : "number" == typeof widthOrSrc ? (this._modified = !1, 
                        this._matrix = new Array(6), this.update(widthOrSrc, height, scaleX, scaleY, angle, 0, 0)) : (this._modified = widthOrSrc._modified, 
                        this._matrix = [ widthOrSrc._matrix[0], widthOrSrc._matrix[1], widthOrSrc._matrix[2], widthOrSrc._matrix[3], widthOrSrc._matrix[4], widthOrSrc._matrix[5] ]);
                    }
                    return PlainMatrix.prototype.update = function(width, height, scaleX, scaleY, angle, x, y) {
                        var r = angle * Math.PI / 180, _cos = Math.cos(r), _sin = Math.sin(r), a = _cos * scaleX, b = _sin * scaleX, c = _sin * scaleY, d = _cos * scaleY, w = width / 2, h = height / 2;
                        this._matrix[0] = a, this._matrix[1] = b, this._matrix[2] = -c, this._matrix[3] = d, 
                        this._matrix[4] = -a * w + c * h + w + x, this._matrix[5] = -b * w - d * h + h + y;
                    }, PlainMatrix.prototype.updateByInverse = function(width, height, scaleX, scaleY, angle, x, y) {
                        var r = angle * Math.PI / 180, _cos = Math.cos(r), _sin = Math.sin(r), a = _cos / scaleX, b = _sin / scaleY, c = _sin / scaleX, d = _cos / scaleY, w = width / 2, h = height / 2;
                        this._matrix[0] = a, this._matrix[1] = -b, this._matrix[2] = c, this._matrix[3] = d, 
                        this._matrix[4] = -a * (w + x) - c * (h + y) + w, this._matrix[5] = b * (w + x) - d * (h + y) + h;
                    }, PlainMatrix.prototype.multiply = function(matrix) {
                        var m1 = this._matrix, m2 = matrix._matrix, m10 = m1[0], m11 = m1[1], m12 = m1[2], m13 = m1[3];
                        m1[0] = m10 * m2[0] + m12 * m2[1], m1[1] = m11 * m2[0] + m13 * m2[1], m1[2] = m10 * m2[2] + m12 * m2[3], 
                        m1[3] = m11 * m2[2] + m13 * m2[3], m1[4] = m10 * m2[4] + m12 * m2[5] + m1[4], m1[5] = m11 * m2[4] + m13 * m2[5] + m1[5];
                    }, PlainMatrix.prototype.multiplyNew = function(matrix) {
                        var ret = this.clone();
                        return ret.multiply(matrix), ret;
                    }, PlainMatrix.prototype.reset = function(x, y) {
                        this._matrix[0] = 1, this._matrix[1] = 0, this._matrix[2] = 0, this._matrix[3] = 1, 
                        this._matrix[4] = x || 0, this._matrix[5] = y || 0;
                    }, PlainMatrix.prototype.clone = function() {
                        return new PlainMatrix(this);
                    }, PlainMatrix.prototype.multiplyInverseForPoint = function(point) {
                        var m = this._matrix, _id = 1 / (m[0] * m[3] + m[2] * -m[1]);
                        return {
                            x: m[3] * _id * point.x + -m[2] * _id * point.y + (m[5] * m[2] - m[4] * m[3]) * _id,
                            y: m[0] * _id * point.y + -m[1] * _id * point.x + (-m[5] * m[0] + m[4] * m[1]) * _id
                        };
                    }, PlainMatrix.prototype.scale = function(x, y) {
                        var m = this._matrix;
                        m[0] *= x, m[1] *= y, m[2] *= x, m[3] *= y, m[4] *= x, m[5] *= y;
                    }, PlainMatrix.prototype.multiplyPoint = function(point) {
                        var m = this._matrix, x = m[0] * point.x + m[2] * point.y + m[4], y = m[1] * point.x + m[3] * point.y + m[5];
                        return {
                            x: x,
                            y: y
                        };
                    }, PlainMatrix;
                }();
                g.PlainMatrix = PlainMatrix;
            }(g || (g = {}));
            var g;
            !function(g) {
                var Util;
                !function(Util) {
                    function distance(p1x, p1y, p2x, p2y) {
                        return Math.sqrt(Math.pow(p1x - p2x, 2) + Math.pow(p1y - p2y, 2));
                    }
                    function distanceBetweenOffsets(p1, p2) {
                        return Util.distance(p1.x, p1.y, p2.x, p2.y);
                    }
                    function distanceBetweenAreas(p1, p2) {
                        return Util.distance(p1.x - p1.width / 2, p1.y - p1.height / 2, p2.x - p2.width / 2, p2.y - p2.height / 2);
                    }
                    function createMatrix(width, height, scaleX, scaleY, angle) {
                        return void 0 === width ? new g.PlainMatrix() : new g.PlainMatrix(width, height, scaleX, scaleY, angle);
                    }
                    function createSpriteFromE(scene, e, camera) {
                        var oldX = e.x, oldY = e.y, x = 0, y = 0, width = e.width, height = e.height, boundingRect = e.calculateBoundingRect(camera);
                        if (!boundingRect) throw g.ExceptionFactory.createAssertionError("Util#createSpriteFromE: camera must look e");
                        width = boundingRect.right - boundingRect.left, height = boundingRect.bottom - boundingRect.top, 
                        boundingRect.left < e.x && (x = e.x - boundingRect.left), boundingRect.top < e.y && (y = e.y - boundingRect.top), 
                        e.moveTo(x, y), e._matrix && (e._matrix._modified = !0);
                        var surface = scene.game.resourceFactory.createSurface(Math.ceil(width), Math.ceil(height)), renderer = surface.renderer();
                        renderer.begin(), e.render(renderer, camera), renderer.end();
                        var s = new g.Sprite({
                            scene: scene,
                            src: surface,
                            width: width,
                            height: height
                        });
                        return s.moveTo(boundingRect.left, boundingRect.top), e.moveTo(oldX, oldY), e._matrix && (e._matrix._modified = !0), 
                        s;
                    }
                    function createSpriteFromScene(toScene, fromScene, camera) {
                        var surface = toScene.game.resourceFactory.createSurface(Math.ceil(fromScene.game.width), Math.ceil(fromScene.game.height)), renderer = surface.renderer();
                        renderer.begin();
                        for (var children = fromScene.children, i = 0; i < children.length; ++i) children[i].render(renderer, camera);
                        return renderer.end(), new g.Sprite({
                            scene: toScene,
                            src: surface,
                            width: fromScene.game.width,
                            height: fromScene.game.height
                        });
                    }
                    function asSurface(src) {
                        if (!src) return src;
                        if (src instanceof g.Surface) return src;
                        if (src instanceof g.ImageAsset) return src.asSurface();
                        throw g.ExceptionFactory.createTypeMismatchError("Util#asSurface", "ImageAsset|Surface", src);
                    }
                    function findAssetByPathAsFile(resolvedPath, liveAssetPathTable) {
                        return liveAssetPathTable.hasOwnProperty(resolvedPath) ? liveAssetPathTable[resolvedPath] : liveAssetPathTable.hasOwnProperty(resolvedPath + ".js") ? liveAssetPathTable[resolvedPath + ".js"] : void 0;
                    }
                    function findAssetByPathAsDirectory(resolvedPath, liveAssetPathTable) {
                        var path;
                        if (path = resolvedPath + "/package.json", liveAssetPathTable.hasOwnProperty(path) && liveAssetPathTable[path] instanceof g.TextAsset) {
                            var pkg = JSON.parse(liveAssetPathTable[path].data);
                            if (pkg && "string" == typeof pkg.main) {
                                var asset = Util.findAssetByPathAsFile(g.PathUtil.resolvePath(resolvedPath, pkg.main), liveAssetPathTable);
                                if (asset) return asset;
                            }
                        }
                        return path = resolvedPath + "/index.js", liveAssetPathTable.hasOwnProperty(path) ? liveAssetPathTable[path] : void 0;
                    }
                    function charCodeAt(str, idx) {
                        var code = str.charCodeAt(idx);
                        if (code >= 55296 && 56319 >= code) {
                            var hi = code, low = str.charCodeAt(idx + 1);
                            return hi << 16 | low;
                        }
                        return code >= 56320 && 57343 >= code ? null : code;
                    }
                    function setupAnimatingHandler(animatingHandler, surface) {
                        surface.isDynamic && (surface.animatingStarted.add(animatingHandler._onAnimatingStarted, animatingHandler), 
                        surface.animatingStopped.add(animatingHandler._onAnimatingStopped, animatingHandler), 
                        surface.isPlaying() && animatingHandler._onAnimatingStarted());
                    }
                    function migrateAnimatingHandler(animatingHandler, beforeSurface, afterSurface) {
                        animatingHandler._onAnimatingStopped(), !beforeSurface.destroyed() && beforeSurface.isDynamic && (beforeSurface.animatingStarted.remove(animatingHandler._onAnimatingStarted, animatingHandler), 
                        beforeSurface.animatingStopped.remove(animatingHandler._onAnimatingStopped, animatingHandler)), 
                        afterSurface.isDynamic && (afterSurface.animatingStarted.add(animatingHandler._onAnimatingStarted, animatingHandler), 
                        afterSurface.animatingStopped.add(animatingHandler._onAnimatingStopped, animatingHandler), 
                        afterSurface.isPlaying() && animatingHandler._onAnimatingStarted());
                    }
                    Util.distance = distance, Util.distanceBetweenOffsets = distanceBetweenOffsets, 
                    Util.distanceBetweenAreas = distanceBetweenAreas, Util.createMatrix = createMatrix, 
                    Util.createSpriteFromE = createSpriteFromE, Util.createSpriteFromScene = createSpriteFromScene, 
                    Util.asSurface = asSurface, Util.findAssetByPathAsFile = findAssetByPathAsFile, 
                    Util.findAssetByPathAsDirectory = findAssetByPathAsDirectory, Util.charCodeAt = charCodeAt, 
                    Util.setupAnimatingHandler = setupAnimatingHandler, Util.migrateAnimatingHandler = migrateAnimatingHandler;
                }(Util = g.Util || (g.Util = {}));
            }(g || (g = {}));
            var g;
            !function(g) {
                var Collision;
                !function(Collision) {
                    function intersect(x1, y1, width1, height1, x2, y2, width2, height2) {
                        return x2 + width2 >= x1 && x1 + width1 >= x2 && y2 + height2 >= y1 && y1 + height1 >= y2;
                    }
                    function intersectAreas(t1, t2) {
                        return Collision.intersect(t1.x, t1.y, t1.width, t1.height, t2.x, t2.y, t2.width, t2.height);
                    }
                    function within(t1x, t1y, t2x, t2y, distance) {
                        return void 0 === distance && (distance = 1), distance >= g.Util.distance(t1x, t1y, t2x, t2y);
                    }
                    function withinAreas(t1, t2, distance) {
                        return void 0 === distance && (distance = 1), distance >= g.Util.distanceBetweenAreas(t1, t2);
                    }
                    Collision.intersect = intersect, Collision.intersectAreas = intersectAreas, Collision.within = within, 
                    Collision.withinAreas = withinAreas;
                }(Collision = g.Collision || (g.Collision = {}));
            }(g || (g = {}));
            var g;
            !function(g) {
                var Trigger = function() {
                    function Trigger() {
                        this._handlers = [], this.length = 0;
                    }
                    return Trigger.prototype.add = function(paramsOrFunc, owner) {
                        if ("function" == typeof paramsOrFunc) this._handlers.push({
                            func: paramsOrFunc,
                            owner: owner,
                            once: !1,
                            name: void 0
                        }); else {
                            var params = paramsOrFunc;
                            "number" == typeof params.index ? this._handlers.splice(params.index, 0, {
                                func: params.func,
                                owner: params.owner,
                                once: !1,
                                name: params.name
                            }) : this._handlers.push({
                                func: params.func,
                                owner: params.owner,
                                once: !1,
                                name: params.name
                            });
                        }
                        this.length = this._handlers.length;
                    }, Trigger.prototype.addOnce = function(paramsOrFunc, owner) {
                        if ("function" == typeof paramsOrFunc) this._handlers.push({
                            func: paramsOrFunc,
                            owner: owner,
                            once: !0,
                            name: void 0
                        }); else {
                            var params = paramsOrFunc;
                            "number" == typeof params.index ? this._handlers.splice(params.index, 0, {
                                func: params.func,
                                owner: params.owner,
                                once: !0,
                                name: params.name
                            }) : this._handlers.push({
                                func: params.func,
                                owner: params.owner,
                                once: !0,
                                name: params.name
                            });
                        }
                        this.length = this._handlers.length;
                    }, Trigger.prototype.handle = function(owner, func, name) {
                        this.add(func ? {
                            owner: owner,
                            func: func,
                            name: name
                        } : {
                            func: owner
                        });
                    }, Trigger.prototype.fire = function(arg) {
                        if (this._handlers.length) {
                            for (var handlers = this._handlers.concat(), i = 0; i < handlers.length; i++) {
                                var handler = handlers[i];
                                if (handler.func.call(handler.owner, arg) || handler.once) {
                                    var index = this._handlers.indexOf(handler);
                                    -1 !== index && this._handlers.splice(index, 1);
                                }
                            }
                            this._handlers && (this.length = this._handlers.length);
                        }
                    }, Trigger.prototype.contains = function(paramsOrFunc, owner) {
                        for (var condition = "function" == typeof paramsOrFunc ? {
                            func: paramsOrFunc,
                            owner: owner
                        } : paramsOrFunc, i = 0; i < this._handlers.length; i++) if (this._comparePartial(condition, this._handlers[i])) return !0;
                        return !1;
                    }, Trigger.prototype.remove = function(paramsOrFunc, owner) {
                        for (var condition = "function" == typeof paramsOrFunc ? {
                            func: paramsOrFunc,
                            owner: owner
                        } : paramsOrFunc, i = 0; i < this._handlers.length; i++) {
                            var handler = this._handlers[i];
                            if (condition.func === handler.func && condition.owner === handler.owner && condition.name === handler.name) return this._handlers.splice(i, 1), 
                            void --this.length;
                        }
                    }, Trigger.prototype.removeAll = function(params) {
                        var handlers = [];
                        if (params) for (var i = 0; i < this._handlers.length; i++) {
                            var handler = this._handlers[i];
                            this._comparePartial(params, handler) || handlers.push(handler);
                        }
                        this._handlers = handlers, this.length = this._handlers.length;
                    }, Trigger.prototype.destroy = function() {
                        this._handlers = null, this.length = null;
                    }, Trigger.prototype.destroyed = function() {
                        return null === this._handlers;
                    }, Trigger.prototype._comparePartial = function(target, compare) {
                        return void 0 !== target.func && target.func !== compare.func ? !1 : void 0 !== target.owner && target.owner !== compare.owner ? !1 : void 0 !== target.name && target.name !== compare.name ? !1 : !0;
                    }, Trigger;
                }();
                g.Trigger = Trigger;
                var ChainTrigger = function(_super) {
                    function ChainTrigger(chain, filter, filterOwner) {
                        var _this = _super.call(this) || this;
                        return _this.chain = chain, _this.filter = filter, _this.filterOwner = filterOwner, 
                        _this._isActivated = !1, _this;
                    }
                    return __extends(ChainTrigger, _super), ChainTrigger.prototype.add = function(paramsOrHandler, owner) {
                        _super.prototype.add.call(this, paramsOrHandler, owner), this._isActivated || (this.chain.add(this._onChainTriggerFired, this), 
                        this._isActivated = !0);
                    }, ChainTrigger.prototype.addOnce = function(paramsOrHandler, owner) {
                        _super.prototype.addOnce.call(this, paramsOrHandler, owner), this._isActivated || (this.chain.add(this._onChainTriggerFired, this), 
                        this._isActivated = !0);
                    }, ChainTrigger.prototype.remove = function(paramsOrFunc, owner) {
                        _super.prototype.remove.call(this, paramsOrFunc, owner), 0 === this.length && this._isActivated && (this.chain.remove(this._onChainTriggerFired, this), 
                        this._isActivated = !1);
                    }, ChainTrigger.prototype.removeAll = function(params) {
                        _super.prototype.removeAll.call(this, params), 0 === this.length && this._isActivated && (this.chain.remove(this._onChainTriggerFired, this), 
                        this._isActivated = !1);
                    }, ChainTrigger.prototype.destroy = function() {
                        _super.prototype.destroy.call(this), this.chain.remove(this._onChainTriggerFired, this), 
                        this.filter = null, this.filterOwner = null, this._isActivated = !1;
                    }, ChainTrigger.prototype._onChainTriggerFired = function(args) {
                        (!this.filter || this.filter.call(this.filterOwner, args)) && this.fire(args);
                    }, ChainTrigger;
                }(Trigger);
                g.ChainTrigger = ChainTrigger;
            }(g || (g = {}));
            var g;
            !function(g) {
                var Timer = function() {
                    function Timer(interval, fps) {
                        this.interval = interval, this._scaledInterval = Math.round(interval * fps), this.elapsed = new g.Trigger(), 
                        this._scaledElapsed = 0;
                    }
                    return Timer.prototype.tick = function() {
                        for (this._scaledElapsed += 1e3; this._scaledElapsed >= this._scaledInterval && this.elapsed; ) this.elapsed.fire(), 
                        this._scaledElapsed -= this._scaledInterval;
                    }, Timer.prototype.canDelete = function() {
                        return !this.elapsed || 0 === this.elapsed.length;
                    }, Timer.prototype.destroy = function() {
                        this.interval = void 0, this.elapsed.destroy(), this.elapsed = void 0, this._scaledInterval = 0, 
                        this._scaledElapsed = 0;
                    }, Timer.prototype.destroyed = function() {
                        return void 0 === this.elapsed;
                    }, Timer;
                }();
                g.Timer = Timer;
            }(g || (g = {}));
            var g;
            !function(g) {
                var TimerIdentifier = function() {
                    function TimerIdentifier(timer, handler, handlerOwner, fired, firedOwner) {
                        this._timer = timer, this._handler = handler, this._handlerOwner = handlerOwner, 
                        this._fired = fired, this._firedOwner = firedOwner, this._timer.elapsed.add(this._fire, this);
                    }
                    return TimerIdentifier.prototype.destroy = function() {
                        this._timer.elapsed.remove(this._fire, this), this._timer = void 0, this._handler = void 0, 
                        this._handlerOwner = void 0, this._fired = void 0, this._firedOwner = void 0;
                    }, TimerIdentifier.prototype.destroyed = function() {
                        return void 0 === this._timer;
                    }, TimerIdentifier.prototype._fire = function() {
                        this._handler.call(this._handlerOwner), this._fired && this._fired.call(this._firedOwner, this);
                    }, TimerIdentifier;
                }();
                g.TimerIdentifier = TimerIdentifier;
                var TimerManager = function() {
                    function TimerManager(trigger, fps) {
                        this._timers = [], this._trigger = trigger, this._identifiers = [], this._fps = fps, 
                        this._registered = !1;
                    }
                    return TimerManager.prototype.destroy = function() {
                        for (var i = 0; i < this._identifiers.length; ++i) this._identifiers[i].destroy();
                        for (var i = 0; i < this._timers.length; ++i) this._timers[i].destroy();
                        this._timers = void 0, this._trigger = void 0, this._identifiers = void 0, this._fps = void 0;
                    }, TimerManager.prototype.destroyed = function() {
                        return void 0 === this._timers;
                    }, TimerManager.prototype.createTimer = function(interval) {
                        if (this._registered || (this._trigger.add(this._tick, this), this._registered = !0), 
                        0 > interval) throw g.ExceptionFactory.createAssertionError("TimerManager#createTimer: invalid interval");
                        1 > interval && (interval = 1);
                        for (var acceptableMargin = Math.min(1e3, interval * this._fps), i = 0; i < this._timers.length; ++i) if (this._timers[i].interval === interval && this._timers[i]._scaledElapsed < acceptableMargin) return this._timers[i];
                        var timer = new g.Timer(interval, this._fps);
                        return this._timers.push(timer), timer;
                    }, TimerManager.prototype.deleteTimer = function(timer) {
                        if (timer.canDelete()) {
                            var index = this._timers.indexOf(timer);
                            if (0 > index) throw g.ExceptionFactory.createAssertionError("TimerManager#deleteTimer: can not find timer");
                            if (this._timers.splice(index, 1), timer.destroy(), !this._timers.length) {
                                if (!this._registered) throw g.ExceptionFactory.createAssertionError("TimerManager#deleteTimer: handler is not handled");
                                this._trigger.remove(this._tick, this), this._registered = !1;
                            }
                        }
                    }, TimerManager.prototype.setTimeout = function(handler, milliseconds, owner) {
                        var timer = this.createTimer(milliseconds), identifier = new TimerIdentifier(timer, handler, owner, this._onTimeoutFired, this);
                        return this._identifiers.push(identifier), identifier;
                    }, TimerManager.prototype.clearTimeout = function(identifier) {
                        this._clear(identifier);
                    }, TimerManager.prototype.setInterval = function(handler, interval, owner) {
                        var timer = this.createTimer(interval), identifier = new TimerIdentifier(timer, handler, owner);
                        return this._identifiers.push(identifier), identifier;
                    }, TimerManager.prototype.clearInterval = function(identifier) {
                        this._clear(identifier);
                    }, TimerManager.prototype._tick = function() {
                        for (var timers = this._timers.concat(), i = 0; i < timers.length; ++i) timers[i].tick();
                    }, TimerManager.prototype._onTimeoutFired = function(identifier) {
                        var index = this._identifiers.indexOf(identifier);
                        if (0 > index) throw g.ExceptionFactory.createAssertionError("TimerManager#_onTimeoutFired: can not find identifier");
                        this._identifiers.splice(index, 1);
                        var timer = identifier._timer;
                        identifier.destroy(), this.deleteTimer(timer);
                    }, TimerManager.prototype._clear = function(identifier) {
                        var index = this._identifiers.indexOf(identifier);
                        if (0 > index) throw g.ExceptionFactory.createAssertionError("TimerManager#_clear: can not find identifier");
                        if (identifier.destroyed()) throw g.ExceptionFactory.createAssertionError("TimerManager#_clear: invalid identifier");
                        this._identifiers.splice(index, 1);
                        var timer = identifier._timer;
                        identifier.destroy(), this.deleteTimer(timer);
                    }, TimerManager;
                }();
                g.TimerManager = TimerManager;
            }(g || (g = {}));
            var g;
            !function(g) {
                var AudioPlayer = function() {
                    function AudioPlayer(system) {
                        this.played = new g.Trigger(), this.stopped = new g.Trigger(), this.currentAudio = void 0, 
                        this.volume = system.volume, this._muted = system._muted, this._playbackRate = system._playbackRate, 
                        this._system = system;
                    }
                    return AudioPlayer.prototype.play = function(audio) {
                        this.currentAudio = audio, this.played.fire({
                            player: this,
                            audio: audio
                        });
                    }, AudioPlayer.prototype.stop = function() {
                        var audio = this.currentAudio;
                        this.currentAudio = void 0, this.stopped.fire({
                            player: this,
                            audio: audio
                        });
                    }, AudioPlayer.prototype.canHandleStopped = function() {
                        return !0;
                    }, AudioPlayer.prototype.changeVolume = function(volume) {
                        this.volume = volume;
                    }, AudioPlayer.prototype._changeMuted = function(muted) {
                        this._muted = muted;
                    }, AudioPlayer.prototype._changePlaybackRate = function(rate) {
                        this._playbackRate = rate;
                    }, AudioPlayer.prototype._supportsPlaybackRate = function() {
                        return !1;
                    }, AudioPlayer.prototype._onVolumeChanged = function() {}, AudioPlayer;
                }();
                g.AudioPlayer = AudioPlayer;
            }(g || (g = {}));
            var g;
            !function(g) {
                var AudioSystem = function() {
                    function AudioSystem(id, game) {
                        var audioSystemManager = game._audioSystemManager;
                        this.id = id, this.game = game, this._volume = 1, this._destroyRequestedAssets = {}, 
                        this._muted = audioSystemManager._muted, this._playbackRate = audioSystemManager._playbackRate;
                    }
                    return Object.defineProperty(AudioSystem.prototype, "volume", {
                        get: function() {
                            return this._volume;
                        },
                        set: function(value) {
                            if (0 > value || value > 1 || isNaN(value) || "number" != typeof value) throw g.ExceptionFactory.createAssertionError("AudioSystem#volume: expected: 0.0-1.0, actual: " + value);
                            this._volume = value, this._onVolumeChanged();
                        },
                        enumerable: !0,
                        configurable: !0
                    }), AudioSystem.prototype.requestDestroy = function(asset) {
                        this._destroyRequestedAssets[asset.id] = asset;
                    }, AudioSystem.prototype._setMuted = function(value) {
                        var before = this._muted;
                        this._muted = !!value, this._muted !== before && this._onMutedChanged();
                    }, AudioSystem.prototype._setPlaybackRate = function(value) {
                        if (0 > value || isNaN(value) || "number" != typeof value) throw g.ExceptionFactory.createAssertionError("AudioSystem#playbackRate: expected: greater or equal to 0.0, actual: " + value);
                        var before = this._playbackRate;
                        this._playbackRate = value, this._playbackRate !== before && this._onPlaybackRateChanged();
                    }, AudioSystem;
                }();
                g.AudioSystem = AudioSystem;
                var MusicAudioSystem = function(_super) {
                    function MusicAudioSystem(id, game) {
                        var _this = _super.call(this, id, game) || this;
                        return _this._player = void 0, _this._suppressingAudio = void 0, _this;
                    }
                    return __extends(MusicAudioSystem, _super), Object.defineProperty(MusicAudioSystem.prototype, "player", {
                        get: function() {
                            return this._player || (this._player = this.game.resourceFactory.createAudioPlayer(this), 
                            this._player.played.handle(this, this._onPlayerPlayed), this._player.stopped.handle(this, this._onPlayerStopped)), 
                            this._player;
                        },
                        set: function(v) {
                            this._player = v;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), MusicAudioSystem.prototype.findPlayers = function(asset) {
                        return this.player.currentAudio && this.player.currentAudio.id === asset.id ? [ this.player ] : [];
                    }, MusicAudioSystem.prototype.createPlayer = function() {
                        return this.player;
                    }, MusicAudioSystem.prototype.stopAll = function() {
                        this._player && this._player.stop();
                    }, MusicAudioSystem.prototype._onVolumeChanged = function() {
                        this.player.changeVolume(this._volume);
                    }, MusicAudioSystem.prototype._onMutedChanged = function() {
                        this.player._changeMuted(this._muted);
                    }, MusicAudioSystem.prototype._onPlaybackRateChanged = function() {
                        var player = this.player;
                        player._changePlaybackRate(this._playbackRate), player._supportsPlaybackRate() || this._onUnsupportedPlaybackRateChanged();
                    }, MusicAudioSystem.prototype._onUnsupportedPlaybackRateChanged = function() {
                        if (1 === this._playbackRate && this._suppressingAudio) {
                            var audio = this._suppressingAudio;
                            this._suppressingAudio = void 0, audio.destroyed() || this.player.play(audio);
                        }
                    }, MusicAudioSystem.prototype._onPlayerPlayed = function(e) {
                        if (e.player !== this._player) throw g.ExceptionFactory.createAssertionError("MusicAudioSystem#_onPlayerPlayed: unexpected audio player");
                        e.player._supportsPlaybackRate() || 1 !== this._playbackRate && (e.player.stop(), 
                        this._suppressingAudio = e.audio);
                    }, MusicAudioSystem.prototype._onPlayerStopped = function(e) {
                        this._destroyRequestedAssets[e.audio.id] && (delete this._destroyRequestedAssets[e.audio.id], 
                        e.audio.destroy());
                    }, MusicAudioSystem;
                }(AudioSystem);
                g.MusicAudioSystem = MusicAudioSystem;
                var SoundAudioSystem = function(_super) {
                    function SoundAudioSystem(id, game) {
                        var _this = _super.call(this, id, game) || this;
                        return _this.players = [], _this;
                    }
                    return __extends(SoundAudioSystem, _super), SoundAudioSystem.prototype.createPlayer = function() {
                        var player = this.game.resourceFactory.createAudioPlayer(this);
                        return player.canHandleStopped() && this.players.push(player), player.played.handle(this, this._onPlayerPlayed), 
                        player.stopped.handle(this, this._onPlayerStopped), player;
                    }, SoundAudioSystem.prototype.findPlayers = function(asset) {
                        for (var ret = [], i = 0; i < this.players.length; ++i) this.players[i].currentAudio && this.players[i].currentAudio.id === asset.id && ret.push(this.players[i]);
                        return ret;
                    }, SoundAudioSystem.prototype.stopAll = function() {
                        for (var players = this.players.concat(), i = 0; i < players.length; ++i) players[i].stop();
                    }, SoundAudioSystem.prototype._onMutedChanged = function() {
                        for (var players = this.players, i = 0; i < players.length; ++i) players[i]._changeMuted(this._muted);
                    }, SoundAudioSystem.prototype._onPlaybackRateChanged = function() {
                        for (var players = this.players, i = 0; i < players.length; ++i) players[i]._changePlaybackRate(this._playbackRate);
                    }, SoundAudioSystem.prototype._onPlayerPlayed = function(e) {
                        e.player._supportsPlaybackRate() || 1 !== this._playbackRate && e.player.stop();
                    }, SoundAudioSystem.prototype._onPlayerStopped = function(e) {
                        var index = this.players.indexOf(e.player);
                        0 > index || (e.player.stopped.remove({
                            owner: this,
                            func: this._onPlayerStopped
                        }), this.players.splice(index, 1), this._destroyRequestedAssets[e.audio.id] && (delete this._destroyRequestedAssets[e.audio.id], 
                        e.audio.destroy()));
                    }, SoundAudioSystem.prototype._onVolumeChanged = function() {
                        for (var i = 0; i < this.players.length; ++i) this.players[i].changeVolume(this._volume);
                    }, SoundAudioSystem;
                }(AudioSystem);
                g.SoundAudioSystem = SoundAudioSystem;
            }(g || (g = {}));
            var g;
            !function(g) {
                var VideoPlayer = function() {
                    function VideoPlayer(loop) {
                        this._loop = !!loop, this.played = new g.Trigger(), this.stopped = new g.Trigger(), 
                        this.currentVideo = void 0, this.volume = 1;
                    }
                    return VideoPlayer.prototype.play = function(videoAsset) {
                        this.currentVideo = videoAsset, this.played.fire({
                            player: this,
                            video: videoAsset
                        }), videoAsset.asSurface().animatingStarted.fire();
                    }, VideoPlayer.prototype.stop = function() {
                        var videoAsset = this.currentVideo;
                        this.stopped.fire({
                            player: this,
                            video: videoAsset
                        }), videoAsset.asSurface().animatingStopped.fire();
                    }, VideoPlayer.prototype.changeVolume = function(volume) {
                        this.volume = volume;
                    }, VideoPlayer;
                }();
                g.VideoPlayer = VideoPlayer;
            }(g || (g = {}));
            var g;
            !function(g) {
                var VideoSystem = function() {
                    function VideoSystem() {}
                    return VideoSystem;
                }();
                g.VideoSystem = VideoSystem;
            }(g || (g = {}));
            var g;
            !function(g) {
                var Object2D = function() {
                    function Object2D(param) {
                        param ? (this.x = param.x || 0, this.y = param.y || 0, this.width = param.width || 0, 
                        this.height = param.height || 0, this.opacity = "opacity" in param ? param.opacity : 1, 
                        this.scaleX = "scaleX" in param ? param.scaleX : 1, this.scaleY = "scaleY" in param ? param.scaleY : 1, 
                        this.angle = param.angle || 0, this.compositeOperation = param.compositeOperation, 
                        this._matrix = void 0) : (this.x = 0, this.y = 0, this.width = 0, this.height = 0, 
                        this.opacity = 1, this.scaleX = 1, this.scaleY = 1, this.angle = 0, this.compositeOperation = void 0, 
                        this._matrix = void 0);
                    }
                    return Object2D.prototype.moveTo = function(posOrX, y) {
                        if ("number" == typeof posOrX && "number" != typeof y) throw g.ExceptionFactory.createAssertionError("Object2D#moveTo: arguments must be CommonOffset or pair of x and y as a number.");
                        "number" == typeof posOrX ? (this.x = posOrX, this.y = y) : (this.x = posOrX.x, 
                        this.y = posOrX.y);
                    }, Object2D.prototype.moveBy = function(x, y) {
                        this.x += x, this.y += y;
                    }, Object2D.prototype.resizeTo = function(sizeOrWidth, height) {
                        if ("number" == typeof sizeOrWidth && "number" != typeof height) throw g.ExceptionFactory.createAssertionError("Object2D#resizeTo: arguments must be CommonSize or pair of width and height as a number.");
                        "number" == typeof sizeOrWidth ? (this.width = sizeOrWidth, this.height = height) : (this.width = sizeOrWidth.width, 
                        this.height = sizeOrWidth.height);
                    }, Object2D.prototype.resizeBy = function(width, height) {
                        this.width += width, this.height += height;
                    }, Object2D.prototype.scale = function(scale) {
                        this.scaleX = scale, this.scaleY = scale;
                    }, Object2D.prototype.getMatrix = function() {
                        if (this._matrix) {
                            if (!this._matrix._modified) return this._matrix;
                        } else this._matrix = g.Util.createMatrix();
                        return this._updateMatrix(), this._matrix._modified = !1, this._matrix;
                    }, Object2D.prototype._updateMatrix = function() {
                        this.angle || 1 !== this.scaleX || 1 !== this.scaleY ? this._matrix.update(this.width, this.height, this.scaleX, this.scaleY, this.angle, this.x, this.y) : this._matrix.reset(this.x, this.y);
                    }, Object2D;
                }();
                g.Object2D = Object2D;
            }(g || (g = {}));
            var g;
            !function(g) {
                var E = function(_super) {
                    function E(param) {
                        var _this = _super.call(this, param) || this;
                        if (_this.children = void 0, _this.parent = void 0, _this._touchable = !1, _this.state = 0, 
                        _this._hasTouchableChildren = !1, _this._update = void 0, _this._message = void 0, 
                        _this._pointDown = void 0, _this._pointMove = void 0, _this._pointUp = void 0, _this._targetCameras = void 0, 
                        _this.tag = param.tag, _this.local = param.scene.local !== g.LocalTickMode.NonLocal || !!param.local, 
                        param.children) for (var i = 0; i < param.children.length; ++i) _this.append(param.children[i]);
                        return param.parent && param.parent.append(_this), param.targetCameras && (_this.targetCameras = param.targetCameras), 
                        "touchable" in param && (_this.touchable = param.touchable), param.hidden && _this.hide(), 
                        _this.id = param.id, param.scene.register(_this), _this;
                    }
                    return __extends(E, _super), Object.defineProperty(E.prototype, "update", {
                        get: function() {
                            return this._update || (this._update = new g.ChainTrigger(this.scene.update)), this._update;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(E.prototype, "message", {
                        get: function() {
                            return this._message || (this._message = new g.ChainTrigger(this.scene.message)), 
                            this._message;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(E.prototype, "pointDown", {
                        get: function() {
                            return this._pointDown || (this._pointDown = new g.ChainTrigger(this.scene.pointDownCapture, this._isTargetOperation, this)), 
                            this._pointDown;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(E.prototype, "pointUp", {
                        get: function() {
                            return this._pointUp || (this._pointUp = new g.ChainTrigger(this.scene.pointUpCapture, this._isTargetOperation, this)), 
                            this._pointUp;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(E.prototype, "pointMove", {
                        get: function() {
                            return this._pointMove || (this._pointMove = new g.ChainTrigger(this.scene.pointMoveCapture, this._isTargetOperation, this)), 
                            this._pointMove;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(E.prototype, "targetCameras", {
                        get: function() {
                            return this._targetCameras || (this._targetCameras = []);
                        },
                        set: function(v) {
                            this._targetCameras = v;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(E.prototype, "touchable", {
                        get: function() {
                            return this._touchable;
                        },
                        set: function(v) {
                            this._touchable !== v && (this._touchable = v, v ? this._enableTouchPropagation() : this._disableTouchPropagation());
                        },
                        enumerable: !0,
                        configurable: !0
                    }), E.prototype.render = function(renderer, camera) {
                        if (this.state &= -5, !(1 & this.state)) {
                            var cams = this._targetCameras;
                            if (!(cams && cams.length > 0) || camera && -1 !== cams.indexOf(camera)) {
                                if (8 & this.state) {
                                    renderer.translate(this.x, this.y);
                                    var goDown = this.renderSelf(renderer, camera);
                                    if (goDown && this.children) for (var children = this.children, len = children.length, i = 0; len > i; ++i) children[i].render(renderer, camera);
                                    return void renderer.translate(-this.x, -this.y);
                                }
                                renderer.save(), this.angle || 1 !== this.scaleX || 1 !== this.scaleY ? renderer.transform(this.getMatrix()._matrix) : renderer.translate(this.x, this.y), 
                                1 !== this.opacity && renderer.opacity(this.opacity), void 0 !== this.compositeOperation && renderer.setCompositeOperation(this.compositeOperation);
                                var goDown = this.renderSelf(renderer, camera);
                                if (goDown && this.children) for (var children = this.children, i = 0; i < children.length; ++i) children[i].render(renderer, camera);
                                renderer.restore();
                            }
                        }
                    }, E.prototype.renderSelf = function(renderer, camera) {
                        return !0;
                    }, E.prototype.game = function() {
                        return this.scene.game;
                    }, E.prototype.append = function(e) {
                        this.insertBefore(e, void 0);
                    }, E.prototype.insertBefore = function(e, target) {
                        e.parent && e.remove(), this.children || (this.children = []), e.parent = this;
                        var index = -1;
                        void 0 !== target && (index = this.children.indexOf(target)) > -1 ? this.children.splice(index, 0, e) : this.children.push(e), 
                        (e._touchable || e._hasTouchableChildren) && (this._hasTouchableChildren = !0, this._enableTouchPropagation()), 
                        this.modified(!0);
                    }, E.prototype.remove = function(e) {
                        if (void 0 === e) return void this.parent.remove(this);
                        var index = this.children ? this.children.indexOf(e) : -1;
                        if (0 > index) throw g.ExceptionFactory.createAssertionError("E#remove: invalid child");
                        this.children[index].parent = void 0, this.children.splice(index, 1), (e._touchable || e._hasTouchableChildren) && (this._findTouchableChildren(this) || (this._hasTouchableChildren = !1, 
                        this._disableTouchPropagation())), this.modified(!0);
                    }, E.prototype.destroy = function() {
                        if (this.parent && this.remove(), this.children) {
                            for (;this.children.length; ) this.children[this.children.length - 1].destroy();
                            this.children = void 0;
                        }
                        this._update && (this._update.destroy(), this._update = void 0), this._message && (this._message.destroy(), 
                        this._message = void 0), this._pointDown && (this._pointDown.destroy(), this._pointDown = void 0), 
                        this._pointMove && (this._pointMove.destroy(), this._pointMove = void 0), this._pointUp && (this._pointUp.destroy(), 
                        this._pointUp = void 0), this.scene.unregister(this);
                    }, E.prototype.destroyed = function() {
                        return void 0 === this.scene;
                    }, E.prototype.modified = function(isBubbling) {
                        this._matrix && (this._matrix._modified = !0), this.angle || 1 !== this.scaleX || 1 !== this.scaleY || 1 !== this.opacity || void 0 !== this.compositeOperation ? this.state &= -9 : this.state |= 8, 
                        4 & this.state || (this.state |= 4, this.parent && this.parent.modified(!0));
                    }, E.prototype.shouldFindChildrenByPoint = function(point) {
                        return !0;
                    }, E.prototype.findPointSourceByPoint = function(point, m, force, camera) {
                        if (!(1 & this.state)) {
                            var cams = this._targetCameras;
                            if (!(cams && cams.length > 0) || camera && -1 !== cams.indexOf(camera)) {
                                m = m ? m.multiplyNew(this.getMatrix()) : this.getMatrix().clone();
                                var p = m.multiplyInverseForPoint(point);
                                if ((this._hasTouchableChildren || force && this.children && this.children.length) && this.shouldFindChildrenByPoint(p)) for (var i = this.children.length - 1; i >= 0; --i) {
                                    var child = this.children[i];
                                    if (force || child._touchable || child._hasTouchableChildren) {
                                        var target = child.findPointSourceByPoint(point, m, force, camera);
                                        if (target) return target;
                                    }
                                }
                                if (force || this._touchable) return 0 <= p.x && this.width > p.x && 0 <= p.y && this.height > p.y ? {
                                    target: this,
                                    point: p
                                } : void 0;
                            }
                        }
                    }, E.prototype.visible = function() {
                        return 1 !== (1 & this.state);
                    }, E.prototype.show = function() {
                        1 & this.state && (this.state &= -2, this.parent && this.parent.modified(!0));
                    }, E.prototype.hide = function() {
                        1 & this.state || (this.state |= 1, this.parent && this.parent.modified(!0));
                    }, E.prototype.calculateBoundingRect = function(c) {
                        return this._calculateBoundingRect(void 0, c);
                    }, E.prototype._calculateBoundingRect = function(m, c) {
                        var matrix = this.getMatrix();
                        if (m && (matrix = m.multiplyNew(matrix)), this.visible() && (!c || this._targetCameras && -1 !== this._targetCameras.indexOf(c))) {
                            for (var thisBoundingRect = {
                                left: 0,
                                right: this.width,
                                top: 0,
                                bottom: this.height
                            }, targetCoordinates = [ {
                                x: thisBoundingRect.left,
                                y: thisBoundingRect.top
                            }, {
                                x: thisBoundingRect.left,
                                y: thisBoundingRect.bottom
                            }, {
                                x: thisBoundingRect.right,
                                y: thisBoundingRect.top
                            }, {
                                x: thisBoundingRect.right,
                                y: thisBoundingRect.bottom
                            } ], convertedPoint = matrix.multiplyPoint(targetCoordinates[0]), result = {
                                left: convertedPoint.x,
                                right: convertedPoint.x,
                                top: convertedPoint.y,
                                bottom: convertedPoint.y
                            }, i = 1; i < targetCoordinates.length; ++i) convertedPoint = matrix.multiplyPoint(targetCoordinates[i]), 
                            result.left > convertedPoint.x && (result.left = convertedPoint.x), result.right < convertedPoint.x && (result.right = convertedPoint.x), 
                            result.top > convertedPoint.y && (result.top = convertedPoint.y), result.bottom < convertedPoint.y && (result.bottom = convertedPoint.y);
                            if (void 0 !== this.children) for (var i = 0; i < this.children.length; ++i) {
                                var nowResult = this.children[i]._calculateBoundingRect(matrix, c);
                                nowResult && (result.left > nowResult.left && (result.left = nowResult.left), result.right < nowResult.right && (result.right = nowResult.right), 
                                result.top > nowResult.top && (result.top = nowResult.top), result.bottom < nowResult.bottom && (result.bottom = nowResult.bottom));
                            }
                            return result;
                        }
                    }, E.prototype._enableTouchPropagation = function() {
                        for (var p = this.parent; p instanceof E && !p._hasTouchableChildren; ) p._hasTouchableChildren = !0, 
                        p = p.parent;
                    }, E.prototype._disableTouchPropagation = function() {
                        for (var p = this.parent; p instanceof E && p._hasTouchableChildren && !this._findTouchableChildren(p); ) p._hasTouchableChildren = !1, 
                        p = p.parent;
                    }, E.prototype._isTargetOperation = function(e) {
                        return 1 & this.state ? !1 : e instanceof g.PointEvent ? this._touchable && e.target === this : !1;
                    }, E.prototype._findTouchableChildren = function(e) {
                        if (e.children) for (var i = 0; i < e.children.length; ++i) {
                            if (e.children[i].touchable) return e.children[i];
                            var tmp = this._findTouchableChildren(e.children[i]);
                            if (tmp) return tmp;
                        }
                    }, E;
                }(g.Object2D);
                g.E = E;
            }(g || (g = {}));
            var g;
            !function(g) {
                var CacheableE = function(_super) {
                    function CacheableE(param) {
                        var _this = _super.call(this, param) || this;
                        return _this._shouldRenderChildren = !0, _this._cache = void 0, _this._renderer = void 0, 
                        _this._renderedCamera = void 0, _this;
                    }
                    return __extends(CacheableE, _super), CacheableE.prototype.invalidate = function() {
                        this.state &= -3, this.modified();
                    }, CacheableE.prototype.renderSelf = function(renderer, camera) {
                        if (this._renderedCamera !== camera && (this.state &= -3, this._renderedCamera = camera), 
                        !(2 & this.state)) {
                            var isNew = !this._cache || this._cache.width < Math.ceil(this.width) || this._cache.height < Math.ceil(this.height);
                            isNew && (this._cache && !this._cache.destroyed() && this._cache.destroy(), this._cache = this.scene.game.resourceFactory.createSurface(Math.ceil(this.width), Math.ceil(this.height)), 
                            this._renderer = this._cache.renderer()), this._renderer.begin(), isNew || this._renderer.clear(), 
                            this.renderCache(this._renderer, camera), this.state |= 2, this._renderer.end();
                        }
                        return this._cache && this.width > 0 && this.height > 0 && renderer.drawImage(this._cache, 0, 0, this.width, this.height, 0, 0), 
                        this._shouldRenderChildren;
                    }, CacheableE.prototype.destroy = function() {
                        this._cache && !this._cache.destroyed() && this._cache.destroy(), this._cache = void 0, 
                        _super.prototype.destroy.call(this);
                    }, CacheableE;
                }(g.E);
                g.CacheableE = CacheableE;
            }(g || (g = {}));
            var g;
            !function(g) {
                var StorageRegion;
                !function(StorageRegion) {
                    StorageRegion[StorageRegion.Slots = 1] = "Slots", StorageRegion[StorageRegion.Scores = 2] = "Scores", 
                    StorageRegion[StorageRegion.Counts = 3] = "Counts", StorageRegion[StorageRegion.Values = 4] = "Values";
                }(StorageRegion = g.StorageRegion || (g.StorageRegion = {}));
                var StorageOrder;
                !function(StorageOrder) {
                    StorageOrder[StorageOrder.Asc = 0] = "Asc", StorageOrder[StorageOrder.Desc = 1] = "Desc";
                }(StorageOrder = g.StorageOrder || (g.StorageOrder = {}));
                var StorageCondition;
                !function(StorageCondition) {
                    StorageCondition[StorageCondition.Equal = 1] = "Equal", StorageCondition[StorageCondition.GreaterThan = 2] = "GreaterThan", 
                    StorageCondition[StorageCondition.LessThan = 3] = "LessThan";
                }(StorageCondition = g.StorageCondition || (g.StorageCondition = {}));
                var StorageCountsOperation;
                !function(StorageCountsOperation) {
                    StorageCountsOperation[StorageCountsOperation.Incr = 1] = "Incr", StorageCountsOperation[StorageCountsOperation.Decr = 2] = "Decr";
                }(StorageCountsOperation = g.StorageCountsOperation || (g.StorageCountsOperation = {}));
                var StorageValueStore = function() {
                    function StorageValueStore(keys, values) {
                        this._keys = keys, this._values = values;
                    }
                    return StorageValueStore.prototype.get = function(keyOrIndex) {
                        if (void 0 === this._values) return [];
                        if ("number" == typeof keyOrIndex) return this._values[keyOrIndex];
                        var index = this._keys.indexOf(keyOrIndex);
                        if (-1 !== index) return this._values[index];
                        for (var i = 0; i < this._keys.length; ++i) {
                            var target = this._keys[i];
                            if (target.region === keyOrIndex.region && target.regionKey === keyOrIndex.regionKey && target.userId === keyOrIndex.userId && target.gameId === keyOrIndex.gameId) return this._values[i];
                        }
                        return [];
                    }, StorageValueStore.prototype.getOne = function(keyOrIndex) {
                        var values = this.get(keyOrIndex);
                        if (values) return values[0];
                    }, StorageValueStore;
                }();
                g.StorageValueStore = StorageValueStore;
                var StorageLoader = function() {
                    function StorageLoader(storage, keys, serialization) {
                        this._loaded = !1, this._storage = storage, this._valueStore = new StorageValueStore(keys), 
                        this._handler = void 0, this._valueStoreSerialization = serialization;
                    }
                    return StorageLoader.prototype._load = function(handler) {
                        this._handler = handler, this._storage._load && this._storage._load.call(this._storage, this._valueStore._keys, this, this._valueStoreSerialization);
                    }, StorageLoader.prototype._onLoaded = function(values, serialization) {
                        this._valueStore._values = values, this._loaded = !0, serialization && (this._valueStoreSerialization = serialization), 
                        this._handler && this._handler._onStorageLoaded();
                    }, StorageLoader.prototype._onError = function(error) {
                        this._handler && this._handler._onStorageLoadError(error);
                    }, StorageLoader;
                }();
                g.StorageLoader = StorageLoader;
                var Storage = function() {
                    function Storage(game) {
                        this._game = game;
                    }
                    return Storage.prototype.write = function(key, value, option) {
                        this._write && this._write(key, value, option);
                    }, Storage.prototype.requestValuesForJoinPlayer = function(keys) {
                        this._requestedKeysForJoinPlayer = keys;
                    }, Storage.prototype._createLoader = function(keys, serialization) {
                        return new StorageLoader(this, keys, serialization);
                    }, Storage.prototype._registerWrite = function(write) {
                        this._write = write;
                    }, Storage.prototype._registerLoad = function(load) {
                        this._load = load;
                    }, Storage;
                }();
                g.Storage = Storage;
            }(g || (g = {}));
            var g;
            !function(g) {
                var SceneAssetHolder = function() {
                    function SceneAssetHolder(param) {
                        this.waitingAssetsCount = param.assetIds.length, this._scene = param.scene, this._assetManager = param.assetManager, 
                        this._assetIds = param.assetIds, this._assets = [], this._handler = param.handler, 
                        this._handlerOwner = param.handlerOwner || null, this._direct = !!param.direct, 
                        this._requested = !1;
                    }
                    return SceneAssetHolder.prototype.request = function() {
                        return 0 === this.waitingAssetsCount ? !1 : this._requested ? !0 : (this._requested = !0, 
                        this._assetManager.requestAssets(this._assetIds, this), !0);
                    }, SceneAssetHolder.prototype.destroy = function() {
                        this._requested && this._assetManager.unrefAssets(this._assets), this.waitingAssetsCount = 0, 
                        this._scene = void 0, this._assetIds = void 0, this._handler = void 0, this._requested = !1;
                    }, SceneAssetHolder.prototype.destroyed = function() {
                        return !this._scene;
                    }, SceneAssetHolder.prototype.callHandler = function() {
                        this._handler.call(this._handlerOwner);
                    }, SceneAssetHolder.prototype._onAssetError = function(asset, error, assetManager) {
                        if (!this.destroyed() && !this._scene.destroyed()) {
                            var failureInfo = {
                                asset: asset,
                                error: error,
                                cancelRetry: !1
                            };
                            this._scene.assetLoadFailed.fire(failureInfo), error.retriable && !failureInfo.cancelRetry ? this._assetManager.retryLoad(asset) : this._assetManager.configuration[asset.id] && this._scene.game.terminateGame(), 
                            this._scene.assetLoadCompleted.fire(asset);
                        }
                    }, SceneAssetHolder.prototype._onAssetLoad = function(asset) {
                        if (!this.destroyed() && !this._scene.destroyed()) {
                            if (this._scene.assets[asset.id] = asset, this._scene.assetLoaded.fire(asset), this._scene.assetLoadCompleted.fire(asset), 
                            this._assets.push(asset), --this.waitingAssetsCount, this.waitingAssetsCount < 0) throw g.ExceptionFactory.createAssertionError("SceneAssetHolder#_onAssetLoad: broken waitingAssetsCount");
                            this.waitingAssetsCount > 0 || (this._direct ? this.callHandler() : this._scene.game._callSceneAssetHolderHandler(this));
                        }
                    }, SceneAssetHolder;
                }();
                g.SceneAssetHolder = SceneAssetHolder;
                var SceneState;
                !function(SceneState) {
                    SceneState[SceneState.Destroyed = 0] = "Destroyed", SceneState[SceneState.Standby = 1] = "Standby", 
                    SceneState[SceneState.Active = 2] = "Active", SceneState[SceneState.Deactive = 3] = "Deactive", 
                    SceneState[SceneState.BeforeDestroyed = 4] = "BeforeDestroyed";
                }(SceneState = g.SceneState || (g.SceneState = {}));
                var SceneLoadState;
                !function(SceneLoadState) {
                    SceneLoadState[SceneLoadState.Initial = 0] = "Initial", SceneLoadState[SceneLoadState.Ready = 1] = "Ready", 
                    SceneLoadState[SceneLoadState.ReadyFired = 2] = "ReadyFired", SceneLoadState[SceneLoadState.LoadedFired = 3] = "LoadedFired";
                }(SceneLoadState = g.SceneLoadState || (g.SceneLoadState = {}));
                var Scene = function() {
                    function Scene(param) {
                        var game, local, tickGenerationMode, assetIds;
                        game = param.game, assetIds = param.assetIds, param.storageKeys ? (this._storageLoader = game.storage._createLoader(param.storageKeys, param.storageValuesSerialization), 
                        this.storageValues = this._storageLoader._valueStore) : (this._storageLoader = void 0, 
                        this.storageValues = void 0), local = void 0 === param.local ? g.LocalTickMode.NonLocal : param.local === !1 ? g.LocalTickMode.NonLocal : param.local === !0 ? g.LocalTickMode.FullLocal : param.local, 
                        tickGenerationMode = void 0 !== param.tickGenerationMode ? param.tickGenerationMode : g.TickGenerationMode.ByClock, 
                        this.name = param.name, assetIds || (assetIds = []), this.game = game, this.local = local, 
                        this.tickGenerationMode = tickGenerationMode, this.loaded = new g.Trigger(), this._ready = new g.Trigger(), 
                        this.assets = {}, this._loaded = !1, this._prefetchRequested = !1, this._loadingState = SceneLoadState.Initial, 
                        this.update = new g.Trigger(), this._timer = new g.TimerManager(this.update, this.game.fps), 
                        this.assetLoaded = new g.Trigger(), this.assetLoadFailed = new g.Trigger(), this.assetLoadCompleted = new g.Trigger(), 
                        this.message = new g.Trigger(), this.pointDownCapture = new g.Trigger(), this.pointMoveCapture = new g.Trigger(), 
                        this.pointUpCapture = new g.Trigger(), this.operation = new g.Trigger(), this.children = [], 
                        this.state = SceneState.Standby, this.stateChanged = new g.Trigger(), this._assetHolders = [], 
                        this._sceneAssetHolder = new SceneAssetHolder({
                            scene: this,
                            assetManager: this.game._assetManager,
                            assetIds: assetIds,
                            handler: this._onSceneAssetsLoad,
                            handlerOwner: this,
                            direct: !0
                        });
                    }
                    return Scene.prototype.modified = function(isBubbling) {
                        this.game.modified = !0;
                    }, Scene.prototype.destroy = function() {
                        this.state = SceneState.BeforeDestroyed, this.stateChanged.fire(this.state);
                        var gameDb = this.game.db;
                        for (var p in gameDb) gameDb.hasOwnProperty(p) && gameDb[p].scene === this && gameDb[p].destroy();
                        var gameDb = this.game._localDb;
                        for (var p in gameDb) gameDb.hasOwnProperty(p) && gameDb[p].scene === this && gameDb[p].destroy();
                        this._timer.destroy(), this.update.destroy(), this.message.destroy(), this.pointDownCapture.destroy(), 
                        this.pointMoveCapture.destroy(), this.pointUpCapture.destroy(), this.operation.destroy(), 
                        this.loaded.destroy(), this.assetLoaded.destroy(), this.assetLoadFailed.destroy(), 
                        this.assetLoadCompleted.destroy(), this.assets = {};
                        for (var i = 0; i < this._assetHolders.length; ++i) this._assetHolders[i].destroy();
                        this._sceneAssetHolder.destroy(), this._storageLoader = void 0, this.game = void 0, 
                        this.state = SceneState.Destroyed, this.stateChanged.fire(this.state), this.stateChanged.destroy();
                    }, Scene.prototype.destroyed = function() {
                        return void 0 === this.game;
                    }, Scene.prototype.createTimer = function(interval) {
                        return this._timer.createTimer(interval);
                    }, Scene.prototype.deleteTimer = function(timer) {
                        this._timer.deleteTimer(timer);
                    }, Scene.prototype.setInterval = function(handler, interval, owner) {
                        var t = this._timer;
                        return "number" == typeof handler ? (this.game.logger.warn("[deprecated] Scene#setInterval(): this arguments ordering is now deprecated. Specify the function first."), 
                        null != owner ? t.setInterval(owner, handler, interval) : t.setInterval(interval, handler, null)) : t.setInterval(handler, interval, owner);
                    }, Scene.prototype.clearInterval = function(identifier) {
                        this._timer.clearInterval(identifier);
                    }, Scene.prototype.setTimeout = function(handler, milliseconds, owner) {
                        var t = this._timer;
                        return "number" == typeof handler ? (this.game.logger.warn("[deprecated] Scene#setTimeout(): this arguments ordering is now deprecated. Specify the function first."), 
                        null != owner ? t.setTimeout(owner, handler, milliseconds) : t.setTimeout(milliseconds, handler, null)) : t.setTimeout(handler, milliseconds, owner);
                    }, Scene.prototype.clearTimeout = function(identifier) {
                        this._timer.clearTimeout(identifier);
                    }, Scene.prototype.isCurrentScene = function() {
                        return this.game.scene() === this;
                    }, Scene.prototype.gotoScene = function(next, toPush) {
                        if (!this.isCurrentScene()) throw g.ExceptionFactory.createAssertionError("Scene#gotoScene: this scene is not the current scene");
                        toPush ? this.game.pushScene(next) : this.game.replaceScene(next);
                    }, Scene.prototype.end = function() {
                        if (!this.isCurrentScene()) throw g.ExceptionFactory.createAssertionError("Scene#end: this scene is not the current scene");
                        this.game.popScene();
                    }, Scene.prototype.register = function(e) {
                        this.game.register(e), e.scene = this;
                    }, Scene.prototype.unregister = function(e) {
                        e.scene = void 0, this.game.unregister(e);
                    }, Scene.prototype.append = function(e) {
                        this.insertBefore(e, void 0);
                    }, Scene.prototype.insertBefore = function(e, target) {
                        e.parent && e.remove(), e.parent = this;
                        var index = -1;
                        void 0 !== target && (index = this.children.indexOf(target)) > -1 ? this.children.splice(index, 0, e) : this.children.push(e), 
                        this.modified(!0);
                    }, Scene.prototype.remove = function(e) {
                        var index = this.children.indexOf(e);
                        -1 !== index && (this.children[index].parent = void 0, this.children.splice(index, 1), 
                        this.modified(!0));
                    }, Scene.prototype.findPointSourceByPoint = function(point, force, camera) {
                        var mayConsumeLocalTick = this.local !== g.LocalTickMode.NonLocal, children = this.children, m = void 0;
                        camera && camera instanceof g.Camera2D && (m = camera.getMatrix());
                        for (var i = children.length - 1; i >= 0; --i) {
                            var ret = children[i].findPointSourceByPoint(point, m, force, camera);
                            if (ret) return ret.local = ret.target.local || mayConsumeLocalTick, ret;
                        }
                        return {
                            target: void 0,
                            point: void 0,
                            local: mayConsumeLocalTick
                        };
                    }, Scene.prototype.prefetch = function() {
                        this._loaded || this._prefetchRequested || (this._prefetchRequested = !0, this._sceneAssetHolder.request());
                    }, Scene.prototype.serializeStorageValues = function() {
                        return this._storageLoader ? this._storageLoader._valueStoreSerialization : void 0;
                    }, Scene.prototype.requestAssets = function(assetIds, handler) {
                        if (this._loadingState < SceneLoadState.ReadyFired) throw g.ExceptionFactory.createAssertionError("Scene#requestAsset(): can be called after loaded.");
                        var holder = new SceneAssetHolder({
                            scene: this,
                            assetManager: this.game._assetManager,
                            assetIds: assetIds,
                            handler: handler
                        });
                        this._assetHolders.push(holder), holder.request();
                    }, Scene.prototype._activate = function() {
                        this.state = SceneState.Active, this.stateChanged.fire(this.state);
                    }, Scene.prototype._deactivate = function() {
                        this.state = SceneState.Deactive, this.stateChanged.fire(this.state);
                    }, Scene.prototype._needsLoading = function() {
                        return this._sceneAssetHolder.waitingAssetsCount > 0 || this._storageLoader && !this._storageLoader._loaded;
                    }, Scene.prototype._load = function() {
                        if (!this._loaded) {
                            this._loaded = !0;
                            var needsWait = this._sceneAssetHolder.request();
                            this._storageLoader && (this._storageLoader._load(this), needsWait = !0), needsWait || this._notifySceneReady();
                        }
                    }, Scene.prototype._onSceneAssetsLoad = function() {
                        this._loaded && (!this._storageLoader || this._storageLoader._loaded) && this._notifySceneReady();
                    }, Scene.prototype._onStorageLoadError = function(error) {
                        this.game.terminateGame();
                    }, Scene.prototype._onStorageLoaded = function() {
                        0 === this._sceneAssetHolder.waitingAssetsCount && this._notifySceneReady();
                    }, Scene.prototype._notifySceneReady = function() {
                        this._loadingState = SceneLoadState.Ready, this.game._fireSceneReady(this);
                    }, Scene.prototype._fireReady = function() {
                        this._ready.fire(this), this._loadingState = SceneLoadState.ReadyFired;
                    }, Scene.prototype._fireLoaded = function() {
                        this.loaded.fire(this), this._loadingState = SceneLoadState.LoadedFired;
                    }, Scene;
                }();
                g.Scene = Scene;
            }(g || (g = {}));
            var g;
            !function(g) {
                var LoadingScene = function(_super) {
                    function LoadingScene(param) {
                        var _this = this;
                        return param.local = !0, _this = _super.call(this, param) || this, _this.targetReset = new g.Trigger(), 
                        _this.targetReady = new g.Trigger(), _this.targetAssetLoaded = new g.Trigger(), 
                        _this._explicitEnd = !!param.explicitEnd, _this._targetScene = void 0, _this;
                    }
                    return __extends(LoadingScene, _super), LoadingScene.prototype.destroy = function() {
                        this._clearTargetScene(), _super.prototype.destroy.call(this);
                    }, LoadingScene.prototype.reset = function(targetScene) {
                        this._clearTargetScene(), this._targetScene = targetScene, this._loadingState < g.SceneLoadState.LoadedFired ? this.loaded.addOnce(this._doReset, this) : this._doReset();
                    }, LoadingScene.prototype.getTargetWaitingAssetsCount = function() {
                        return this._targetScene ? this._targetScene._sceneAssetHolder.waitingAssetsCount : 0;
                    }, LoadingScene.prototype.end = function() {
                        if (!this._targetScene || this._targetScene._loadingState < g.SceneLoadState.Ready) {
                            var state = this._targetScene ? g.SceneLoadState[this._targetScene._loadingState] : "(no scene)", msg = "LoadingScene#end(): the target scene is in invalid state: " + state;
                            throw g.ExceptionFactory.createAssertionError(msg);
                        }
                        this.game.popScene(!0), this.game._fireSceneLoaded(this._targetScene), this._clearTargetScene();
                    }, LoadingScene.prototype._clearTargetScene = function() {
                        this._targetScene && (this._targetScene._ready.removeAll({
                            owner: this
                        }), this._targetScene.assetLoaded.removeAll({
                            owner: this
                        }), this._targetScene = void 0);
                    }, LoadingScene.prototype._doReset = function() {
                        this.targetReset.fire(this._targetScene), this._targetScene._loadingState < g.SceneLoadState.ReadyFired ? (this._targetScene._ready.add(this._fireTriggerOnTargetReady, this), 
                        this._targetScene.assetLoaded.add(this._fireTriggerOnTargetAssetLoad, this), this._targetScene._load()) : this._fireTriggerOnTargetReady(this._targetScene);
                    }, LoadingScene.prototype._fireTriggerOnTargetAssetLoad = function(asset) {
                        this.targetAssetLoaded.fire(asset);
                    }, LoadingScene.prototype._fireTriggerOnTargetReady = function(scene) {
                        this.targetReady.fire(scene), this._explicitEnd || this.end();
                    }, LoadingScene;
                }(g.Scene);
                g.LoadingScene = LoadingScene;
            }(g || (g = {}));
            var g;
            !function(g) {
                var CameraCancellingE = function(_super) {
                    function CameraCancellingE(param) {
                        var _this = _super.call(this, param) || this;
                        return _this._canceller = new g.Object2D(), _this;
                    }
                    return __extends(CameraCancellingE, _super), CameraCancellingE.prototype.renderSelf = function(renderer, camera) {
                        if (!this.children) return !1;
                        if (camera) {
                            var c = camera, canceller = this._canceller;
                            (c.x !== canceller.x || c.y !== canceller.y || c.angle !== canceller.angle || c.scaleX !== canceller.scaleX || c.scaleY !== canceller.scaleY) && (canceller.x = c.x, 
                            canceller.y = c.y, canceller.angle = c.angle, canceller.scaleX = c.scaleX, canceller.scaleY = c.scaleY, 
                            canceller._matrix && (canceller._matrix._modified = !0)), renderer.save(), renderer.transform(canceller.getMatrix()._matrix);
                        }
                        for (var children = this.children, i = 0; i < children.length; ++i) children[i].render(renderer, camera);
                        return camera && renderer.restore(), !1;
                    }, CameraCancellingE;
                }(g.E), DefaultLoadingScene = function(_super) {
                    function DefaultLoadingScene(param) {
                        var _this = _super.call(this, {
                            game: param.game,
                            name: "akashic:default-loading-scene"
                        }) || this;
                        return _this._barWidth = Math.min(param.game.width, Math.max(100, param.game.width / 2)), 
                        _this._barHeight = 5, _this._gauge = void 0, _this._gaugeUpdateCount = 0, _this._totalWaitingAssetCount = 0, 
                        _this.loaded.handle(_this, _this._onLoaded), _this.targetReset.handle(_this, _this._onTargetReset), 
                        _this.targetAssetLoaded.handle(_this, _this._onTargetAssetLoaded), _this;
                    }
                    return __extends(DefaultLoadingScene, _super), DefaultLoadingScene.prototype._onLoaded = function() {
                        var gauge;
                        return this.append(new CameraCancellingE({
                            scene: this,
                            children: [ new g.FilledRect({
                                scene: this,
                                width: this.game.width,
                                height: this.game.height,
                                cssColor: "rgba(0, 0, 0, 0.8)",
                                children: [ new g.FilledRect({
                                    scene: this,
                                    x: (this.game.width - this._barWidth) / 2,
                                    y: (this.game.height - this._barHeight) / 2,
                                    width: this._barWidth,
                                    height: this._barHeight,
                                    cssColor: "gray",
                                    children: [ gauge = new g.FilledRect({
                                        scene: this,
                                        width: 0,
                                        height: this._barHeight,
                                        cssColor: "white"
                                    }) ]
                                }) ]
                            }) ]
                        })), gauge.update.handle(this, this._onUpdateGuage), this._gauge = gauge, !0;
                    }, DefaultLoadingScene.prototype._onUpdateGuage = function() {
                        var BLINK_RANGE = 50, BLINK_PER_SEC = 2 / 3;
                        ++this._gaugeUpdateCount;
                        var c = Math.round(255 - BLINK_RANGE + Math.sin(this._gaugeUpdateCount / this.game.fps * BLINK_PER_SEC * (2 * Math.PI)) * BLINK_RANGE);
                        this._gauge.cssColor = "rgb(" + c + "," + c + "," + c + ")", this._gauge.modified();
                    }, DefaultLoadingScene.prototype._onTargetReset = function(targetScene) {
                        this._gauge && (this._gauge.width = 0, this._gauge.modified()), this._totalWaitingAssetCount = targetScene._sceneAssetHolder.waitingAssetsCount;
                    }, DefaultLoadingScene.prototype._onTargetAssetLoaded = function(asset) {
                        var waitingAssetsCount = this._targetScene._sceneAssetHolder.waitingAssetsCount;
                        this._gauge.width = Math.ceil((1 - waitingAssetsCount / this._totalWaitingAssetCount) * this._barWidth), 
                        this._gauge.modified();
                    }, DefaultLoadingScene;
                }(g.LoadingScene);
                g.DefaultLoadingScene = DefaultLoadingScene;
            }(g || (g = {}));
            var g;
            !function(g) {
                var Sprite = function(_super) {
                    function Sprite(param) {
                        var _this = _super.call(this, param) || this;
                        return _this.surface = g.Util.asSurface(param.src), "width" in param || (_this.width = _this.surface.width), 
                        "height" in param || (_this.height = _this.surface.height), _this.srcWidth = "srcWidth" in param ? param.srcWidth : _this.width, 
                        _this.srcHeight = "srcHeight" in param ? param.srcHeight : _this.height, _this.srcX = param.srcX || 0, 
                        _this.srcY = param.srcY || 0, _this._stretchMatrix = void 0, _this._beforeSurface = _this.surface, 
                        g.Util.setupAnimatingHandler(_this, _this.surface), _this._invalidateSelf(), _this;
                    }
                    return __extends(Sprite, _super), Sprite.prototype._onUpdate = function() {
                        this.modified();
                    }, Sprite.prototype._onAnimatingStarted = function() {
                        this.update.contains(this._onUpdate, this) || this.update.add(this._onUpdate, this);
                    }, Sprite.prototype._onAnimatingStopped = function() {
                        this.destroyed() || this.update.remove(this._onUpdate, this);
                    }, Sprite.prototype.renderSelf = function(renderer, camera) {
                        return this.srcWidth <= 0 || this.srcHeight <= 0 ? !0 : (this._stretchMatrix && (renderer.save(), 
                        renderer.transform(this._stretchMatrix._matrix)), renderer.drawImage(this.surface, this.srcX, this.srcY, this.srcWidth, this.srcHeight, 0, 0), 
                        this._stretchMatrix && renderer.restore(), !0);
                    }, Sprite.prototype.invalidate = function() {
                        this._invalidateSelf(), this.modified();
                    }, Sprite.prototype.destroy = function(destroySurface) {
                        this.surface && !this.surface.destroyed() && (destroySurface ? this.surface.destroy() : this.surface.isDynamic && (this.surface.animatingStarted.remove(this._onAnimatingStarted, this), 
                        this.surface.animatingStopped.remove(this._onAnimatingStopped, this))), this.surface = void 0, 
                        _super.prototype.destroy.call(this);
                    }, Sprite.prototype._invalidateSelf = function() {
                        this.width === this.srcWidth && this.height === this.srcHeight ? this._stretchMatrix = void 0 : (this._stretchMatrix = g.Util.createMatrix(), 
                        this._stretchMatrix.scale(this.width / this.srcWidth, this.height / this.srcHeight)), 
                        this.surface !== this._beforeSurface && (g.Util.migrateAnimatingHandler(this, this._beforeSurface, this.surface), 
                        this._beforeSurface = this.surface);
                    }, Sprite;
                }(g.E);
                g.Sprite = Sprite;
            }(g || (g = {}));
            var g;
            !function(g) {
                var FrameSprite = function(_super) {
                    function FrameSprite(param) {
                        var _this = _super.call(this, param) || this;
                        return _this._lastUsedIndex = 0, _this.frameNumber = param.frameNumber || 0, _this.frames = "frames" in param ? param.frames : [ 0 ], 
                        _this.interval = param.interval, _this._timer = void 0, _this._modifiedSelf(), _this;
                    }
                    return __extends(FrameSprite, _super), FrameSprite.createBySprite = function(sprite, width, height) {
                        var frameSprite = new FrameSprite({
                            scene: sprite.scene,
                            src: sprite.surface,
                            width: void 0 === width ? sprite.width : width,
                            height: void 0 === height ? sprite.height : height
                        });
                        return frameSprite.srcHeight = void 0 === height ? sprite.srcHeight : height, frameSprite.srcWidth = void 0 === width ? sprite.srcWidth : width, 
                        frameSprite;
                    }, FrameSprite.prototype.start = function() {
                        void 0 === this.interval && (this.interval = 1e3 / this.game().fps), this._timer && this._free(), 
                        this._timer = this.scene.createTimer(this.interval), this._timer.elapsed.add(this._onElapsed, this);
                    }, FrameSprite.prototype.destroy = function(destroySurface) {
                        this.stop(), _super.prototype.destroy.call(this, destroySurface);
                    }, FrameSprite.prototype.stop = function() {
                        this._timer && this._free();
                    }, FrameSprite.prototype.modified = function(isBubbling) {
                        this._modifiedSelf(isBubbling), _super.prototype.modified.call(this, isBubbling);
                    }, FrameSprite.prototype._onElapsed = function() {
                        ++this.frameNumber >= this.frames.length && (this.frameNumber = 0), this.modified();
                    }, FrameSprite.prototype._free = function() {
                        this._timer && (this._timer.elapsed.remove(this._onElapsed, this), this._timer.canDelete() && this.scene.deleteTimer(this._timer), 
                        this._timer = void 0);
                    }, FrameSprite.prototype._changeFrame = function() {
                        var frame = this.frames[this.frameNumber], sep = Math.floor(this.surface.width / this.srcWidth);
                        this.srcX = frame % sep * this.srcWidth, this.srcY = Math.floor(frame / sep) * this.srcHeight, 
                        this._lastUsedIndex = frame;
                    }, FrameSprite.prototype._modifiedSelf = function(isBubbling) {
                        this._lastUsedIndex !== this.frames[this.frameNumber] && this._changeFrame();
                    }, FrameSprite;
                }(g.Sprite);
                g.FrameSprite = FrameSprite;
            }(g || (g = {}));
            var g;
            !function(g) {
                var EventType;
                !function(EventType) {
                    EventType[EventType.Unknown = 0] = "Unknown", EventType[EventType.Join = 1] = "Join", 
                    EventType[EventType.Leave = 2] = "Leave", EventType[EventType.Timestamp = 3] = "Timestamp", 
                    EventType[EventType.Seed = 4] = "Seed", EventType[EventType.PointDown = 5] = "PointDown", 
                    EventType[EventType.PointMove = 6] = "PointMove", EventType[EventType.PointUp = 7] = "PointUp", 
                    EventType[EventType.Message = 8] = "Message", EventType[EventType.Operation = 9] = "Operation";
                }(EventType = g.EventType || (g.EventType = {}));
                var PointEvent = function() {
                    function PointEvent(pointerId, target, point, player, local, priority) {
                        this.priority = priority, this.local = local, this.player = player, this.pointerId = pointerId, 
                        this.target = target, this.point = point;
                    }
                    return PointEvent;
                }();
                g.PointEvent = PointEvent;
                var PointDownEvent = function(_super) {
                    function PointDownEvent(pointerId, target, point, player, local, priority) {
                        var _this = _super.call(this, pointerId, target, point, player, local, priority) || this;
                        return _this.type = EventType.PointDown, _this;
                    }
                    return __extends(PointDownEvent, _super), PointDownEvent;
                }(PointEvent);
                g.PointDownEvent = PointDownEvent;
                var PointUpEvent = function(_super) {
                    function PointUpEvent(pointerId, target, point, prevDelta, startDelta, player, local, priority) {
                        var _this = _super.call(this, pointerId, target, point, player, local, priority) || this;
                        return _this.type = EventType.PointUp, _this.prevDelta = prevDelta, _this.startDelta = startDelta, 
                        _this;
                    }
                    return __extends(PointUpEvent, _super), PointUpEvent;
                }(PointEvent);
                g.PointUpEvent = PointUpEvent;
                var PointMoveEvent = function(_super) {
                    function PointMoveEvent(pointerId, target, point, prevDelta, startDelta, player, local, priority) {
                        var _this = _super.call(this, pointerId, target, point, player, local, priority) || this;
                        return _this.type = EventType.PointMove, _this.prevDelta = prevDelta, _this.startDelta = startDelta, 
                        _this;
                    }
                    return __extends(PointMoveEvent, _super), PointMoveEvent;
                }(PointEvent);
                g.PointMoveEvent = PointMoveEvent;
                var MessageEvent = function() {
                    function MessageEvent(data, player, local, priority) {
                        this.type = EventType.Message, this.priority = priority, this.local = local, this.player = player, 
                        this.data = data;
                    }
                    return MessageEvent;
                }();
                g.MessageEvent = MessageEvent;
                var OperationEvent = function() {
                    function OperationEvent(code, data, player, local, priority) {
                        this.type = EventType.Operation, this.priority = priority, this.local = local, this.player = player, 
                        this.code = code, this.data = data;
                    }
                    return OperationEvent;
                }();
                g.OperationEvent = OperationEvent;
                var JoinEvent = function() {
                    function JoinEvent(player, storageValues, priority) {
                        this.type = EventType.Join, this.priority = priority, this.player = player, this.storageValues = storageValues;
                    }
                    return JoinEvent;
                }();
                g.JoinEvent = JoinEvent;
                var LeaveEvent = function() {
                    function LeaveEvent(player, priority) {
                        this.type = EventType.Leave, this.priority = priority, this.player = player;
                    }
                    return LeaveEvent;
                }();
                g.LeaveEvent = LeaveEvent;
                var TimestampEvent = function() {
                    function TimestampEvent(timestamp, player, priority) {
                        this.type = EventType.Timestamp, this.priority = priority, this.player = player, 
                        this.timestamp = timestamp;
                    }
                    return TimestampEvent;
                }();
                g.TimestampEvent = TimestampEvent;
                var SeedEvent = function() {
                    function SeedEvent(generator, priority) {
                        this.type = EventType.Seed, this.priority = priority, this.generator = generator;
                    }
                    return SeedEvent;
                }();
                g.SeedEvent = SeedEvent;
            }(g || (g = {}));
            var g;
            !function(g) {
                var LogLevel;
                !function(LogLevel) {
                    LogLevel[LogLevel.Error = 0] = "Error", LogLevel[LogLevel.Warn = 1] = "Warn", LogLevel[LogLevel.Info = 2] = "Info", 
                    LogLevel[LogLevel.Debug = 3] = "Debug";
                }(LogLevel = g.LogLevel || (g.LogLevel = {}));
                var Logger = function() {
                    function Logger(game) {
                        this.game = game, this.logging = new g.Trigger();
                    }
                    return Logger.prototype.error = function(message, cause) {
                        this.logging.fire({
                            game: this.game,
                            level: LogLevel.Error,
                            message: message,
                            cause: cause
                        });
                    }, Logger.prototype.warn = function(message, cause) {
                        this.logging.fire({
                            game: this.game,
                            level: LogLevel.Warn,
                            message: message,
                            cause: cause
                        });
                    }, Logger.prototype.info = function(message, cause) {
                        this.logging.fire({
                            game: this.game,
                            level: LogLevel.Info,
                            message: message,
                            cause: cause
                        });
                    }, Logger.prototype.debug = function(message, cause) {
                        this.logging.fire({
                            game: this.game,
                            level: LogLevel.Debug,
                            message: message,
                            cause: cause
                        });
                    }, Logger;
                }();
                g.Logger = Logger;
            }(g || (g = {}));
            var g;
            !function(g) {
                var Game = function() {
                    function Game(gameConfiguration, resourceFactory, assetBase, selfId, operationPluginViewInfo) {
                        gameConfiguration = this._normalizeConfiguration(gameConfiguration), this.fps = gameConfiguration.fps, 
                        this.width = gameConfiguration.width, this.height = gameConfiguration.height, this.renderers = [], 
                        this.scenes = [], this.random = null, this.age = 0, this.assetBase = assetBase || "", 
                        this.resourceFactory = resourceFactory, this.selfId = selfId || void 0, this.playId = void 0, 
                        this._audioSystemManager = new g.AudioSystemManager(this), this.audio = {
                            music: new g.MusicAudioSystem("music", this),
                            sound: new g.SoundAudioSystem("sound", this)
                        }, this.defaultAudioSystemId = "sound", this.storage = new g.Storage(this), this.assets = {}, 
                        this.join = new g.Trigger(), this.leave = new g.Trigger(), this.seed = new g.Trigger(), 
                        this._eventTriggerMap = {}, this._eventTriggerMap[g.EventType.Join] = this.join, 
                        this._eventTriggerMap[g.EventType.Leave] = this.leave, this._eventTriggerMap[g.EventType.Seed] = this.seed, 
                        this._eventTriggerMap[g.EventType.Message] = void 0, this._eventTriggerMap[g.EventType.PointDown] = void 0, 
                        this._eventTriggerMap[g.EventType.PointMove] = void 0, this._eventTriggerMap[g.EventType.PointUp] = void 0, 
                        this._eventTriggerMap[g.EventType.Operation] = void 0, this.resized = new g.Trigger(), 
                        this._loaded = new g.Trigger(), this._started = new g.Trigger(), this.isLoaded = !1, 
                        this.snapshotRequest = new g.Trigger(), this.external = {}, this.logger = new g.Logger(this), 
                        this._main = gameConfiguration.main, this._mainParameter = void 0, this._configuration = gameConfiguration, 
                        this._assetManager = new g.AssetManager(this, gameConfiguration.assets, gameConfiguration.audio, gameConfiguration.moduleMainScripts);
                        var operationPluginsField = gameConfiguration.operationPlugins || [];
                        this._operationPluginManager = new g.OperationPluginManager(this, operationPluginViewInfo, operationPluginsField), 
                        this._operationPluginOperated = new g.Trigger(), this._operationPluginManager.operated.add(this._operationPluginOperated.fire, this._operationPluginOperated), 
                        this._sceneChanged = new g.Trigger(), this._sceneChanged.add(this._updateEventTriggers, this), 
                        this._initialScene = new g.Scene({
                            game: this,
                            assetIds: this._assetManager.globalAssetIds(),
                            local: !0,
                            name: "akashic:initial-scene"
                        }), this._initialScene.loaded.add(this._onInitialSceneLoaded, this), this._reset({
                            age: 0
                        });
                    }
                    return Object.defineProperty(Game.prototype, "focusingCamera", {
                        get: function() {
                            return this._focusingCamera;
                        },
                        set: function(c) {
                            c !== this._focusingCamera && (this.modified && this.render(this._focusingCamera), 
                            this._focusingCamera = c);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Game.prototype.pushScene = function(scene) {
                        this._sceneChangeRequests.push({
                            type: 0,
                            scene: scene
                        });
                    }, Game.prototype.replaceScene = function(scene, preserveCurrent) {
                        this._sceneChangeRequests.push({
                            type: 1,
                            scene: scene,
                            preserveCurrent: preserveCurrent
                        });
                    }, Game.prototype.popScene = function(preserveCurrent) {
                        this._sceneChangeRequests.push({
                            type: 2,
                            preserveCurrent: preserveCurrent
                        });
                    }, Game.prototype.scene = function() {
                        return this.scenes.length ? this.scenes[this.scenes.length - 1] : void 0;
                    }, Game.prototype.tick = function(advanceAge) {
                        var scene = void 0;
                        if (this._isTerminated) return !1;
                        if (this.scenes.length) {
                            if (scene = this.scenes[this.scenes.length - 1], this.events.length) {
                                var events = this.events;
                                this.events = [];
                                for (var i = 0; i < events.length; ++i) {
                                    var trigger = this._eventTriggerMap[events[i].type];
                                    trigger && trigger.fire(events[i]);
                                }
                            }
                            scene.update.fire(), (advanceAge === !0 || void 0 === advanceAge && scene.local !== g.LocalTickMode.FullLocal) && ++this.age;
                        }
                        return this._sceneChangeRequests.length ? (this._flushSceneChangeRequests(), scene !== this.scenes[this.scenes.length - 1]) : !1;
                    }, Game.prototype.render = function(camera) {
                        camera || (camera = this.focusingCamera);
                        for (var renderers = this.renderers, i = 0; i < renderers.length; ++i) renderers[i].draw(this, camera);
                        this.modified = !1;
                    }, Game.prototype.findPointSource = function(point, camera) {
                        return camera || (camera = this.focusingCamera), this.scene().findPointSourceByPoint(point, !1, camera);
                    }, Game.prototype.register = function(e) {
                        if (e.local) {
                            if (void 0 === e.id) e.id = --this._localIdx; else {
                                if (e.id > 0) throw g.ExceptionFactory.createAssertionError("Game#register: invalid local id: " + e.id);
                                if (this._localDb.hasOwnProperty(String(e.id))) throw g.ExceptionFactory.createAssertionError("Game#register: conflicted id: " + e.id);
                                this._localIdx > e.id && (this._localIdx = e.id);
                            }
                            this._localDb[e.id] = e;
                        } else {
                            if (void 0 === e.id) e.id = ++this._idx; else {
                                if (e.id < 0) throw g.ExceptionFactory.createAssertionError("Game#register: invalid non-local id: " + e.id);
                                if (this.db.hasOwnProperty(String(e.id))) throw g.ExceptionFactory.createAssertionError("Game#register: conflicted id: " + e.id);
                                this._idx < e.id && (this._idx = e.id);
                            }
                            this.db[e.id] = e;
                        }
                    }, Game.prototype.unregister = function(e) {
                        e.local ? delete this._localDb[e.id] : delete this.db[e.id];
                    }, Game.prototype.leaveGame = function() {
                        this._leaveGame();
                    }, Game.prototype.terminateGame = function() {
                        this._leaveGame(), this._isTerminated = !0, this._terminateGame();
                    }, Game.prototype._fireSceneReady = function(scene) {
                        this._sceneChangeRequests.push({
                            type: 3,
                            scene: scene
                        });
                    }, Game.prototype._fireSceneLoaded = function(scene) {
                        scene._loadingState < g.SceneLoadState.LoadedFired && this._sceneChangeRequests.push({
                            type: 4,
                            scene: scene
                        });
                    }, Game.prototype._callSceneAssetHolderHandler = function(assetHolder) {
                        this._sceneChangeRequests.push({
                            type: 5,
                            assetHolder: assetHolder
                        });
                    }, Game.prototype._normalizeConfiguration = function(gameConfiguration) {
                        if (!gameConfiguration) throw g.ExceptionFactory.createAssertionError("Game#_normalizeConfiguration: invalid arguments");
                        if ("assets" in gameConfiguration || (gameConfiguration.assets = {}), "fps" in gameConfiguration || (gameConfiguration.fps = 30), 
                        "number" != typeof gameConfiguration.fps) throw g.ExceptionFactory.createAssertionError("Game#_normalizeConfiguration: fps must be given as a number");
                        if (!(0 <= gameConfiguration.fps && gameConfiguration.fps <= 60)) throw g.ExceptionFactory.createAssertionError("Game#_normalizeConfiguration: fps must be a number in (0, 60].");
                        if ("number" != typeof gameConfiguration.width) throw g.ExceptionFactory.createAssertionError("Game#_normalizeConfiguration: width must be given as a number");
                        if ("number" != typeof gameConfiguration.height) throw g.ExceptionFactory.createAssertionError("Game#_normalizeConfiguration: height must be given as a number");
                        return gameConfiguration;
                    }, Game.prototype._setAudioPlaybackRate = function(playbackRate) {
                        this._audioSystemManager._setPlaybackRate(playbackRate);
                    }, Game.prototype._setMuted = function(muted) {
                        this._audioSystemManager._setMuted(muted);
                    }, Game.prototype._decodeOperationPluginOperation = function(code, op) {
                        var plugins = this._operationPluginManager.plugins;
                        return plugins[code] && plugins[code].decode ? plugins[code].decode(op) : op;
                    }, Game.prototype._reset = function(param) {
                        if (this._operationPluginManager.stopAll(), this.scene()) {
                            for (;this.scene() !== this._initialScene; ) this.popScene(), this._flushSceneChangeRequests();
                            this.isLoaded || this.scenes.pop();
                        }
                        switch (param && (void 0 !== param.age && (this.age = param.age), void 0 !== param.randGen && (this.random = param.randGen)), 
                        this._loaded.removeAll({
                            func: this._start,
                            owner: this
                        }), this.join.removeAll(), this.leave.removeAll(), this.seed.removeAll(), this.resized.removeAll(), 
                        this._idx = 0, this._localIdx = 0, this._cameraIdx = 0, this.db = {}, this._localDb = {}, 
                        this.events = [], this.modified = !0, this.loadingScene = void 0, this._focusingCamera = void 0, 
                        this._scriptCaches = {}, this.snapshotRequest.removeAll(), this._sceneChangeRequests = [], 
                        this._isTerminated = !1, this.vars = {}, this._configuration.defaultLoadingScene) {
                          case "none":
                            this._defaultLoadingScene = new g.LoadingScene({
                                game: this
                            });
                            break;

                          default:
                            this._defaultLoadingScene = new g.DefaultLoadingScene({
                                game: this
                            });
                        }
                    }, Game.prototype._loadAndStart = function(param) {
                        this._mainParameter = param || {}, this.isLoaded ? this._start() : (this._loaded.add(this._start, this), 
                        this.pushScene(this._initialScene), this._flushSceneChangeRequests());
                    }, Game.prototype._startLoadingGlobalAssets = function() {
                        if (this.isLoaded) throw g.ExceptionFactory.createAssertionError("Game#_startLoadingGlobalAssets: already loaded.");
                        this.pushScene(this._initialScene), this._flushSceneChangeRequests();
                    }, Game.prototype._updateEventTriggers = function(scene) {
                        return this.modified = !0, scene ? (this._eventTriggerMap[g.EventType.Message] = scene.message, 
                        this._eventTriggerMap[g.EventType.PointDown] = scene.pointDownCapture, this._eventTriggerMap[g.EventType.PointMove] = scene.pointMoveCapture, 
                        this._eventTriggerMap[g.EventType.PointUp] = scene.pointUpCapture, this._eventTriggerMap[g.EventType.Operation] = scene.operation, 
                        void scene._activate()) : (this._eventTriggerMap[g.EventType.Message] = void 0, 
                        this._eventTriggerMap[g.EventType.PointDown] = void 0, this._eventTriggerMap[g.EventType.PointMove] = void 0, 
                        this._eventTriggerMap[g.EventType.PointUp] = void 0, void (this._eventTriggerMap[g.EventType.Operation] = void 0));
                    }, Game.prototype._onInitialSceneLoaded = function() {
                        this._initialScene.loaded.remove(this._onInitialSceneLoaded, this), this.assets = this._initialScene.assets, 
                        this.isLoaded = !0, this._loaded.fire();
                    }, Game.prototype._terminateGame = function() {}, Game.prototype._flushSceneChangeRequests = function() {
                        do {
                            var reqs = this._sceneChangeRequests;
                            this._sceneChangeRequests = [];
                            for (var i = 0; i < reqs.length; ++i) {
                                var req = reqs[i];
                                switch (req.type) {
                                  case 0:
                                    var oldScene = this.scene();
                                    oldScene && oldScene._deactivate(), this._doPushScene(req.scene);
                                    break;

                                  case 1:
                                    this._doPopScene(req.preserveCurrent, !1), this._doPushScene(req.scene);
                                    break;

                                  case 2:
                                    this._doPopScene(req.preserveCurrent, !0);
                                    break;

                                  case 3:
                                    req.scene.destroyed() || req.scene._fireReady();
                                    break;

                                  case 4:
                                    req.scene.destroyed() || req.scene._fireLoaded();
                                    break;

                                  case 5:
                                    req.assetHolder.callHandler();
                                    break;

                                  default:
                                    throw g.ExceptionFactory.createAssertionError("Game#_flushSceneChangeRequests: unknown scene change request.");
                                }
                            }
                        } while (this._sceneChangeRequests.length > 0);
                    }, Game.prototype._doPopScene = function(preserveCurrent, fireSceneChanged) {
                        var scene = this.scenes.pop();
                        if (scene === this._initialScene) throw g.ExceptionFactory.createAssertionError("Game#_doPopScene: invalid call; attempting to pop the initial scene");
                        preserveCurrent || scene.destroy(), fireSceneChanged && this._sceneChanged.fire(this.scene());
                    }, Game.prototype._start = function() {
                        if (this._operationPluginManager.initialize(), this.operationPlugins = this._operationPluginManager.plugins, 
                        !this._main) {
                            if (this._mainParameter.snapshot) {
                                if (!this.assets.snapshotLoader) throw g.ExceptionFactory.createAssertionError("Game#_start: global asset 'snapshotLoader' not found.");
                                var loader = g._require(this, "snapshotLoader");
                                loader(this._mainParameter.snapshot), this._flushSceneChangeRequests();
                            } else {
                                if (!this.assets.mainScene) throw g.ExceptionFactory.createAssertionError("Game#_start: global asset 'mainScene' not found.");
                                var mainScene = g._require(this, "mainScene")();
                                this.pushScene(mainScene), this._flushSceneChangeRequests();
                            }
                            return void this._started.fire();
                        }
                        var mainFun = g._require(this, this._main);
                        if (!mainFun || "function" != typeof mainFun) throw g.ExceptionFactory.createAssertionError("Game#_start: Entry point '" + this._main + "' not found.");
                        mainFun(this._mainParameter), this._flushSceneChangeRequests(), this._started.fire();
                    }, Game.prototype._doPushScene = function(scene, loadingScene) {
                        if (loadingScene || (loadingScene = this.loadingScene || this._defaultLoadingScene), 
                        this.scenes.push(scene), scene._needsLoading() && scene._loadingState < g.SceneLoadState.LoadedFired) {
                            if (this._defaultLoadingScene._needsLoading()) throw g.ExceptionFactory.createAssertionError("Game#_doPushScene: _defaultLoadingScene must not depend on any assets/storages.");
                            this._doPushScene(loadingScene, this._defaultLoadingScene), loadingScene.reset(scene);
                        } else this._sceneChanged.fire(scene), scene._loaded || (scene._load(), this._fireSceneLoaded(scene));
                        this.modified = !0;
                    }, Game;
                }();
                g.Game = Game;
            }(g || (g = {}));
            var g;
            !function(g) {
                var Camera2D = function(_super) {
                    function Camera2D(param) {
                        var _this = _super.call(this, param) || this;
                        return _this.game = param.game, _this.local = !!param.local, _this.name = param.name, 
                        _this._modifiedCount = 0, _this.width = param.game.width, _this.height = param.game.height, 
                        _this.id = _this.local ? void 0 : _this.game._cameraIdx++, _this;
                    }
                    return __extends(Camera2D, _super), Camera2D.deserialize = function(ser, game) {
                        var s = ser;
                        s.param.game = game;
                        var ret = new Camera2D(s.param);
                        return ret.id = s.id, ret;
                    }, Camera2D.prototype.modified = function() {
                        this._modifiedCount = (this._modifiedCount + 1) % 32768, this._matrix && (this._matrix._modified = !0), 
                        this.game.modified = !0;
                    }, Camera2D.prototype.serialize = function() {
                        var ser = {
                            id: this.id,
                            param: {
                                game: void 0,
                                local: this.local,
                                name: this.name,
                                x: this.x,
                                y: this.y,
                                width: this.width,
                                height: this.height,
                                opacity: this.opacity,
                                scaleX: this.scaleX,
                                scaleY: this.scaleY,
                                angle: this.angle,
                                compositeOperation: this.compositeOperation
                            }
                        };
                        return ser;
                    }, Camera2D.prototype._applyTransformToRenderer = function(renderer) {
                        this.angle || 1 !== this.scaleX || 1 !== this.scaleY ? renderer.transform(this.getMatrix()._matrix) : renderer.translate(-this.x, -this.y), 
                        1 !== this.opacity && renderer.opacity(this.opacity);
                    }, Camera2D.prototype._updateMatrix = function() {
                        this.angle || 1 !== this.scaleX || 1 !== this.scaleY ? this._matrix.updateByInverse(this.width, this.height, this.scaleX, this.scaleY, this.angle, this.x, this.y) : this._matrix.reset(-this.x, -this.y);
                    }, Camera2D;
                }(g.Object2D);
                g.Camera2D = Camera2D;
            }(g || (g = {}));
            var g;
            !function(g) {
                var Renderer = function() {
                    function Renderer() {}
                    return Renderer.prototype.draw = function(game, camera) {
                        var scene = game.scene();
                        if (scene) {
                            this.begin(), this.clear(), camera && (this.save(), camera._applyTransformToRenderer(this));
                            for (var children = scene.children, i = 0; i < children.length; ++i) children[i].render(this, camera);
                            camera && this.restore(), this.end();
                        }
                    }, Renderer.prototype.begin = function() {}, Renderer.prototype.end = function() {}, 
                    Renderer;
                }();
                g.Renderer = Renderer;
            }(g || (g = {}));
            var g;
            !function(g) {
                var Surface = function() {
                    function Surface(width, height, drawable, isDynamic) {
                        if (void 0 === isDynamic && (isDynamic = !1), width % 1 !== 0 || height % 1 !== 0) throw g.ExceptionFactory.createAssertionError("Surface#constructor: width and height must be integers");
                        this.width = width, this.height = height, drawable && (this._drawable = drawable), 
                        this.isDynamic = isDynamic, this.isDynamic ? (this.animatingStarted = new g.Trigger(), 
                        this.animatingStopped = new g.Trigger()) : (this.animatingStarted = void 0, this.animatingStopped = void 0);
                    }
                    return Surface.prototype.destroy = function() {
                        this.animatingStarted && this.animatingStarted.destroy(), this.animatingStopped && this.animatingStopped.destroy(), 
                        this._destroyed = !0;
                    }, Surface.prototype.destroyed = function() {
                        return !!this._destroyed;
                    }, Surface;
                }();
                g.Surface = Surface;
            }(g || (g = {}));
            var g;
            !function(g) {
                var Label = function(_super) {
                    function Label(param) {
                        var _this = _super.call(this, param) || this;
                        return _this.text = param.text, _this.font = param.font, _this.textAlign = "textAlign" in param ? param.textAlign : g.TextAlign.Left, 
                        _this.glyphs = new Array(param.text.length), _this.fontSize = param.fontSize, _this.maxWidth = param.maxWidth, 
                        _this.widthAutoAdjust = "widthAutoAdjust" in param ? param.widthAutoAdjust : !0, 
                        _this.textColor = param.textColor, _this._textWidth = 0, _this._game = void 0, _this._invalidateSelf(), 
                        _this;
                    }
                    return __extends(Label, _super), Label.prototype.aligning = function(width, textAlign) {
                        this.width = width, this.widthAutoAdjust = !1, this.textAlign = textAlign;
                    }, Label.prototype.invalidate = function() {
                        this._invalidateSelf(), _super.prototype.invalidate.call(this);
                    }, Label.prototype.renderCache = function(renderer) {
                        if (!(!this.fontSize || this.height <= 0 || this._textWidth <= 0)) {
                            var textSurface = this.scene.game.resourceFactory.createSurface(Math.ceil(this._textWidth), Math.ceil(this.height)), textRenderer = textSurface.renderer();
                            textRenderer.begin(), textRenderer.save();
                            for (var i = 0; i < this.glyphs.length; ++i) {
                                var glyph = this.glyphs[i], glyphScale = this.fontSize / this.font.size, glyphWidth = glyph.advanceWidth * glyphScale;
                                glyph.surface && (textRenderer.save(), textRenderer.transform([ glyphScale, 0, 0, glyphScale, 0, 0 ]), 
                                textRenderer.drawImage(glyph.surface, glyph.x, glyph.y, glyph.width, glyph.height, glyph.offsetX, glyph.offsetY), 
                                textRenderer.restore()), textRenderer.translate(glyphWidth, 0);
                            }
                            textRenderer.restore(), textRenderer.end();
                            var offsetX, scale = this.maxWidth > 0 && this.maxWidth < this._textWidth ? this.maxWidth / this._textWidth : 1;
                            switch (this.textAlign) {
                              case g.TextAlign.Center:
                                offsetX = this.width / 2 - this._textWidth / 2 * scale;
                                break;

                              case g.TextAlign.Right:
                                offsetX = this.width - this._textWidth * scale;
                                break;

                              default:
                                offsetX = 0;
                            }
                            renderer.save(), renderer.translate(offsetX, 0), 1 !== scale && renderer.transform([ scale, 0, 0, 1, 0, 0 ]), 
                            renderer.drawImage(textSurface, 0, 0, this._textWidth, this.height, 0, 0), textSurface.destroy(), 
                            this.textColor && (renderer.setCompositeOperation(g.CompositeOperation.SourceAtop), 
                            renderer.fillRect(0, 0, this._textWidth, this.height, this.textColor)), renderer.restore();
                        }
                    }, Label.prototype.destroy = function() {
                        _super.prototype.destroy.call(this);
                    }, Label.prototype._invalidateSelf = function() {
                        if (this.glyphs.length = 0, this._textWidth = 0, !this.fontSize) return void (this.height = 0);
                        for (var maxHeight = 0, glyphScale = this.font.size > 0 ? this.fontSize / this.font.size : 0, i = 0; i < this.text.length; ++i) {
                            var code = g.Util.charCodeAt(this.text, i);
                            if (code) {
                                var glyph = this.font.glyphForCharacter(code);
                                if (glyph) {
                                    if (!(glyph.width < 0 || glyph.height < 0 || glyph.x < 0 || glyph.y < 0)) {
                                        this.glyphs.push(glyph), this._textWidth += glyph.advanceWidth * glyphScale;
                                        var height = glyph.offsetY + glyph.height;
                                        height > maxHeight && (maxHeight = height);
                                    }
                                } else {
                                    var str = 4294901760 & code ? String.fromCharCode((4294901760 & code) >>> 16, 65535 & code) : String.fromCharCode(code);
                                    this.game().logger.warn("Label#_invalidateSelf(): failed to get a glyph for '" + str + "' (BitmapFont might not have the glyph or DynamicFont might create a glyph larger than its atlas).");
                                }
                            }
                        }
                        this.widthAutoAdjust && (this.width = this._textWidth), this.height = maxHeight * glyphScale;
                    }, Label;
                }(g.CacheableE);
                g.Label = Label;
            }(g || (g = {}));
            var g;
            !function(g) {
                var Glyph = function() {
                    function Glyph(code, x, y, width, height, offsetX, offsetY, advanceWidth, surface, isSurfaceValid) {
                        void 0 === offsetX && (offsetX = 0), void 0 === offsetY && (offsetY = 0), void 0 === advanceWidth && (advanceWidth = width), 
                        void 0 === isSurfaceValid && (isSurfaceValid = !!surface), this.code = code, this.x = x, 
                        this.y = y, this.width = width, this.height = height, this.offsetX = offsetX, this.offsetY = offsetY, 
                        this.advanceWidth = advanceWidth, this.surface = surface, this.isSurfaceValid = isSurfaceValid, 
                        this._atlas = null;
                    }
                    return Glyph.prototype.renderingWidth = function(fontSize) {
                        return this.width && this.height ? fontSize / this.height * this.width : 0;
                    }, Glyph;
                }();
                g.Glyph = Glyph;
            }(g || (g = {}));
            var g;
            !function(g) {
                var FilledRect = function(_super) {
                    function FilledRect(param) {
                        var _this = _super.call(this, param) || this;
                        if ("string" != typeof param.cssColor) throw g.ExceptionFactory.createTypeMismatchError("ColorBox#constructor(cssColor)", "string", param.cssColor);
                        return _this.cssColor = param.cssColor, _this;
                    }
                    return __extends(FilledRect, _super), FilledRect.prototype.renderSelf = function(renderer) {
                        return renderer.fillRect(0, 0, this.width, this.height, this.cssColor), !0;
                    }, FilledRect;
                }(g.E);
                g.FilledRect = FilledRect;
            }(g || (g = {}));
            var g;
            !function(g) {
                var Pane = function(_super) {
                    function Pane(param) {
                        var _this = _super.call(this, param) || this;
                        return _this._oldWidth = param.width, _this._oldHeight = param.height, _this.backgroundImage = g.Util.asSurface(param.backgroundImage), 
                        _this.backgroundEffector = param.backgroundEffector, _this._shouldRenderChildren = !1, 
                        _this._padding = param.padding, _this._initialize(), _this._paddingChanged = !1, 
                        _this._bgSurface = void 0, _this._bgRenderer = void 0, _this;
                    }
                    return __extends(Pane, _super), Object.defineProperty(Pane.prototype, "padding", {
                        get: function() {
                            return this._padding;
                        },
                        set: function(padding) {
                            this._padding = padding, this._paddingChanged = !0;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Pane.prototype.modified = function(isBubbling) {
                        isBubbling && (this.state &= -3), _super.prototype.modified.call(this);
                    }, Pane.prototype.shouldFindChildrenByPoint = function(point) {
                        var p = this._normalizedPadding;
                        return p.left < point.x && this.width - p.right > point.x && p.top < point.y && this.height - p.bottom > point.y ? !0 : !1;
                    }, Pane.prototype.renderCache = function(renderer, camera) {
                        this.width <= 0 || this.height <= 0 || (this._renderBackground(), this._renderChildren(camera), 
                        this._bgSurface ? renderer.drawImage(this._bgSurface, 0, 0, this.width, this.height, 0, 0) : this.backgroundImage && renderer.drawImage(this.backgroundImage, 0, 0, this.width, this.height, 0, 0), 
                        this._childrenArea.width <= 0 || this._childrenArea.height <= 0 || (renderer.save(), 
                        (0 !== this._childrenArea.x || 0 !== this._childrenArea.y) && renderer.translate(this._childrenArea.x, this._childrenArea.y), 
                        renderer.drawImage(this._childrenSurface, 0, 0, this._childrenArea.width, this._childrenArea.height, 0, 0), 
                        renderer.restore()));
                    }, Pane.prototype.destroy = function(destroySurface) {
                        destroySurface && this.backgroundImage && !this.backgroundImage.destroyed() && this.backgroundImage.destroy(), 
                        this._bgSurface && !this._bgSurface.destroyed() && this._bgSurface.destroy(), this._childrenSurface && !this._childrenSurface.destroyed() && this._childrenSurface.destroy(), 
                        this.backgroundImage = void 0, this._bgSurface = void 0, this._childrenSurface = void 0, 
                        _super.prototype.destroy.call(this);
                    }, Pane.prototype._renderBackground = function() {
                        this._bgSurface && !this._bgSurface.destroyed() && this._bgSurface.destroy(), this.backgroundImage && this.backgroundEffector ? this._bgSurface = this.backgroundEffector.render(this.backgroundImage, this.width, this.height) : this._bgSurface = void 0;
                    }, Pane.prototype._renderChildren = function(camera) {
                        var isNew = this._oldWidth !== this.width || this._oldHeight !== this.height || this._paddingChanged;
                        if (isNew && (this._initialize(), this._paddingChanged = !1, this._oldWidth = this.width, 
                        this._oldHeight = this.height), this._childrenRenderer.begin(), isNew || this._childrenRenderer.clear(), 
                        this.children) for (var children = this.children, i = 0; i < children.length; ++i) children[i].render(this._childrenRenderer, camera);
                        this._childrenRenderer.end();
                    }, Pane.prototype._initialize = function() {
                        var r, p = void 0 === this._padding ? 0 : this._padding;
                        r = "number" == typeof p ? {
                            top: p,
                            bottom: p,
                            left: p,
                            right: p
                        } : this._padding, this._childrenArea = {
                            x: r.left,
                            y: r.top,
                            width: this.width - r.left - r.right,
                            height: this.height - r.top - r.bottom
                        };
                        var resourceFactory = this.scene.game.resourceFactory;
                        this._childrenSurface && !this._childrenSurface.destroyed() && this._childrenSurface.destroy(), 
                        this._childrenSurface = resourceFactory.createSurface(Math.ceil(this._childrenArea.width), Math.ceil(this._childrenArea.height)), 
                        this._childrenRenderer = this._childrenSurface.renderer(), this._normalizedPadding = r;
                    }, Pane.prototype._calculateBoundingRect = function(m, c) {
                        var matrix = this.getMatrix();
                        if (m && (matrix = m.multiplyNew(matrix)), this.visible() && (!c || this._targetCameras && -1 !== this._targetCameras.indexOf(c))) {
                            for (var thisBoundingRect = {
                                left: 0,
                                right: this.width,
                                top: 0,
                                bottom: this.height
                            }, targetCoordinates = [ {
                                x: thisBoundingRect.left,
                                y: thisBoundingRect.top
                            }, {
                                x: thisBoundingRect.left,
                                y: thisBoundingRect.bottom
                            }, {
                                x: thisBoundingRect.right,
                                y: thisBoundingRect.top
                            }, {
                                x: thisBoundingRect.right,
                                y: thisBoundingRect.bottom
                            } ], convertedPoint = matrix.multiplyPoint(targetCoordinates[0]), result = {
                                left: convertedPoint.x,
                                right: convertedPoint.x,
                                top: convertedPoint.y,
                                bottom: convertedPoint.y
                            }, i = 1; i < targetCoordinates.length; ++i) convertedPoint = matrix.multiplyPoint(targetCoordinates[i]), 
                            result.left > convertedPoint.x && (result.left = convertedPoint.x), result.right < convertedPoint.x && (result.right = convertedPoint.x), 
                            result.top > convertedPoint.y && (result.top = convertedPoint.y), result.bottom < convertedPoint.y && (result.bottom = convertedPoint.y);
                            return result;
                        }
                    }, Pane;
                }(g.CacheableE);
                g.Pane = Pane;
            }(g || (g = {}));
            var g;
            !function(g) {
                var OperationHandler = function() {
                    function OperationHandler(code, owner, handler) {
                        this._code = code, this._handler = handler, this._handlerOwner = owner;
                    }
                    return OperationHandler.prototype.onOperation = function(op) {
                        var iop;
                        op instanceof Array ? iop = {
                            _code: this._code,
                            data: op
                        } : (iop = op, iop._code = this._code), this._handler.call(this._handlerOwner, iop);
                    }, OperationHandler;
                }(), OperationPluginManager = function() {
                    function OperationPluginManager(game, viewInfo, infos) {
                        this.operated = new g.Trigger(), this.plugins = {}, this._game = game, this._viewInfo = viewInfo, 
                        this._infos = infos, this._initialized = !1;
                    }
                    return OperationPluginManager.prototype.initialize = function() {
                        this._initialized || (this._initialized = !0, this._loadOperationPlugins()), this._doAutoStart();
                    }, OperationPluginManager.prototype.destroy = function() {
                        this.stopAll(), this.operated.destroy(), this.operated = void 0, this.plugins = void 0, 
                        this._game = void 0, this._viewInfo = void 0, this._infos = void 0;
                    }, OperationPluginManager.prototype.stopAll = function() {
                        if (this._initialized) for (var i = 0; i < this._infos.length; ++i) {
                            var info = this._infos[i];
                            info._plugin && info._plugin.stop();
                        }
                    }, OperationPluginManager.prototype._doAutoStart = function() {
                        for (var i = 0; i < this._infos.length; ++i) {
                            var info = this._infos[i];
                            !info.manualStart && info._plugin && info._plugin.start();
                        }
                    }, OperationPluginManager.prototype._loadOperationPlugins = function() {
                        for (var i = 0; i < this._infos.length; ++i) {
                            var info = this._infos[i];
                            if (info.script) {
                                var pluginClass = g._require(this._game, info.script);
                                if (pluginClass.isSupported()) {
                                    var plugin = new pluginClass(this._game, this._viewInfo, info.option), code = info.code;
                                    if (this.plugins[code]) throw new Error("Plugin#code conflicted for code: " + code);
                                    this.plugins[code] = plugin, info._plugin = plugin;
                                    var handler = new OperationHandler(code, this.operated, this.operated.fire);
                                    plugin.operationTrigger.handle(handler, handler.onOperation);
                                }
                            }
                        }
                    }, OperationPluginManager;
                }();
                g.OperationPluginManager = OperationPluginManager;
            }(g || (g = {}));
            var g;
            !function(g) {}(g || (g = {}));
            var g;
            !function(g) {
                function getSurfaceAtlasSlot(slot, width, height) {
                    for (;slot; ) {
                        if (slot.width >= width && slot.height >= height) return slot;
                        slot = slot.next;
                    }
                    return null;
                }
                function calcAtlasSize(hint) {
                    var width = Math.ceil(Math.min(hint.initialAtlasWidth, hint.maxAtlasWidth)), height = Math.ceil(Math.min(hint.initialAtlasHeight, hint.maxAtlasHeight));
                    return {
                        width: width,
                        height: height
                    };
                }
                var FontWeight;
                !function(FontWeight) {
                    FontWeight[FontWeight.Normal = 0] = "Normal", FontWeight[FontWeight.Bold = 1] = "Bold";
                }(FontWeight = g.FontWeight || (g.FontWeight = {}));
                var SurfaceAtlasSlot = function() {
                    function SurfaceAtlasSlot(x, y, width, height) {
                        this.x = x, this.y = y, this.width = width, this.height = height, this.prev = null, 
                        this.next = null;
                    }
                    return SurfaceAtlasSlot;
                }();
                g.SurfaceAtlasSlot = SurfaceAtlasSlot;
                var SurfaceAtlas = function() {
                    function SurfaceAtlas(surface) {
                        this._surface = surface, this._emptySurfaceAtlasSlotHead = new SurfaceAtlasSlot(0, 0, this._surface.width, this._surface.height), 
                        this._accessScore = 0, this._usedRectangleAreaSize = {
                            width: 0,
                            height: 0
                        };
                    }
                    return SurfaceAtlas.prototype._acquireSurfaceAtlasSlot = function(width, height) {
                        width += 1, height += 1;
                        var slot = getSurfaceAtlasSlot(this._emptySurfaceAtlasSlotHead, width, height);
                        if (!slot) return null;
                        var left, right, remainWidth = slot.width - width, remainHeight = slot.height - height;
                        remainHeight >= remainWidth ? (left = new SurfaceAtlasSlot(slot.x + width, slot.y, remainWidth, height), 
                        right = new SurfaceAtlasSlot(slot.x, slot.y + height, slot.width, remainHeight)) : (left = new SurfaceAtlasSlot(slot.x, slot.y + height, width, remainHeight), 
                        right = new SurfaceAtlasSlot(slot.x + width, slot.y, remainWidth, slot.height)), 
                        left.prev = slot.prev, left.next = right, null === left.prev ? this._emptySurfaceAtlasSlotHead = left : left.prev.next = left, 
                        right.prev = left, right.next = slot.next, right.next && (right.next.prev = right);
                        var acquiredSlot = new SurfaceAtlasSlot(slot.x, slot.y, width, height);
                        return this._updateUsedRectangleAreaSize(acquiredSlot), acquiredSlot;
                    }, SurfaceAtlas.prototype._updateUsedRectangleAreaSize = function(slot) {
                        var slotRight = slot.x + slot.width, slotBottom = slot.y + slot.height;
                        slotRight > this._usedRectangleAreaSize.width && (this._usedRectangleAreaSize.width = slotRight), 
                        slotBottom > this._usedRectangleAreaSize.height && (this._usedRectangleAreaSize.height = slotBottom);
                    }, SurfaceAtlas.prototype.addSurface = function(surface, rect) {
                        var slot = this._acquireSurfaceAtlasSlot(rect.width, rect.height);
                        if (!slot) return null;
                        var renderer = this._surface.renderer();
                        return renderer.begin(), renderer.drawImage(surface, rect.x, rect.y, rect.width, rect.height, slot.x, slot.y), 
                        renderer.end(), slot;
                    }, SurfaceAtlas.prototype.destroy = function() {
                        this._surface.destroy();
                    }, SurfaceAtlas.prototype.destroyed = function() {
                        return this._surface.destroyed();
                    }, SurfaceAtlas.prototype.duplicateSurface = function(resourceFactory) {
                        var src = this._surface, dst = resourceFactory.createSurface(this._usedRectangleAreaSize.width, this._usedRectangleAreaSize.height), renderer = dst.renderer();
                        return renderer.begin(), renderer.drawImage(src, 0, 0, this._usedRectangleAreaSize.width, this._usedRectangleAreaSize.height, 0, 0), 
                        renderer.end(), dst;
                    }, SurfaceAtlas;
                }();
                g.SurfaceAtlas = SurfaceAtlas;
                var DynamicFont = function() {
                    function DynamicFont(param) {
                        if (this.fontFamily = param.fontFamily, this.size = param.size, this.hint = "hint" in param ? param.hint : {}, 
                        this.fontColor = "fontColor" in param ? param.fontColor : "black", this.fontWeight = "fontWeight" in param ? param.fontWeight : FontWeight.Normal, 
                        this.strokeWidth = "strokeWidth" in param ? param.strokeWidth : 0, this.strokeColor = "strokeColor" in param ? param.strokeColor : "black", 
                        this.strokeOnly = "strokeOnly" in param ? param.strokeOnly : !1, this._resourceFactory = param.game.resourceFactory, 
                        this._glyphFactory = this._resourceFactory.createGlyphFactory(this.fontFamily, this.size, this.hint.baselineHeight, this.fontColor, this.strokeWidth, this.strokeColor, this.strokeOnly, this.fontWeight), 
                        this._glyphs = {}, this._atlases = [], this._currentAtlasIndex = 0, this._destroyed = !1, 
                        this.hint.initialAtlasWidth = this.hint.initialAtlasWidth ? this.hint.initialAtlasWidth : 2048, 
                        this.hint.initialAtlasHeight = this.hint.initialAtlasHeight ? this.hint.initialAtlasHeight : 2048, 
                        this.hint.maxAtlasWidth = this.hint.maxAtlasWidth ? this.hint.maxAtlasWidth : 2048, 
                        this.hint.maxAtlasHeight = this.hint.maxAtlasHeight ? this.hint.maxAtlasHeight : 2048, 
                        this.hint.maxAtlasNum = this.hint.maxAtlasNum ? this.hint.maxAtlasNum : 1, this._atlasSize = calcAtlasSize(this.hint), 
                        this._atlases.push(this._resourceFactory.createSurfaceAtlas(this._atlasSize.width, this._atlasSize.height)), 
                        this.hint.presetChars) for (var i = 0, len = this.hint.presetChars.length; len > i; i++) {
                            var code = g.Util.charCodeAt(this.hint.presetChars, i);
                            code && this.glyphForCharacter(code);
                        }
                    }
                    return DynamicFont.prototype.glyphForCharacter = function(code) {
                        var glyph = this._glyphs[code];
                        if (!glyph || !glyph.isSurfaceValid) {
                            if (glyph = this._glyphFactory.create(code), glyph.surface) {
                                if (glyph.width > this._atlasSize.width || glyph.height > this._atlasSize.height) return null;
                                var atlas_1 = this._addToAtlas(glyph);
                                if (!atlas_1 && (this._reallocateAtlas(), atlas_1 = this._addToAtlas(glyph), !atlas_1)) return null;
                                glyph._atlas = atlas_1;
                            }
                            this._glyphs[code] = glyph;
                        }
                        for (var i = 0; i < this._atlases.length; i++) {
                            var atlas = this._atlases[i];
                            atlas === glyph._atlas && (atlas._accessScore += 1), atlas._accessScore /= 2;
                        }
                        return glyph;
                    }, DynamicFont.prototype.asBitmapFont = function(missingGlyphChar) {
                        var _this = this;
                        if (1 !== this._atlases.length) return null;
                        var missingGlyphCharCodePoint;
                        missingGlyphChar && (missingGlyphCharCodePoint = g.Util.charCodeAt(missingGlyphChar, 0), 
                        this.glyphForCharacter(missingGlyphCharCodePoint));
                        var glyphAreaMap = {};
                        Object.keys(this._glyphs).forEach(function(_key) {
                            var key = Number(_key), glyph = _this._glyphs[key], glyphArea = {
                                x: glyph.x,
                                y: glyph.y,
                                width: glyph.width,
                                height: glyph.height,
                                offsetX: glyph.offsetX,
                                offsetY: glyph.offsetY,
                                advanceWidth: glyph.advanceWidth
                            };
                            glyphAreaMap[key] = glyphArea;
                        });
                        var missingGlyph = glyphAreaMap[missingGlyphCharCodePoint], surface = this._atlases[0].duplicateSurface(this._resourceFactory), bitmapFont = new g.BitmapFont({
                            src: surface,
                            map: glyphAreaMap,
                            defaultGlyphWidth: 0,
                            defaultGlyphHeight: this.size,
                            missingGlyph: missingGlyph
                        });
                        return bitmapFont;
                    }, DynamicFont.prototype._removeLowUseAtlas = function() {
                        for (var minScore = Number.MAX_VALUE, lowScoreAtlasIndex = -1, i = 0; i < this._atlases.length; i++) this._atlases[i]._accessScore <= minScore && (minScore = this._atlases[i]._accessScore, 
                        lowScoreAtlasIndex = i);
                        var removedAtlas = this._atlases.splice(lowScoreAtlasIndex, 1)[0];
                        return removedAtlas;
                    }, DynamicFont.prototype._reallocateAtlas = function() {
                        if (this._atlases.length >= this.hint.maxAtlasNum) {
                            var atlas = this._removeLowUseAtlas(), glyphs = this._glyphs;
                            for (var key in glyphs) if (glyphs.hasOwnProperty(key)) {
                                var glyph = glyphs[key];
                                glyph.surface === atlas._surface && (glyph.surface = null, glyph.isSurfaceValid = !1, 
                                glyph._atlas = null);
                            }
                            atlas.destroy();
                        }
                        this._atlases.push(this._resourceFactory.createSurfaceAtlas(this._atlasSize.width, this._atlasSize.height)), 
                        this._currentAtlasIndex = this._atlases.length - 1;
                    }, DynamicFont.prototype._addToAtlas = function(glyph) {
                        for (var atlas = null, slot = null, area = {
                            x: glyph.x,
                            y: glyph.y,
                            width: glyph.width,
                            height: glyph.height
                        }, i = 0; i < this._atlases.length; i++) {
                            var index = (this._currentAtlasIndex + i) % this._atlases.length;
                            if (atlas = this._atlases[index], slot = atlas.addSurface(glyph.surface, area)) {
                                this._currentAtlasIndex = index;
                                break;
                            }
                        }
                        return slot ? (glyph.surface.destroy(), glyph.surface = atlas._surface, glyph.x = slot.x, 
                        glyph.y = slot.y, atlas) : null;
                    }, DynamicFont.prototype.destroy = function() {
                        for (var i = 0; i < this._atlases.length; i++) this._atlases[i].destroy();
                        this._glyphs = null, this._glyphFactory = null, this._destroyed = !0;
                    }, DynamicFont.prototype.destroyed = function() {
                        return this._destroyed;
                    }, DynamicFont;
                }();
                g.DynamicFont = DynamicFont;
            }(g || (g = {}));
            var g;
            !function(g) {
                var AudioSystemManager = function() {
                    function AudioSystemManager(game) {
                        this._game = game, this._muted = !1, this._playbackRate = 1;
                    }
                    return AudioSystemManager.prototype._setMuted = function(muted) {
                        if (this._muted !== muted) {
                            this._muted = muted;
                            var systems = this._game.audio;
                            for (var id in systems) systems.hasOwnProperty(id) && systems[id]._setMuted(muted);
                        }
                    }, AudioSystemManager.prototype._setPlaybackRate = function(rate) {
                        if (this._playbackRate !== rate) {
                            this._playbackRate = rate;
                            var systems = this._game.audio;
                            for (var id in systems) systems.hasOwnProperty(id) && systems[id]._setPlaybackRate(rate);
                        }
                    }, AudioSystemManager;
                }();
                g.AudioSystemManager = AudioSystemManager;
            }(g || (g = {}));
            var g;
            !function(g) {
                var CompositeOperation;
                !function(CompositeOperation) {
                    CompositeOperation[CompositeOperation.SourceOver = 0] = "SourceOver", CompositeOperation[CompositeOperation.SourceAtop = 1] = "SourceAtop", 
                    CompositeOperation[CompositeOperation.Lighter = 2] = "Lighter", CompositeOperation[CompositeOperation.Copy = 3] = "Copy", 
                    CompositeOperation[CompositeOperation.ExperimentalSourceIn = 4] = "ExperimentalSourceIn", 
                    CompositeOperation[CompositeOperation.ExperimentalSourceOut = 5] = "ExperimentalSourceOut", 
                    CompositeOperation[CompositeOperation.ExperimentalDestinationAtop = 6] = "ExperimentalDestinationAtop", 
                    CompositeOperation[CompositeOperation.ExperimentalDestinationIn = 7] = "ExperimentalDestinationIn", 
                    CompositeOperation[CompositeOperation.DestinationOut = 8] = "DestinationOut", CompositeOperation[CompositeOperation.DestinationOver = 9] = "DestinationOver", 
                    CompositeOperation[CompositeOperation.Xor = 10] = "Xor";
                }(CompositeOperation = g.CompositeOperation || (g.CompositeOperation = {}));
            }(g || (g = {}));
            var g;
            !function(g) {
                var GlyphFactory = function() {
                    function GlyphFactory(fontFamily, fontSize, baselineHeight, fontColor, strokeWidth, strokeColor, strokeOnly, fontWeight) {
                        void 0 === baselineHeight && (baselineHeight = fontSize), void 0 === fontColor && (fontColor = "black"), 
                        void 0 === strokeWidth && (strokeWidth = 0), void 0 === strokeColor && (strokeColor = "black"), 
                        void 0 === strokeOnly && (strokeOnly = !1), void 0 === fontWeight && (fontWeight = g.FontWeight.Normal), 
                        this.fontFamily = fontFamily, this.fontSize = fontSize, this.fontWeight = fontWeight, 
                        this.baselineHeight = baselineHeight, this.fontColor = fontColor, this.strokeWidth = strokeWidth, 
                        this.strokeColor = strokeColor, this.strokeOnly = strokeOnly;
                    }
                    return GlyphFactory;
                }();
                g.GlyphFactory = GlyphFactory;
            }(g || (g = {}));
            var g;
            !function(g) {
                var LocalTickMode;
                !function(LocalTickMode) {
                    LocalTickMode[LocalTickMode.NonLocal = 0] = "NonLocal", LocalTickMode[LocalTickMode.FullLocal = 1] = "FullLocal", 
                    LocalTickMode[LocalTickMode.InterpolateLocal = 2] = "InterpolateLocal";
                }(LocalTickMode = g.LocalTickMode || (g.LocalTickMode = {}));
            }(g || (g = {}));
            var g;
            !function(g) {
                var NinePatchSurfaceEffector = function() {
                    function NinePatchSurfaceEffector(game, borderWidth) {
                        void 0 === borderWidth && (borderWidth = 4), this.game = game, "number" == typeof borderWidth ? this.borderWidth = {
                            top: borderWidth,
                            bottom: borderWidth,
                            left: borderWidth,
                            right: borderWidth
                        } : this.borderWidth = borderWidth;
                    }
                    return NinePatchSurfaceEffector.prototype.render = function(srcSurface, width, height) {
                        var surface = this.game.resourceFactory.createSurface(Math.ceil(width), Math.ceil(height)), renderer = surface.renderer();
                        renderer.begin();
                        var sx1 = this.borderWidth.left, sx2 = srcSurface.width - this.borderWidth.right, sy1 = this.borderWidth.top, sy2 = srcSurface.height - this.borderWidth.bottom, dx1 = this.borderWidth.left, dx2 = width - this.borderWidth.right, dy1 = this.borderWidth.top, dy2 = height - this.borderWidth.bottom, srcCorners = [ {
                            x: 0,
                            y: 0,
                            width: this.borderWidth.left,
                            height: this.borderWidth.top
                        }, {
                            x: sx2,
                            y: 0,
                            width: this.borderWidth.right,
                            height: this.borderWidth.top
                        }, {
                            x: 0,
                            y: sy2,
                            width: this.borderWidth.left,
                            height: this.borderWidth.bottom
                        }, {
                            x: sx2,
                            y: sy2,
                            width: this.borderWidth.right,
                            height: this.borderWidth.bottom
                        } ], destCorners = [ {
                            x: 0,
                            y: 0
                        }, {
                            x: dx2,
                            y: 0
                        }, {
                            x: 0,
                            y: dy2
                        }, {
                            x: dx2,
                            y: dy2
                        } ], i = 0;
                        for (i = 0; i < srcCorners.length; ++i) {
                            var c = srcCorners[i];
                            renderer.save(), renderer.translate(destCorners[i].x, destCorners[i].y), renderer.drawImage(srcSurface, c.x, c.y, c.width, c.height, 0, 0), 
                            renderer.restore();
                        }
                        var srcBorders = [ {
                            x: sx1,
                            y: 0,
                            width: sx2 - sx1,
                            height: this.borderWidth.top
                        }, {
                            x: 0,
                            y: sy1,
                            width: this.borderWidth.left,
                            height: sy2 - sy1
                        }, {
                            x: sx2,
                            y: sy1,
                            width: this.borderWidth.right,
                            height: sy2 - sy1
                        }, {
                            x: sx1,
                            y: sy2,
                            width: sx2 - sx1,
                            height: this.borderWidth.bottom
                        } ], destBorders = [ {
                            x: dx1,
                            y: 0,
                            width: dx2 - dx1,
                            height: this.borderWidth.top
                        }, {
                            x: 0,
                            y: dy1,
                            width: this.borderWidth.left,
                            height: dy2 - dy1
                        }, {
                            x: dx2,
                            y: dy1,
                            width: this.borderWidth.right,
                            height: dy2 - dy1
                        }, {
                            x: dx1,
                            y: dy2,
                            width: dx2 - dx1,
                            height: this.borderWidth.bottom
                        } ];
                        for (i = 0; i < srcBorders.length; ++i) {
                            var s = srcBorders[i], d = destBorders[i];
                            renderer.save(), renderer.translate(d.x, d.y), renderer.transform([ d.width / s.width, 0, 0, d.height / s.height, 0, 0 ]), 
                            renderer.drawImage(srcSurface, s.x, s.y, s.width, s.height, 0, 0), renderer.restore();
                        }
                        var sw = sx2 - sx1, sh = sy2 - sy1, dw = dx2 - dx1, dh = dy2 - dy1;
                        return renderer.save(), renderer.translate(dx1, dy1), renderer.transform([ dw / sw, 0, 0, dh / sh, 0, 0 ]), 
                        renderer.drawImage(srcSurface, sx1, sy1, sw, sh, 0, 0), renderer.restore(), renderer.end(), 
                        surface;
                    }, NinePatchSurfaceEffector;
                }();
                g.NinePatchSurfaceEffector = NinePatchSurfaceEffector;
            }(g || (g = {}));
            var g;
            !function(g) {
                var PathUtil;
                !function(PathUtil) {
                    function resolvePath(base, path) {
                        function split(str) {
                            var ret = str.split("/");
                            return "" === ret[ret.length - 1] && ret.pop(), ret;
                        }
                        if ("" === path) return base;
                        for (var baseComponents = PathUtil.splitPath(base), parts = split(baseComponents.path).concat(split(path)), resolved = [], i = 0; i < parts.length; ++i) {
                            var part = parts[i];
                            switch (part) {
                              case "..":
                                var popped = resolved.pop();
                                if (void 0 === popped || "" === popped || "." === popped) throw g.ExceptionFactory.createAssertionError("PathUtil.resolvePath: invalid arguments");
                                break;

                              case ".":
                                0 === resolved.length && resolved.push(".");
                                break;

                              case "":
                                resolved = [ "" ];
                                break;

                              default:
                                resolved.push(part);
                            }
                        }
                        return baseComponents.host + resolved.join("/");
                    }
                    function resolveDirname(path) {
                        var index = path.lastIndexOf("/");
                        return -1 === index ? path : path.substr(0, index);
                    }
                    function resolveExtname(path) {
                        for (var i = path.length - 1; i >= 0; --i) {
                            var c = path.charAt(i);
                            if ("." === c) return path.substr(i);
                            if ("/" === c) return "";
                        }
                        return "";
                    }
                    function makeNodeModulePaths(path) {
                        var pathComponents = PathUtil.splitPath(path), host = pathComponents.host;
                        path = pathComponents.path, "/" === path[path.length - 1] && (path = path.slice(0, path.length - 1));
                        for (var parts = path.split("/"), firstDir = parts.indexOf("node_modules"), root = firstDir > 0 ? firstDir - 1 : 0, dirs = [], i = parts.length - 1; i >= root; --i) if ("node_modules" !== parts[i]) {
                            var dirParts = parts.slice(0, i + 1);
                            dirParts.push("node_modules");
                            var dir = dirParts.join("/");
                            dirs.push(host + dir);
                        }
                        return dirs;
                    }
                    function addExtname(path, ext) {
                        var index = path.indexOf("?");
                        return -1 === index ? path + "." + ext : path.substring(0, index) + "." + ext + path.substring(index, path.length);
                    }
                    function splitPath(path) {
                        var host = "", doubleSlashIndex = path.indexOf("//");
                        if (doubleSlashIndex >= 0) {
                            var hostSlashIndex = path.indexOf("/", doubleSlashIndex + 2);
                            hostSlashIndex >= 0 ? (host = path.slice(0, hostSlashIndex), path = path.slice(hostSlashIndex)) : (host = path, 
                            path = "/");
                        } else host = "";
                        return {
                            host: host,
                            path: path
                        };
                    }
                    PathUtil.resolvePath = resolvePath, PathUtil.resolveDirname = resolveDirname, PathUtil.resolveExtname = resolveExtname, 
                    PathUtil.makeNodeModulePaths = makeNodeModulePaths, PathUtil.addExtname = addExtname, 
                    PathUtil.splitPath = splitPath;
                }(PathUtil = g.PathUtil || (g.PathUtil = {}));
            }(g || (g = {}));
            var g;
            !function(g) {
                var FontFamily;
                !function(FontFamily) {
                    FontFamily[FontFamily.SansSerif = 0] = "SansSerif", FontFamily[FontFamily.Serif = 1] = "Serif", 
                    FontFamily[FontFamily.Monospace = 2] = "Monospace";
                }(FontFamily = g.FontFamily || (g.FontFamily = {}));
            }(g || (g = {}));
            var g;
            !function(g_1) {
                var BitmapFont = function() {
                    function BitmapFont(param) {
                        this.surface = g_1.Util.asSurface(param.src), this.map = param.map, this.defaultGlyphWidth = param.defaultGlyphWidth, 
                        this.defaultGlyphHeight = param.defaultGlyphHeight, this.missingGlyph = param.missingGlyph, 
                        this.size = param.defaultGlyphHeight;
                    }
                    return BitmapFont.prototype.glyphForCharacter = function(code) {
                        var g = this.map[code] || this.missingGlyph;
                        if (!g) return null;
                        var w = void 0 === g.width ? this.defaultGlyphWidth : g.width, h = void 0 === g.height ? this.defaultGlyphHeight : g.height, offsetX = g.offsetX || 0, offsetY = g.offsetY || 0, advanceWidth = void 0 === g.advanceWidth ? w : g.advanceWidth, surface = 0 === w || 0 === h ? void 0 : this.surface;
                        return new g_1.Glyph(code, g.x, g.y, w, h, offsetX, offsetY, advanceWidth, surface, !0);
                    }, BitmapFont.prototype.destroy = function() {
                        this.surface && !this.surface.destroyed() && this.surface.destroy(), this.map = void 0;
                    }, BitmapFont.prototype.destroyed = function() {
                        return !this.map;
                    }, BitmapFont;
                }();
                g_1.BitmapFont = BitmapFont;
            }(g || (g = {}));
            var g;
            !function(g) {
                var TextBaseline;
                !function(TextBaseline) {
                    TextBaseline[TextBaseline.Top = 0] = "Top", TextBaseline[TextBaseline.Middle = 1] = "Middle", 
                    TextBaseline[TextBaseline.Alphabetic = 2] = "Alphabetic", TextBaseline[TextBaseline.Bottom = 3] = "Bottom";
                }(TextBaseline = g.TextBaseline || (g.TextBaseline = {}));
                var SystemLabel = function(_super) {
                    function SystemLabel(param) {
                        var _this = _super.call(this, param) || this;
                        return _this.text = param.text, _this.fontSize = param.fontSize, _this.textAlign = "textAlign" in param ? param.textAlign : g.TextAlign.Left, 
                        _this.textBaseline = "textBaseline" in param ? param.textBaseline : TextBaseline.Alphabetic, 
                        _this.maxWidth = param.maxWidth, _this.textColor = "textColor" in param ? param.textColor : "black", 
                        _this.fontFamily = "fontFamily" in param ? param.fontFamily : g.FontFamily.SansSerif, 
                        _this.strokeWidth = "strokeWidth" in param ? param.strokeWidth : 0, _this.strokeColor = "strokeColor" in param ? param.strokeColor : "black", 
                        _this.strokeOnly = "strokeOnly" in param ? param.strokeOnly : !1, _this;
                    }
                    return __extends(SystemLabel, _super), SystemLabel.prototype.renderSelf = function(renderer, camera) {
                        if (this.text) {
                            var offsetX;
                            switch (this.textAlign) {
                              case g.TextAlign.Right:
                                offsetX = this.width;
                                break;

                              case g.TextAlign.Center:
                                offsetX = this.width / 2;
                                break;

                              default:
                                offsetX = 0;
                            }
                            renderer.drawSystemText(this.text, offsetX, 0, this.maxWidth, this.fontSize, this.textAlign, this.textBaseline, this.textColor, this.fontFamily, this.strokeWidth, this.strokeColor, this.strokeOnly);
                        }
                        return !0;
                    }, SystemLabel;
                }(g.E);
                g.SystemLabel = SystemLabel;
            }(g || (g = {}));
            var g;
            !function(g) {
                var TextAlign;
                !function(TextAlign) {
                    TextAlign[TextAlign.Left = 0] = "Left", TextAlign[TextAlign.Center = 1] = "Center", 
                    TextAlign[TextAlign.Right = 2] = "Right";
                }(TextAlign = g.TextAlign || (g.TextAlign = {}));
            }(g || (g = {}));
            var g;
            !function(g) {
                var TickGenerationMode;
                !function(TickGenerationMode) {
                    TickGenerationMode[TickGenerationMode.ByClock = 0] = "ByClock", TickGenerationMode[TickGenerationMode.Manual = 1] = "Manual";
                }(TickGenerationMode = g.TickGenerationMode || (g.TickGenerationMode = {}));
            }(g || (g = {}));
            var g;
            !function(g) {
                // Copyright (c) 2014 Andreas Madsen & Emil Bay
                // From https://github.com/AndreasMadsen/xorshift
                // https://github.com/AndreasMadsen/xorshift/blob/master/LICENSE.md
                // Arranged by DWANGO Co., Ltd.
                var Xorshift = function() {
                    function Xorshift(seed) {
                        this.initState(seed);
                    }
                    return Xorshift.deserialize = function(ser) {
                        var ret = new Xorshift(0);
                        return ret._state0U = ser._state0U, ret._state0L = ser._state0L, ret._state1U = ser._state1U, 
                        ret._state1L = ser._state1L, ret;
                    }, Xorshift.prototype.initState = function(seed) {
                        var factor = 1812433253;
                        seed = factor * (seed ^ seed >> 30) + 1, this._state0U = seed, seed = factor * (seed ^ seed >> 30) + 2, 
                        this._state0L = seed, seed = factor * (seed ^ seed >> 30) + 3, this._state1U = seed, 
                        seed = factor * (seed ^ seed >> 30) + 4, this._state1L = seed;
                    }, Xorshift.prototype.randomInt = function() {
                        var s1U = this._state0U, s1L = this._state0L, s0U = this._state1U, s0L = this._state1L;
                        this._state0U = s0U, this._state0L = s0L;
                        var t1U = 0, t1L = 0, t2U = 0, t2L = 0, a1 = 23, m1 = 4294967295 << 32 - a1;
                        t1U = s1U << a1 | (s1L & m1) >>> 32 - a1, t1L = s1L << a1, s1U ^= t1U, s1L ^= t1L, 
                        t1U = s1U ^ s0U, t1L = s1L ^ s0L;
                        var a2 = 17, m2 = 4294967295 >>> 32 - a2;
                        t2U = s1U >>> a2, t2L = s1L >>> a2 | (s1U & m2) << 32 - a2, t1U ^= t2U, t1L ^= t2L;
                        var a3 = 26, m3 = 4294967295 >>> 32 - a3;
                        t2U = s0U >>> a3, t2L = s0L >>> a3 | (s0U & m3) << 32 - a3, t1U ^= t2U, t1L ^= t2L, 
                        this._state1U = t1U, this._state1L = t1L;
                        var sumL = (t1L >>> 0) + (s0L >>> 0);
                        return t2U = t1U + s0U + (sumL / 2 >>> 31) >>> 0, t2L = sumL >>> 0, [ t2U, t2L ];
                    }, Xorshift.prototype.random = function() {
                        var t2 = this.randomInt();
                        return (4294967296 * t2[0] + t2[1]) / 0x10000000000000000;
                    }, Xorshift.prototype.nextInt = function(min, sup) {
                        return Math.floor(min + this.random() * (sup - min));
                    }, Xorshift.prototype.serialize = function() {
                        return {
                            _state0U: this._state0U,
                            _state0L: this._state0L,
                            _state1U: this._state1U,
                            _state1L: this._state1L
                        };
                    }, Xorshift;
                }();
                g.Xorshift = Xorshift;
            }(g || (g = {}));
            var g;
            !function(g) {
                var XorshiftRandomGenerator = function(_super) {
                    function XorshiftRandomGenerator(seed, xorshift) {
                        var _this = this;
                        if (void 0 === seed) throw g.ExceptionFactory.createAssertionError("XorshiftRandomGenerator#constructor: seed is undefined");
                        return _this = _super.call(this, seed) || this, xorshift ? _this._xorshift = g.Xorshift.deserialize(xorshift) : _this._xorshift = new g.Xorshift(seed), 
                        _this;
                    }
                    return __extends(XorshiftRandomGenerator, _super), XorshiftRandomGenerator.deserialize = function(ser) {
                        return new XorshiftRandomGenerator(ser._seed, ser._xorshift);
                    }, XorshiftRandomGenerator.prototype.get = function(min, max) {
                        return this._xorshift.nextInt(min, max + 1);
                    }, XorshiftRandomGenerator.prototype.serialize = function() {
                        return {
                            _seed: this.seed,
                            _xorshift: this._xorshift.serialize()
                        };
                    }, XorshiftRandomGenerator;
                }(g.RandomGenerator);
                g.XorshiftRandomGenerator = XorshiftRandomGenerator;
            }(g || (g = {})), module.exports = g;
        }).call(this);
    }, {} ]
}, {}, []);	require = function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = "function" == typeof require && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                var f = new Error("Cannot find module '" + o + "'");
                throw f.code = "MODULE_NOT_FOUND", f;
            }
            var l = n[o] = {
                exports: {}
            };
            t[o][0].call(l.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    for (var i = "function" == typeof require && require, o = 0; o < r.length; o++) s(r[o]);
    return s;
}({
    1: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), Clock = function() {
            function Clock(param) {
                this.fps = param.fps, this.scaleFactor = param.scaleFactor || 1, this.frameTrigger = new g.Trigger(), 
                this.rawFrameTrigger = new g.Trigger(), this._platform = param.platform, this._maxFramePerOnce = param.maxFramePerOnce, 
                this._deltaTimeBrokenThreshold = param.deltaTimeBrokenThreshold || Clock.DEFAULT_DELTA_TIME_BROKEN_THRESHOLD, 
                param.frameHandler && this.frameTrigger.add(param.frameHandler, param.frameHandlerOwner), 
                this.running = !1, this._totalDeltaTime = 0, this._onLooperCall_bound = this._onLooperCall.bind(this), 
                this._looper = this._platform.createLooper(this._onLooperCall_bound), this._waitTime = 0, 
                this._waitTimeDoubled = 0, this._waitTimeMax = 0, this._skipFrameWaitTime = 0, this._realMaxFramePerOnce = 0;
            }
            return Clock.prototype.start = function() {
                this.running || (this._totalDeltaTime = 0, this._updateWaitTimes(this.fps, this.scaleFactor), 
                this._looper.start(), this.running = !0);
            }, Clock.prototype.stop = function() {
                this.running && (this._looper.stop(), this.running = !1);
            }, Clock.prototype.changeScaleFactor = function(scaleFactor) {
                this.running ? (this.stop(), this.scaleFactor = scaleFactor, this.start()) : this.scaleFactor = scaleFactor;
            }, Clock.prototype._onLooperCall = function(deltaTime) {
                if (0 >= deltaTime) return this._waitTime - this._totalDeltaTime;
                deltaTime > this._deltaTimeBrokenThreshold && (deltaTime = this._waitTime);
                var totalDeltaTime = this._totalDeltaTime;
                if (totalDeltaTime += deltaTime, totalDeltaTime <= this._skipFrameWaitTime) return this._totalDeltaTime = totalDeltaTime, 
                this._waitTime - totalDeltaTime;
                for (var frameCount = totalDeltaTime < this._waitTimeDoubled ? 1 : totalDeltaTime > this._waitTimeMax ? this._realMaxFramePerOnce : totalDeltaTime / this._waitTime | 0, fc = frameCount, arg = {
                    interrupt: !1
                }; fc > 0 && this.running && !arg.interrupt; ) --fc, this.frameTrigger.fire(arg);
                return totalDeltaTime -= (frameCount - fc) * this._waitTime, this.rawFrameTrigger.fire(), 
                this._totalDeltaTime = totalDeltaTime, this._waitTime - totalDeltaTime;
            }, Clock.prototype._updateWaitTimes = function(fps, scaleFactor) {
                var realFps = fps * scaleFactor;
                this._waitTime = 1e3 / realFps, this._waitTimeDoubled = Math.max(2e3 / realFps | 0, 1), 
                this._waitTimeMax = Math.max(scaleFactor * (1e3 * this._maxFramePerOnce / realFps) | 0, 1), 
                this._skipFrameWaitTime = this._waitTime * Clock.ANTICIPATE_RATE | 0, this._realMaxFramePerOnce = this._maxFramePerOnce * scaleFactor;
            }, Clock.ANTICIPATE_RATE = .8, Clock.DEFAULT_DELTA_TIME_BROKEN_THRESHOLD = 150, 
            Clock;
        }();
        exports.Clock = Clock;
    }, {
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    2: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = (require("@akashic/akashic-pdi"), require("@akashic/akashic-engine")), PointEventResolver_1 = require("./PointEventResolver"), EventBuffer = function() {
            function EventBuffer(param) {
                this._amflow = param.amflow, this._isLocalReceiver = !0, this._isReceiver = !1, 
                this._isSender = !1, this._isDiscarder = !1, this._defaultEventPriority = 0, this._buffer = null, 
                this._joinLeaveBuffer = null, this._localBuffer = null, this._filters = null, this._unfilteredLocalEvents = [], 
                this._unfilteredEvents = [], this._unfilteredJoinLeaves = [], this._pointEventResolver = new PointEventResolver_1.PointEventResolver({
                    game: param.game
                }), this._onEvent_bound = this.onEvent.bind(this);
            }
            return EventBuffer.isEventLocal = function(pev) {
                switch (pev[0]) {
                  case 0:
                    return pev[5];

                  case 1:
                    return pev[3];

                  case 2:
                    return pev[4];

                  case 32:
                    return pev[4];

                  case 33:
                    return pev[7];

                  case 34:
                    return pev[11];

                  case 35:
                    return pev[11];

                  case 64:
                    return pev[5];

                  default:
                    throw g.ExceptionFactory.createAssertionError("EventBuffer.isEventLocal");
                }
            }, EventBuffer.prototype.setMode = function(param) {
                null != param.isLocalReceiver && (this._isLocalReceiver = param.isLocalReceiver), 
                null != param.isReceiver && this._isReceiver !== param.isReceiver && (this._isReceiver = param.isReceiver, 
                param.isReceiver ? this._amflow.onEvent(this._onEvent_bound) : this._amflow.offEvent(this._onEvent_bound)), 
                null != param.isSender && (this._isSender = param.isSender), null != param.isDiscarder && (this._isDiscarder = param.isDiscarder), 
                null != param.defaultEventPriority && (this._defaultEventPriority = param.defaultEventPriority);
            }, EventBuffer.prototype.getMode = function() {
                return {
                    isLocalReceiver: this._isLocalReceiver,
                    isReceiver: this._isReceiver,
                    isSender: this._isSender,
                    isDiscarder: this._isDiscarder,
                    defaultEventPriority: this._defaultEventPriority
                };
            }, EventBuffer.prototype.onEvent = function(pev) {
                return EventBuffer.isEventLocal(pev) ? void (this._isLocalReceiver && !this._isDiscarder && this._unfilteredLocalEvents.push(pev)) : (this._isReceiver && !this._isDiscarder && (0 === pev[0] || 1 === pev[0] ? this._unfilteredJoinLeaves.push(pev) : this._unfilteredEvents.push(pev)), 
                void (this._isSender && (null == pev[1] && (pev[1] = this._defaultEventPriority), 
                this._amflow.sendEvent(pev))));
            }, EventBuffer.prototype.onPointEvent = function(e) {
                var pev;
                switch (e.type) {
                  case 0:
                    pev = this._pointEventResolver.pointDown(e);
                    break;

                  case 1:
                    pev = this._pointEventResolver.pointMove(e);
                    break;

                  case 2:
                    pev = this._pointEventResolver.pointUp(e);
                }
                pev && this.onEvent(pev);
            }, EventBuffer.prototype.addEventDirect = function(pev) {
                if (EventBuffer.isEventLocal(pev)) {
                    if (!this._isLocalReceiver || this._isDiscarder) return;
                    return void (this._localBuffer ? this._localBuffer.push(pev) : this._localBuffer = [ pev ]);
                }
                this._isReceiver && !this._isDiscarder && (0 === pev[0] || 1 === pev[0] ? this._joinLeaveBuffer ? this._joinLeaveBuffer.push(pev) : this._joinLeaveBuffer = [ pev ] : this._buffer ? this._buffer.push(pev) : this._buffer = [ pev ]), 
                this._isSender && (null == pev[1] && (pev[1] = this._defaultEventPriority), this._amflow.sendEvent(pev));
            }, EventBuffer.prototype.readEvents = function() {
                var ret = this._buffer;
                return this._buffer = null, ret;
            }, EventBuffer.prototype.readJoinLeaves = function() {
                var ret = this._joinLeaveBuffer;
                return this._joinLeaveBuffer = null, ret;
            }, EventBuffer.prototype.readLocalEvents = function() {
                var ret = this._localBuffer;
                return this._localBuffer = null, ret;
            }, EventBuffer.prototype.addFilter = function(filter, handleEmpty) {
                this._filters || (this._filters = []), this._filters.push({
                    func: filter,
                    handleEmpty: !!handleEmpty
                });
            }, EventBuffer.prototype.removeFilter = function(filter) {
                if (this._filters) {
                    if (!filter) return void (this._filters = null);
                    for (var i = this._filters.length - 1; i >= 0; --i) this._filters[i].func === filter && this._filters.splice(i, 1);
                }
            }, EventBuffer.prototype.processEvents = function() {
                var lpevs = this._unfilteredLocalEvents, pevs = this._unfilteredEvents, joins = this._unfilteredJoinLeaves;
                if (!this._filters) return lpevs.length > 0 && (this._unfilteredLocalEvents = [], 
                this._localBuffer = this._localBuffer ? this._localBuffer.concat(lpevs) : lpevs), 
                pevs.length > 0 && (this._unfilteredEvents = [], this._buffer = this._buffer ? this._buffer.concat(pevs) : pevs), 
                void (joins.length > 0 && (this._unfilteredJoinLeaves = [], this._joinLeaveBuffer = this._joinLeaveBuffer ? this._joinLeaveBuffer.concat(joins) : joins));
                if (0 === lpevs.length && 0 === pevs.length && 0 === joins.length) for (var i = 0; i < this._filters.length; ++i) if (this._filters[i].handleEmpty) {
                    var gpevs = this._filters[i].func([]);
                    if (gpevs) for (var j = 0; j < gpevs.length; ++j) {
                        var pev = gpevs[j];
                        EventBuffer.isEventLocal(pev) ? lpevs.push(pev) : 0 === pev[0] || 1 === pev[0] ? joins.push(pev) : pevs.push(pev);
                    }
                }
                if (lpevs.length > 0) {
                    this._unfilteredLocalEvents = [];
                    for (var i = 0; i < this._filters.length && (lpevs = this._filters[i].func(lpevs), 
                    lpevs); ++i) ;
                    lpevs && lpevs.length > 0 && (this._localBuffer = this._localBuffer ? this._localBuffer.concat(lpevs) : lpevs);
                }
                if (pevs.length > 0) {
                    this._unfilteredEvents = [];
                    for (var i = 0; i < this._filters.length && (pevs = this._filters[i].func(pevs), 
                    pevs); ++i) ;
                    pevs && pevs.length > 0 && (this._buffer = this._buffer ? this._buffer.concat(pevs) : pevs);
                }
                if (joins.length > 0) {
                    this._unfilteredJoinLeaves = [];
                    for (var i = 0; i < this._filters.length && joins && joins.length > 0 && (joins = this._filters[i].func(joins), 
                    joins); ++i) ;
                    joins && joins.length > 0 && (this._joinLeaveBuffer = this._joinLeaveBuffer ? this._joinLeaveBuffer.concat(joins) : joins);
                }
            }, EventBuffer;
        }();
        exports.EventBuffer = EventBuffer;
    }, {
        "./PointEventResolver": 13,
        "@akashic/akashic-engine": "@akashic/akashic-engine",
        "@akashic/akashic-pdi": 22
    } ],
    3: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), EventConverter = function() {
            function EventConverter(param) {
                this._game = param.game, this._playerTable = {};
            }
            return EventConverter.prototype.toGameEvent = function(pev) {
                var pointerId, entityId, target, point, startDelta, prevDelta, local, timestamp, eventCode = pev[0], prio = pev[1], playerId = pev[2], player = this._playerTable[playerId] || {
                    id: playerId
                };
                switch (eventCode) {
                  case 0:
                    player = {
                        id: playerId,
                        name: pev[3]
                    }, this._playerTable[playerId] = player;
                    var store = void 0;
                    if (pev[4]) {
                        var keys = [], values = [];
                        pev[4].map(function(data) {
                            keys.push(data.readKey), values.push(data.values);
                        }), store = new g.StorageValueStore(keys, values);
                    }
                    return new g.JoinEvent(player, store, prio);

                  case 1:
                    return delete this._playerTable[player.id], new g.LeaveEvent(player, prio);

                  case 2:
                    return timestamp = pev[3], new g.TimestampEvent(timestamp, player, prio);

                  case 32:
                    return local = pev[4], new g.MessageEvent(pev[3], player, local, prio);

                  case 33:
                    return local = pev[7], pointerId = pev[3], entityId = pev[6], target = null == entityId ? void 0 : entityId >= 0 ? this._game.db[entityId] : this._game._localDb[entityId], 
                    point = {
                        x: pev[4],
                        y: pev[5]
                    }, new g.PointDownEvent(pointerId, target, point, player, local, prio);

                  case 34:
                    return local = pev[11], pointerId = pev[3], entityId = pev[10], target = null == entityId ? void 0 : entityId >= 0 ? this._game.db[entityId] : this._game._localDb[entityId], 
                    point = {
                        x: pev[4],
                        y: pev[5]
                    }, startDelta = {
                        x: pev[6],
                        y: pev[7]
                    }, prevDelta = {
                        x: pev[8],
                        y: pev[9]
                    }, new g.PointMoveEvent(pointerId, target, point, prevDelta, startDelta, player, local, prio);

                  case 35:
                    return local = pev[11], pointerId = pev[3], entityId = pev[10], target = null == entityId ? void 0 : entityId >= 0 ? this._game.db[entityId] : this._game._localDb[entityId], 
                    point = {
                        x: pev[4],
                        y: pev[5]
                    }, startDelta = {
                        x: pev[6],
                        y: pev[7]
                    }, prevDelta = {
                        x: pev[8],
                        y: pev[9]
                    }, new g.PointUpEvent(pointerId, target, point, prevDelta, startDelta, player, local, prio);

                  case 64:
                    local = pev[5];
                    var operationCode = pev[3], operationData = pev[4], decodedData = this._game._decodeOperationPluginOperation(operationCode, operationData);
                    return new g.OperationEvent(operationCode, decodedData, player, local, prio);

                  default:
                    throw g.ExceptionFactory.createAssertionError("EventConverter#toGameEvent");
                }
            }, EventConverter.prototype.toPlaylogEvent = function(e, preservePlayer) {
                var targetId, playerId;
                switch (e.type) {
                  case g.EventType.Join:
                  case g.EventType.Leave:
                    throw g.ExceptionFactory.createAssertionError("EventConverter#toPlaylogEvent: Invalid type: " + g.EventType[e.type]);

                  case g.EventType.Timestamp:
                    var ts = e;
                    return playerId = preservePlayer ? ts.player.id : this._game.player.id, [ 2, ts.priority, playerId, ts.timestamp ];

                  case g.EventType.PointDown:
                    var pointDown = e;
                    return targetId = pointDown.target ? pointDown.target.id : null, playerId = preservePlayer ? pointDown.player.id : this._game.player.id, 
                    [ 33, pointDown.priority, playerId, pointDown.pointerId, pointDown.point.x, pointDown.point.y, targetId, !!pointDown.local ];

                  case g.EventType.PointMove:
                    var pointMove = e;
                    return targetId = pointMove.target ? pointMove.target.id : null, playerId = preservePlayer ? pointMove.player.id : this._game.player.id, 
                    [ 34, pointMove.priority, playerId, pointMove.pointerId, pointMove.point.x, pointMove.point.y, pointMove.startDelta.x, pointMove.startDelta.y, pointMove.prevDelta.x, pointMove.prevDelta.y, targetId, !!pointMove.local ];

                  case g.EventType.PointUp:
                    var pointUp = e;
                    return targetId = pointUp.target ? pointUp.target.id : null, playerId = preservePlayer ? pointUp.player.id : this._game.player.id, 
                    [ 35, pointUp.priority, playerId, pointUp.pointerId, pointUp.point.x, pointUp.point.y, pointUp.startDelta.x, pointUp.startDelta.y, pointUp.prevDelta.x, pointUp.prevDelta.y, targetId, !!pointUp.local ];

                  case g.EventType.Message:
                    var message = e;
                    return playerId = preservePlayer ? message.player.id : this._game.player.id, [ 32, message.priority, playerId, message.data, !!message.local ];

                  case g.EventType.Operation:
                    var op = e;
                    return playerId = preservePlayer ? op.player.id : this._game.player.id, [ 64, op.priority, playerId, op.code, op.data, !!op.local ];

                  default:
                    throw g.ExceptionFactory.createAssertionError("Unknown type: " + e.type);
                }
            }, EventConverter.prototype.makePlaylogOperationEvent = function(op) {
                var playerId = this._game.player.id, priority = null != op.priority ? op.priority : 0;
                return [ 64, priority, playerId, op._code, op.data, !!op.local ];
            }, EventConverter;
        }();
        exports.EventConverter = EventConverter;
    }, {
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    4: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
    }, {} ],
    5: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var ExecutionMode;
        !function(ExecutionMode) {
            ExecutionMode[ExecutionMode.Active = 0] = "Active", ExecutionMode[ExecutionMode.Passive = 1] = "Passive";
        }(ExecutionMode || (ExecutionMode = {})), exports["default"] = ExecutionMode;
    }, {} ],
    6: [ function(require, module, exports) {
        "use strict";
        var __extends = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            };
            return function(d, b) {
                function __() {
                    this.constructor = d;
                }
                extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
                new __());
            };
        }();
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), Game = function(_super) {
            function Game(param) {
                var _this = _super.call(this, param.configuration, param.resourceFactory, param.assetBase, param.player.id, param.operationPluginViewInfo) || this;
                return _this.agePassedTrigger = new g.Trigger(), _this.skippingChangedTrigger = new g.Trigger(), 
                _this.abortTrigger = new g.Trigger(), _this.player = param.player, _this.raiseEventTrigger = new g.Trigger(), 
                _this.raiseTickTrigger = new g.Trigger(), _this.snapshotTrigger = new g.Trigger(), 
                _this.isSnapshotSaver = !!param.isSnapshotSaver, _this._getCurrentTimeFunc = null, 
                _this._eventFilterFuncs = null, _this._notifyPassedAgeTable = {}, _this._gameArgs = param.gameArgs, 
                _this._globalGameArgs = param.globalGameArgs, _this;
            }
            return __extends(Game, _super), Game.prototype.requestNotifyAgePassed = function(age) {
                this._notifyPassedAgeTable[age] = !0;
            }, Game.prototype.cancelNotifyAgePassed = function(age) {
                delete this._notifyPassedAgeTable[age];
            }, Game.prototype.fireAgePassedIfNeeded = function() {
                var age = this.age - 1;
                return this._notifyPassedAgeTable[age] ? (delete this._notifyPassedAgeTable[age], 
                this.agePassedTrigger.fire(age), !0) : !1;
            }, Game.prototype.setCurrentTimeFunc = function(fun) {
                this._getCurrentTimeFunc = fun;
            }, Game.prototype.setEventFilterFuncs = function(funcs) {
                this._eventFilterFuncs = funcs;
            }, Game.prototype.setStorageFunc = function(funcs) {
                this.storage._registerLoad(funcs.storageGetFunc), this.storage._registerWrite(funcs.storagePutFunc), 
                this.storage.requestValuesForJoinPlayer = funcs.requestValuesForJoinFunc;
            }, Game.prototype.raiseEvent = function(event) {
                this.raiseEventTrigger.fire(event);
            }, Game.prototype.raiseTick = function(events) {
                if (!this.scene() || this.scene().tickGenerationMode !== g.TickGenerationMode.Manual) throw g.ExceptionFactory.createAssertionError("Game#raiseTick(): tickGenerationMode for the current scene is not Manual.");
                this.raiseTickTrigger.fire(events);
            }, Game.prototype.addEventFilter = function(filter, handleEmpty) {
                this._eventFilterFuncs.addFilter(filter, handleEmpty);
            }, Game.prototype.removeEventFilter = function(filter) {
                this._eventFilterFuncs.removeFilter(filter);
            }, Game.prototype.shouldSaveSnapshot = function() {
                return this.isSnapshotSaver;
            }, Game.prototype.saveSnapshot = function(gameSnapshot, timestamp) {
                void 0 === timestamp && (timestamp = this._getCurrentTimeFunc()), this.shouldSaveSnapshot() && this.snapshotTrigger.fire({
                    frame: this.age,
                    timestamp: timestamp,
                    data: {
                        randGenSer: this.random[0].serialize(),
                        gameSnapshot: gameSnapshot
                    }
                });
            }, Game.prototype._restartWithSnapshot = function(snapshot) {
                var data = snapshot.data;
                if (this._eventFilterFuncs.removeFilter(), null != data.seed) {
                    var randGen = new g.XorshiftRandomGenerator(data.seed);
                    this._reset({
                        age: snapshot.frame,
                        randGen: randGen
                    }), this._loadAndStart({
                        args: this._gameArgs,
                        globalArgs: this._globalGameArgs
                    });
                } else {
                    var randGen = new g.XorshiftRandomGenerator(0, data.randGenSer);
                    this._reset({
                        age: snapshot.frame,
                        randGen: randGen
                    }), this._loadAndStart({
                        snapshot: data.gameSnapshot
                    });
                }
            }, Game.prototype._leaveGame = function() {}, Game.prototype._terminateGame = function() {
                this.abortTrigger.fire();
            }, Game;
        }(g.Game);
        exports.Game = Game;
    }, {
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    7: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var es6_promise_1 = require("es6-promise"), g = require("@akashic/akashic-engine"), ExecutionMode_1 = require("./ExecutionMode"), Game_1 = require("./Game"), EventBuffer_1 = require("./EventBuffer"), GameLoop_1 = require("./GameLoop"), PdiUtil_1 = require("./PdiUtil"), GameDriver = function() {
            function GameDriver(param) {
                this.errorTrigger = new g.Trigger(), param.errorHandler && this.errorTrigger.add(param.errorHandler, param.errorHandlerOwner), 
                this.configurationLoadedTrigger = new g.Trigger(), this.gameCreatedTrigger = new g.Trigger(), 
                this._platform = param.platform, this._loadConfigurationFunc = PdiUtil_1.PdiUtil.makeLoadConfigurationFunc(param.platform), 
                this._player = param.player, this._rendererRequirement = null, this._playId = null, 
                this._game = null, this._gameLoop = null, this._eventBuffer = null, this._openedAmflow = !1, 
                this._playToken = null, this._permission = null, this._hidden = !1;
            }
            return GameDriver.prototype.initialize = function(param, callback) {
                this.doInitialize(param).then(function() {
                    callback();
                }, callback);
            }, GameDriver.prototype.changeState = function(param, callback) {
                var _this = this, pausing = this._gameLoop && this._gameLoop.running;
                pausing && this._gameLoop.stop(), this.initialize(param, function(err) {
                    return err ? void callback(err) : (pausing && _this._gameLoop.start(), void callback());
                });
            }, GameDriver.prototype.startGame = function() {
                return this._gameLoop ? void this._gameLoop.start() : void this.errorTrigger.fire(new Error("Not initialized"));
            }, GameDriver.prototype.stopGame = function() {
                this._gameLoop && this._gameLoop.stop();
            }, GameDriver.prototype.setNextAge = function(age) {
                this._gameLoop.setNextAge(age);
            }, GameDriver.prototype.getPermission = function() {
                return this._permission;
            }, GameDriver.prototype.getDriverConfiguration = function() {
                return {
                    playId: this._playId,
                    playToken: this._playToken,
                    executionMode: this._gameLoop ? this._gameLoop.getExecutionMode() : void 0,
                    eventBufferMode: this._eventBuffer ? this._eventBuffer.getMode() : void 0
                };
            }, GameDriver.prototype.getLoopConfiguration = function() {
                return this._gameLoop ? this._gameLoop.getLoopConfiguration() : null;
            }, GameDriver.prototype.getHidden = function() {
                return this._hidden;
            }, GameDriver.prototype.resetPrimarySurface = function(width, height, rendererCandidates) {
                rendererCandidates = rendererCandidates ? rendererCandidates : this._rendererRequirement ? this._rendererRequirement.rendererCandidates : null;
                var game = this._game, pf = this._platform, primarySurface = pf.getPrimarySurface();
                game.renderers = game.renderers.filter(function(renderer) {
                    return renderer !== primarySurface.renderer();
                }), pf.setRendererRequirement({
                    primarySurfaceWidth: width,
                    primarySurfaceHeight: height,
                    rendererCandidates: rendererCandidates
                }), this._rendererRequirement = {
                    primarySurfaceWidth: width,
                    primarySurfaceHeight: height,
                    rendererCandidates: rendererCandidates
                }, game.renderers.push(pf.getPrimarySurface().renderer()), game.width = width, game.height = height, 
                game.resized.fire({
                    width: width,
                    height: height
                }), game.modified = !0;
            }, GameDriver.prototype.doInitialize = function(param) {
                var _this = this, p = new es6_promise_1.Promise(function(resolve, reject) {
                    return _this._gameLoop && _this._gameLoop.running ? reject(new Error("Game is running. Must be stopped.")) : (_this._gameLoop && param.loopConfiguration && _this._gameLoop.setLoopConfiguration(param.loopConfiguration), 
                    null != param.hidden && (_this._hidden = param.hidden, _this._game && _this._game._setMuted(param.hidden)), 
                    void resolve());
                }).then(function() {
                    return _this._doSetDriverConfiguration(param.driverConfiguration);
                });
                return param.configurationUrl ? p.then(function() {
                    return _this._loadConfiguration(param.configurationUrl, param.assetBase);
                }).then(function(conf) {
                    return _this._createGame(conf, _this._player, param);
                }) : p;
            }, GameDriver.prototype._doSetDriverConfiguration = function(dconf) {
                var _this = this;
                if (null == dconf) return es6_promise_1.Promise.resolve();
                void 0 === dconf.playId && (dconf.playId = this._playId), void 0 === dconf.playToken && (dconf.playToken = this._playToken), 
                void 0 === dconf.eventBufferMode && (dconf.executionMode === ExecutionMode_1["default"].Active ? dconf.eventBufferMode = {
                    isReceiver: !0,
                    isSender: !1
                } : dconf.executionMode === ExecutionMode_1["default"].Passive && (dconf.eventBufferMode = {
                    isReceiver: !1,
                    isSender: !0
                }));
                var p = es6_promise_1.Promise.resolve();
                return this._playId !== dconf.playId && (p = p.then(function() {
                    return _this._doOpenAmflow(dconf.playId);
                })), this._playToken !== dconf.playToken && (p = p.then(function() {
                    return _this._doAuthenticate(dconf.playToken);
                })), p.then(function() {
                    return new es6_promise_1.Promise(function(resolve, reject) {
                        null != dconf.eventBufferMode && (null == dconf.eventBufferMode.defaultEventPriority && (dconf.eventBufferMode.defaultEventPriority = _this._permission.maxEventPriority), 
                        _this._eventBuffer && _this._eventBuffer.setMode(dconf.eventBufferMode)), null != dconf.executionMode && _this._gameLoop && _this._gameLoop.setExecutionMode(dconf.executionMode), 
                        resolve();
                    });
                });
            }, GameDriver.prototype._doCloseAmflow = function() {
                var _this = this;
                return new es6_promise_1.Promise(function(resolve, reject) {
                    return _this._openedAmflow ? void _this._platform.amflow.close(function(err) {
                        return _this._openedAmflow = !1, err ? reject(err) : void resolve();
                    }) : resolve();
                });
            }, GameDriver.prototype._doOpenAmflow = function(playId) {
                var _this = this;
                if (void 0 === playId) return es6_promise_1.Promise.resolve();
                var p = this._doCloseAmflow();
                return p.then(function() {
                    return new es6_promise_1.Promise(function(resolve, reject) {
                        return null === playId ? resolve() : void _this._platform.amflow.open(playId, function(err) {
                            return err ? reject(err) : (_this._openedAmflow = !0, _this._playId = playId, _this._game && _this._updateGamePlayId(_this._game), 
                            void resolve());
                        });
                    });
                });
            }, GameDriver.prototype._doAuthenticate = function(playToken) {
                var _this = this;
                return null == playToken ? es6_promise_1.Promise.resolve() : new es6_promise_1.Promise(function(resolve, reject) {
                    _this._platform.amflow.authenticate(playToken, function(err, permission) {
                        return err ? reject(err) : (_this._playToken = playToken, _this._permission = permission, 
                        _this._game && (_this._game.isSnapshotSaver = _this._permission.writeTick), void resolve());
                    });
                });
            }, GameDriver.prototype._loadConfiguration = function(configurationUrl, basePath) {
                var _this = this;
                return new es6_promise_1.Promise(function(resolve, reject) {
                    _this._loadConfigurationFunc(configurationUrl, basePath, function(err, conf) {
                        return err ? reject(err) : (_this.configurationLoadedTrigger.fire(conf), void resolve(conf));
                    });
                });
            }, GameDriver.prototype._putZerothStartPoint = function(data) {
                var _this = this;
                return new es6_promise_1.Promise(function(resolve, reject) {
                    var zerothStartPoint = {
                        frame: 0,
                        timestamp: 0,
                        data: data
                    };
                    _this._platform.amflow.putStartPoint(zerothStartPoint, function(err) {
                        return err ? reject(err) : void resolve();
                    });
                });
            }, GameDriver.prototype._getZerothStartPointData = function() {
                var _this = this;
                return new es6_promise_1.Promise(function(resolve, reject) {
                    _this._platform.amflow.getStartPoint({
                        frame: 0
                    }, function(err, startPoint) {
                        if (err) return reject(err);
                        var data = startPoint.data;
                        return "number" != typeof data.seed ? reject(new Error("GameDriver#_getRandomSeed: No seed found.")) : void resolve(data);
                    });
                });
            }, GameDriver.prototype._createGame = function(conf, player, param) {
                var p, _this = this, putSeed = param.driverConfiguration.executionMode === ExecutionMode_1["default"].Active && this._permission.writeTick;
                return p = putSeed ? this._putZerothStartPoint({
                    seed: Date.now(),
                    globalArgs: param.globalGameArgs,
                    fps: conf.fps,
                    startedAt: Date.now()
                }) : es6_promise_1.Promise.resolve(), p = p.then(function() {
                    return _this._getZerothStartPointData();
                }), p.then(function(zerothData) {
                    var pf = _this._platform, driverConf = param.driverConfiguration || {
                        eventBufferMode: {
                            isReceiver: !0,
                            isSender: !1
                        },
                        executionMode: ExecutionMode_1["default"].Active
                    }, seed = zerothData.seed, args = param.gameArgs, globalArgs = zerothData.globalArgs, startedAt = zerothData.startedAt, rendererRequirement = {
                        primarySurfaceWidth: conf.width,
                        primarySurfaceHeight: conf.height,
                        rendererCandidates: conf.renderers
                    };
                    pf.setRendererRequirement(rendererRequirement);
                    var game = new Game_1.Game({
                        configuration: conf,
                        player: player,
                        resourceFactory: pf.getResourceFactory(),
                        assetBase: param.assetBase,
                        isSnapshotSaver: _this._permission.writeTick,
                        operationPluginViewInfo: pf.getOperationPluginViewInfo ? pf.getOperationPluginViewInfo() : null,
                        gameArgs: args,
                        globalGameArgs: globalArgs
                    }), eventBuffer = new EventBuffer_1.EventBuffer({
                        game: game,
                        amflow: pf.amflow
                    });
                    eventBuffer.setMode(driverConf.eventBufferMode), pf.setPlatformEventHandler(eventBuffer), 
                    game.setEventFilterFuncs({
                        addFilter: eventBuffer.addFilter.bind(eventBuffer),
                        removeFilter: eventBuffer.removeFilter.bind(eventBuffer)
                    }), game.renderers.push(pf.getPrimarySurface().renderer());
                    var gameLoop = new GameLoop_1.GameLoop({
                        game: game,
                        amflow: pf.amflow,
                        platform: pf,
                        executionMode: driverConf.executionMode,
                        eventBuffer: eventBuffer,
                        configuration: param.loopConfiguration,
                        startedAt: startedAt,
                        profiler: param.profiler
                    });
                    game.setCurrentTimeFunc(gameLoop.getCurrentTime.bind(gameLoop)), game._reset({
                        age: 0,
                        randGen: new g.XorshiftRandomGenerator(seed)
                    }), _this._updateGamePlayId(game), _this._hidden && game._setMuted(!0), game.snapshotTrigger.add(function(startPoint) {
                        _this._platform.amflow.putStartPoint(startPoint, function(err) {
                            err && _this.errorTrigger.fire(err);
                        });
                    }), _this._game = game, _this._eventBuffer = eventBuffer, _this._gameLoop = gameLoop, 
                    _this._rendererRequirement = rendererRequirement, _this.gameCreatedTrigger.fire(game), 
                    _this._game._loadAndStart({
                        args: param.gameArgs || void 0
                    });
                });
            }, GameDriver.prototype._updateGamePlayId = function(game) {
                var _this = this;
                game.playId = this._playId, game.external.send = function(data) {
                    _this._platform.sendToExternal(_this._playId, data);
                };
            }, GameDriver;
        }();
        exports.GameDriver = GameDriver;
    }, {
        "./EventBuffer": 2,
        "./ExecutionMode": 5,
        "./Game": 6,
        "./GameLoop": 8,
        "./PdiUtil": 12,
        "@akashic/akashic-engine": "@akashic/akashic-engine",
        "es6-promise": 23
    } ],
    8: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), LoopMode_1 = require("./LoopMode"), LoopRenderMode_1 = require("./LoopRenderMode"), ExecutionMode_1 = require("./ExecutionMode"), Clock_1 = require("./Clock"), ProfilerClock_1 = require("./ProfilerClock"), EventConverter_1 = require("./EventConverter"), TickController_1 = require("./TickController"), GameLoop = function() {
            function GameLoop(param) {
                this.errorTrigger = new g.Trigger(), this.running = !1, this._currentTime = 0, this._frameTime = 1e3 / param.game.fps, 
                param.errorHandler && this.errorTrigger.add(param.errorHandler, param.errorHandlerOwner);
                var conf = param.configuration;
                this._startedAt = param.startedAt, this._targetTimeFunc = conf.targetTimeFunc || null, 
                this._targetTimeOffset = conf.targetTimeOffset || null, this._originDate = conf.originDate || null, 
                this._realTargetTimeOffset = null != this._originDate ? this._originDate - this._startedAt : this._targetTimeOffset || 0, 
                this._delayIgnoreThreshold = conf.delayIgnoreThreshold || GameLoop.DEFAULT_DELAY_IGNORE_THRESHOLD, 
                this._skipTicksAtOnce = conf.skipTicksAtOnce || GameLoop.DEFAULT_SKIP_TICKS_AT_ONCE, 
                this._skipThreshold = conf.skipThreshold || GameLoop.DEFAULT_SKIP_THRESHOLD, this._jumpTryThreshold = conf.jumpTryThreshold || GameLoop.DEFAULT_JUMP_TRY_THRESHOLD, 
                this._jumpIgnoreThreshold = conf.jumpIgnoreThreshold || GameLoop.DEFAULT_JUMP_IGNORE_THRESHOLD, 
                this._pollingTickThreshold = conf._pollingTickThreshold || GameLoop.DEFAULT_POLLING_TICK_THRESHOLD, 
                this._playbackRate = conf.playbackRate || 1;
                var loopRenderMode = null != conf.loopRenderMode ? conf.loopRenderMode : LoopRenderMode_1["default"].AfterRawFrame;
                this._loopRenderMode = null, this._loopMode = conf.loopMode, this._amflow = param.amflow, 
                this._game = param.game, this._eventBuffer = param.eventBuffer, this._executionMode = param.executionMode, 
                this._sceneTickMode = null, this._sceneLocalMode = null, this._targetAge = null != conf.targetAge ? conf.targetAge : null, 
                this._waitingStartPoint = !1, this._lastRequestedStartPointAge = -1, this._lastRequestedStartPointTime = -1, 
                this._waitingNextTick = !1, this._skipping = !1, this._lastPollingTickTime = 0, 
                param.profiler ? this._clock = new ProfilerClock_1.ProfilerClock({
                    fps: param.game.fps,
                    scaleFactor: this._playbackRate,
                    platform: param.platform,
                    maxFramePerOnce: 5,
                    profiler: param.profiler
                }) : this._clock = new Clock_1.Clock({
                    fps: param.game.fps,
                    scaleFactor: this._playbackRate,
                    platform: param.platform,
                    maxFramePerOnce: 5
                }), this._tickController = new TickController_1.TickController({
                    amflow: param.amflow,
                    clock: this._clock,
                    game: param.game,
                    eventBuffer: param.eventBuffer,
                    executionMode: param.executionMode,
                    errorHandler: this.errorTrigger.fire,
                    errorHandlerOwner: this.errorTrigger
                }), this._eventConverter = new EventConverter_1.EventConverter({
                    game: param.game
                }), this._tickBuffer = this._tickController.getBuffer(), this._onGotStartPoint_bound = this._onGotStartPoint.bind(this), 
                this._setLoopRenderMode(loopRenderMode), this._game.setStorageFunc(this._tickController.storageFunc()), 
                this._game.raiseEventTrigger.add(this._onGameRaiseEvent, this), this._game.raiseTickTrigger.add(this._onGameRaiseTick, this), 
                this._game._started.add(this._onGameStarted, this), this._game._operationPluginOperated.add(this._onGameOperationPluginOperated, this), 
                this._tickBuffer.gotNextTickTrigger.add(this._onGotNextFrameTick, this), this._tickBuffer.start(), 
                this._updateGamePlaybackRate(), this._handleSceneChange();
            }
            return GameLoop.prototype.start = function() {
                this.running = !0, this._clock.start();
            }, GameLoop.prototype.stop = function() {
                this._clock.stop(), this.running = !1;
            }, GameLoop.prototype.setNextAge = function(age) {
                this._tickController.setNextAge(age);
            }, GameLoop.prototype.getExecutionMode = function() {
                return this._executionMode;
            }, GameLoop.prototype.setExecutionMode = function(execMode) {
                this._executionMode = execMode, this._tickController.setExecutionMode(execMode);
            }, GameLoop.prototype.getLoopConfiguration = function() {
                return {
                    loopMode: this._loopMode,
                    delayIgnoreThreshold: this._delayIgnoreThreshold,
                    skipTicksAtOnce: this._skipTicksAtOnce,
                    skipThreshold: this._skipThreshold,
                    jumpTryThreshold: this._jumpTryThreshold,
                    jumpIgnoreThreshold: this._jumpIgnoreThreshold,
                    playbackRate: this._playbackRate,
                    loopRenderMode: this._loopRenderMode,
                    targetTimeFunc: this._targetTimeFunc,
                    targetTimeOffset: this._targetTimeOffset,
                    originDate: this._originDate,
                    targetAge: this._targetAge
                };
            }, GameLoop.prototype.setLoopConfiguration = function(conf) {
                null != conf.loopMode && (this._loopMode = conf.loopMode), null != conf.delayIgnoreThreshold && (this._delayIgnoreThreshold = conf.delayIgnoreThreshold), 
                null != conf.skipTicksAtOnce && (this._skipTicksAtOnce = conf.skipTicksAtOnce), 
                null != conf.skipThreshold && (this._skipThreshold = conf.skipThreshold), null != conf.jumpTryThreshold && (this._jumpTryThreshold = conf.jumpTryThreshold), 
                null != conf.jumpIgnoreThreshold && (this._jumpIgnoreThreshold = conf.jumpIgnoreThreshold), 
                null != conf.playbackRate && (this._playbackRate = conf.playbackRate, this._clock.changeScaleFactor(this._playbackRate), 
                this._updateGamePlaybackRate()), null != conf.loopRenderMode && this._setLoopRenderMode(conf.loopRenderMode), 
                null != conf.targetTimeFunc && (this._targetTimeFunc = conf.targetTimeFunc), null != conf.targetTimeOffset && (this._targetTimeOffset = conf.targetTimeOffset), 
                null != conf.originDate && (this._originDate = conf.originDate), this._realTargetTimeOffset = null != this._originDate ? this._originDate - this._startedAt : this._targetTimeOffset || 0, 
                null != conf.targetAge && (this._targetAge !== conf.targetAge && (this._waitingNextTick = !1), 
                this._targetAge = conf.targetAge);
            }, GameLoop.prototype.addTickList = function(tickList) {
                this._tickBuffer.addTickList(tickList);
            }, GameLoop.prototype.getCurrentTime = function() {
                return this._currentTime;
            }, GameLoop.prototype._startSkipping = function() {
                this._skipping = !0, this._updateGamePlaybackRate(), this._game.skippingChangedTrigger.fire(!0);
            }, GameLoop.prototype._stopSkipping = function() {
                this._skipping = !1, this._updateGamePlaybackRate(), this._game.skippingChangedTrigger.fire(!1);
            }, GameLoop.prototype._updateGamePlaybackRate = function() {
                var realPlaybackRate = this._skipping ? this._playbackRate * this._skipTicksAtOnce : this._playbackRate;
                this._game._setAudioPlaybackRate(realPlaybackRate);
            }, GameLoop.prototype._handleSceneChange = function() {
                var scene = this._game.scene(), localMode = scene ? scene.local : g.LocalTickMode.FullLocal, tickMode = scene ? scene.tickGenerationMode : g.TickGenerationMode.ByClock;
                if (this._sceneLocalMode !== localMode || this._sceneTickMode !== tickMode) switch (this._sceneLocalMode = localMode, 
                this._sceneTickMode = tickMode, localMode) {
                  case g.LocalTickMode.FullLocal:
                    this._tickController.stopTick(), this._clock.frameTrigger.remove(this._onFrame, this), 
                    this._clock.frameTrigger.add(this._onLocalFrame, this);
                    break;

                  case g.LocalTickMode.NonLocal:
                  case g.LocalTickMode.InterpolateLocal:
                    tickMode === g.TickGenerationMode.ByClock ? this._tickController.startTick() : this._tickController.startTickOnce(), 
                    this._clock.frameTrigger.remove(this._onLocalFrame, this), this._clock.frameTrigger.add(this._onFrame, this);
                    break;

                  default:
                    return void this.errorTrigger.fire(new Error("Unknown LocalTickMode: " + localMode));
                }
            }, GameLoop.prototype._onLocalFrame = function() {
                this._doLocalTick();
            }, GameLoop.prototype._doLocalTick = function() {
                var game = this._game, pevs = this._eventBuffer.readLocalEvents();
                if (this._currentTime += this._frameTime, pevs) for (var i = 0, len = pevs.length; len > i; ++i) game.events.push(this._eventConverter.toGameEvent(pevs[i]));
                var sceneChanged = game.tick(!1);
                sceneChanged && this._handleSceneChange();
            }, GameLoop.prototype._onFrame = function(frameArg) {
                this._loopMode === LoopMode_1["default"].Replay && this._targetTimeFunc ? this._onFrameForTimedReplay(frameArg) : this._onFrameNormal(frameArg);
            }, GameLoop.prototype._onFrameForTimedReplay = function(frameArg) {
                var sceneChanged = !1, game = this._game, targetTime = this._targetTimeFunc() + this._realTargetTimeOffset, timeGap = targetTime - this._currentTime, frameGap = timeGap / this._frameTime;
                if ((frameGap > this._jumpTryThreshold || 0 > frameGap) && !this._waitingStartPoint && this._lastRequestedStartPointTime < this._currentTime && (this._waitingStartPoint = !0, 
                this._lastRequestedStartPointTime = targetTime, this._amflow.getStartPoint({
                    timestamp: targetTime
                }, this._onGotStartPoint_bound)), this._skipping ? 1 >= frameGap && this._stopSkipping() : frameGap > this._skipThreshold && this._startSkipping(), 
                !(0 >= frameGap)) for (var i = 0; i < this._skipTicksAtOnce; ++i) {
                    if (!this._tickBuffer.hasNextTick()) {
                        this._waitingNextTick || (this._tickBuffer.requestTicks(), this._startWaitingNextTick());
                        break;
                    }
                    var nextFrameTime = this._currentTime + this._frameTime, nextTickTime = this._tickBuffer.readNextTickTime();
                    if (null == nextTickTime && (nextTickTime = nextFrameTime), nextFrameTime > targetTime) {
                        if (!(targetTime >= nextTickTime)) break;
                        nextFrameTime = targetTime;
                    } else if (nextTickTime > nextFrameTime) {
                        this._sceneLocalMode === g.LocalTickMode.InterpolateLocal && this._doLocalTick();
                        continue;
                    }
                    this._currentTime = nextFrameTime;
                    var tick = this._tickBuffer.consume(), consumedAge = -1, pevs = this._eventBuffer.readLocalEvents();
                    if (pevs) for (var j = 0, len = pevs.length; len > j; ++j) game.events.push(this._eventConverter.toGameEvent(pevs[j]));
                    if ("number" == typeof tick) consumedAge = tick, sceneChanged = game.tick(!0); else {
                        consumedAge = tick[0];
                        var pevs_1 = tick[1];
                        if (pevs_1) for (var j = 0, len = pevs_1.length; len > j; ++j) game.events.push(this._eventConverter.toGameEvent(pevs_1[j]));
                        sceneChanged = game.tick(!0);
                    }
                    if (game._notifyPassedAgeTable[consumedAge] && game.fireAgePassedIfNeeded()) {
                        frameArg.interrupt = !0;
                        break;
                    }
                    if (sceneChanged) {
                        this._handleSceneChange();
                        break;
                    }
                }
            }, GameLoop.prototype._onFrameNormal = function(frameArg) {
                var sceneChanged = !1, game = this._game;
                if (this._waitingNextTick) return void (this._sceneLocalMode === g.LocalTickMode.InterpolateLocal && this._doLocalTick());
                var targetAge, ageGap;
                if (this._loopMode === LoopMode_1["default"].Realtime ? (targetAge = this._tickBuffer.knownLatestAge + 1, 
                ageGap = targetAge - this._tickBuffer.currentAge) : null === this._targetAge ? (targetAge = null, 
                ageGap = 1) : this._targetAge === this._tickBuffer.currentAge ? (targetAge = this._targetAge = null, 
                ageGap = 1) : (targetAge = this._targetAge, ageGap = targetAge - this._tickBuffer.currentAge), 
                (ageGap > this._jumpTryThreshold || 0 > ageGap) && !this._waitingStartPoint && this._lastRequestedStartPointAge < this._tickBuffer.currentAge && (this._waitingStartPoint = !0, 
                this._lastRequestedStartPointAge = targetAge, this._amflow.getStartPoint({
                    frame: targetAge
                }, this._onGotStartPoint_bound)), this._skipping) {
                    var skipStopGap = this._loopMode === LoopMode_1["default"].Realtime ? 0 : 1;
                    skipStopGap >= ageGap && this._stopSkipping();
                } else ageGap > this._skipThreshold && this._startSkipping();
                if (0 >= ageGap) return 0 === ageGap && (this._sceneTickMode !== g.TickGenerationMode.Manual && this._loopMode !== LoopMode_1["default"].Replay || 0 !== this._tickBuffer.currentAge || this._tickBuffer.requestTicks(), 
                this._startWaitingNextTick()), void (this._sceneLocalMode === g.LocalTickMode.InterpolateLocal && this._doLocalTick());
                for (var loopCount = !this._skipping && ageGap <= this._delayIgnoreThreshold ? 1 : Math.min(ageGap, this._skipTicksAtOnce), i = 0; loopCount > i; ++i) {
                    var nextFrameTime = this._currentTime + this._frameTime, nextTickTime = this._tickBuffer.readNextTickTime();
                    if (null != nextTickTime && nextTickTime > nextFrameTime) {
                        if (this._loopMode !== LoopMode_1["default"].Realtime) {
                            if (this._sceneLocalMode === g.LocalTickMode.InterpolateLocal) {
                                this._doLocalTick();
                                continue;
                            }
                            break;
                        }
                        nextFrameTime = Math.ceil(nextTickTime / this._frameTime) * this._frameTime;
                    }
                    this._currentTime = nextFrameTime;
                    var tick = this._tickBuffer.consume(), consumedAge = -1;
                    if (null == tick) {
                        this._tickBuffer.requestTicks(), this._startWaitingNextTick();
                        break;
                    }
                    var pevs = this._eventBuffer.readLocalEvents();
                    if (pevs) for (var i_1 = 0, len = pevs.length; len > i_1; ++i_1) game.events.push(this._eventConverter.toGameEvent(pevs[i_1]));
                    if ("number" == typeof tick) consumedAge = tick, sceneChanged = game.tick(!0); else {
                        consumedAge = tick[0];
                        var pevs_2 = tick[1];
                        if (pevs_2) for (var j = 0, len = pevs_2.length; len > j; ++j) game.events.push(this._eventConverter.toGameEvent(pevs_2[j]));
                        sceneChanged = game.tick(!0);
                    }
                    if (game._notifyPassedAgeTable[consumedAge] && game.fireAgePassedIfNeeded()) {
                        frameArg.interrupt = !0;
                        break;
                    }
                    if (sceneChanged) {
                        this._handleSceneChange();
                        break;
                    }
                }
            }, GameLoop.prototype._onGotNextFrameTick = function() {
                this._waitingNextTick && this._loopMode !== LoopMode_1["default"].FrameByFrame && this._stopWaitingNextTick();
            }, GameLoop.prototype._onGotStartPoint = function(err, startPoint) {
                if (this._waitingStartPoint = !1, err) return void this.errorTrigger.fire(err);
                if (this._targetTimeFunc && this._loopMode !== LoopMode_1["default"].Realtime) {
                    var targetTime = this._targetTimeFunc() + this._realTargetTimeOffset;
                    if (targetTime < startPoint.timestamp) return;
                    var currentTime = this._currentTime;
                    if (targetTime >= currentTime && startPoint.timestamp < currentTime + this._jumpIgnoreThreshold * this._frameTime) return;
                } else {
                    var targetAge = this._loopMode === LoopMode_1["default"].Realtime ? this._tickBuffer.knownLatestAge + 1 : this._targetAge;
                    if (null === targetAge || targetAge < startPoint.frame) return;
                    var currentAge = this._tickBuffer.currentAge;
                    if (targetAge >= currentAge && startPoint.frame < currentAge + this._jumpIgnoreThreshold) return;
                }
                this._clock.frameTrigger.remove(this._eventBuffer.processEvents, this._eventBuffer), 
                this._tickBuffer.setCurrentAge(startPoint.frame), this._currentTime = startPoint.timestamp || startPoint.data.timestamp || 0, 
                this._waitingNextTick = !1, this._lastRequestedStartPointAge = -1, this._lastRequestedStartPointTime = -1, 
                this._game._restartWithSnapshot(startPoint), this._handleSceneChange(), this.start();
            }, GameLoop.prototype._onGameStarted = function() {
                this._clock.frameTrigger.add({
                    index: 0,
                    owner: this._eventBuffer,
                    func: this._eventBuffer.processEvents
                });
            }, GameLoop.prototype._setLoopRenderMode = function(mode) {
                if (mode !== this._loopRenderMode) switch (this._loopRenderMode = mode, mode) {
                  case LoopRenderMode_1["default"].AfterRawFrame:
                    this._clock.rawFrameTrigger.add(this._renderOnRawFrame, this);
                    break;

                  case LoopRenderMode_1["default"].None:
                    this._clock.rawFrameTrigger.remove(this._renderOnRawFrame, this);
                    break;

                  default:
                    this.errorTrigger.fire(new Error("GameLoop#_setLoopRenderMode: unknown mode: " + mode));
                }
            }, GameLoop.prototype._renderOnRawFrame = function() {
                var game = this._game;
                game.modified && game.scenes.length > 0 && game.render();
            }, GameLoop.prototype._onGameRaiseEvent = function(e) {
                var pev = this._eventConverter.toPlaylogEvent(e);
                this._eventBuffer.onEvent(pev);
            }, GameLoop.prototype._onGameRaiseTick = function(es) {
                if (this._executionMode === ExecutionMode_1["default"].Active) {
                    if (es) for (var i = 0; i < es.length; ++i) this._eventBuffer.addEventDirect(this._eventConverter.toPlaylogEvent(es[i]));
                    this._tickController.forceGenerateTick();
                }
            }, GameLoop.prototype._onGameOperationPluginOperated = function(op) {
                var pev = this._eventConverter.makePlaylogOperationEvent(op);
                this._eventBuffer.onEvent(pev);
            }, GameLoop.prototype._onPollingTick = function() {
                var time = +new Date();
                time - this._lastPollingTickTime > this._pollingTickThreshold && (this._lastPollingTickTime = time, 
                this._tickBuffer.requestTicks());
            }, GameLoop.prototype._startWaitingNextTick = function() {
                this._waitingNextTick = !0, this._clock.rawFrameTrigger.add(this._onPollingTick, this), 
                this._lastPollingTickTime = +new Date();
            }, GameLoop.prototype._stopWaitingNextTick = function() {
                this._waitingNextTick = !1, this._clock.rawFrameTrigger.remove(this._onPollingTick, this);
            }, GameLoop.DEFAULT_DELAY_IGNORE_THRESHOLD = 6, GameLoop.DEFAULT_SKIP_TICKS_AT_ONCE = 100, 
            GameLoop.DEFAULT_SKIP_THRESHOLD = 3e4, GameLoop.DEFAULT_JUMP_TRY_THRESHOLD = 9e4, 
            GameLoop.DEFAULT_JUMP_IGNORE_THRESHOLD = 15e3, GameLoop.DEFAULT_POLLING_TICK_THRESHOLD = 1e4, 
            GameLoop.DEFAULT_DELAY_IGNORE_THERSHOLD = GameLoop.DEFAULT_DELAY_IGNORE_THRESHOLD, 
            GameLoop;
        }();
        exports.GameLoop = GameLoop;
    }, {
        "./Clock": 1,
        "./EventConverter": 3,
        "./ExecutionMode": 5,
        "./LoopMode": 10,
        "./LoopRenderMode": 11,
        "./ProfilerClock": 14,
        "./TickController": 17,
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    9: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), JoinLeaveRequest = function() {
            function JoinLeaveRequest(pev, joinResolver, amflow, keys) {
                this.joinResolver = joinResolver, this.pev = pev, 0 === pev[0] && keys ? (this.resolved = !1, 
                amflow.getStorageData(keys, this._onGotStorageData.bind(this))) : this.resolved = !0;
            }
            return JoinLeaveRequest.prototype._onGotStorageData = function(err, sds) {
                return this.resolved = !0, err ? void this.joinResolver.errorTrigger.fire(err) : void (this.pev[4] = sds);
            }, JoinLeaveRequest;
        }();
        exports.JoinLeaveRequest = JoinLeaveRequest;
        var JoinResolver = function() {
            function JoinResolver(param) {
                this.errorTrigger = new g.Trigger(), param.errorHandler && this.errorTrigger.add(param.errorHandler, param.errorHandlerOwner), 
                this._amflow = param.amflow, this._keysForJoin = null, this._requested = [];
            }
            return JoinResolver.prototype.request = function(pev) {
                this._requested.push(new JoinLeaveRequest(pev, this, this._amflow, this._keysForJoin));
            }, JoinResolver.prototype.readResolved = function() {
                var len = this._requested.length;
                if (0 === len || !this._requested[0].resolved) return null;
                for (var ret = [], i = 0; len > i; ++i) {
                    var req = this._requested[i];
                    if (!req.resolved) break;
                    ret.push(req.pev);
                }
                return this._requested.splice(0, i), ret;
            }, JoinResolver.prototype.setRequestValuesForJoin = function(keys) {
                this._keysForJoin = keys;
            }, JoinResolver;
        }();
        exports.JoinResolver = JoinResolver;
    }, {
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    10: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var LoopMode;
        !function(LoopMode) {
            LoopMode[LoopMode.Realtime = 0] = "Realtime", LoopMode[LoopMode.Replay = 1] = "Replay", 
            LoopMode[LoopMode.FrameByFrame = 2] = "FrameByFrame";
        }(LoopMode || (LoopMode = {})), exports["default"] = LoopMode;
    }, {} ],
    11: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var LoopRenderMode;
        !function(LoopRenderMode) {
            LoopRenderMode[LoopRenderMode.AfterRawFrame = 0] = "AfterRawFrame", LoopRenderMode[LoopRenderMode.None = 1] = "None";
        }(LoopRenderMode || (LoopRenderMode = {})), exports["default"] = LoopRenderMode;
    }, {} ],
    12: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var PdiUtil, es6_promise_1 = require("es6-promise"), g = require("@akashic/akashic-engine");
        !function(PdiUtil) {
            function makeLoadConfigurationFunc(pf) {
                function loadResolvedConfiguration(url, basePath, callback) {
                    pf.loadGameConfiguration(url, function(err, conf) {
                        if (err) return void callback(err, null);
                        try {
                            conf = PdiUtil._resolveConfigurationBasePath(conf, null != basePath ? basePath : g.PathUtil.resolveDirname(url));
                        } catch (e) {
                            return void callback(e, null);
                        }
                        if (!conf.definitions) return void callback(null, conf);
                        var defs = conf.definitions.map(function(def) {
                            return "string" == typeof def ? promisifiedLoad(def) : promisifiedLoad(def.url, def.basePath);
                        });
                        es6_promise_1.Promise.all(defs).then(function(confs) {
                            return callback(null, confs.reduce(PdiUtil._mergeGameConfiguration));
                        })["catch"](function(e) {
                            return callback(e, null);
                        });
                    });
                }
                function promisifiedLoad(url, basePath) {
                    return new es6_promise_1.Promise(function(resolve, reject) {
                        loadResolvedConfiguration(url, basePath, function(err, conf) {
                            err ? reject(err) : resolve(conf);
                        });
                    });
                }
                return loadResolvedConfiguration;
            }
            function _resolveConfigurationBasePath(configuration, basePath) {
                function resolvePath(base, path) {
                    var ret = g.PathUtil.resolvePath(base, path);
                    if (0 !== ret.indexOf(base)) throw g.ExceptionFactory.createAssertionError("PdiUtil._resolveConfigurationBasePath: invalid path: " + path);
                    return ret;
                }
                var assets = configuration.assets;
                if (assets instanceof Object) for (var p in assets) assets.hasOwnProperty(p) && "path" in assets[p] && (assets[p].virtualPath = assets[p].virtualPath || assets[p].path, 
                assets[p].path = resolvePath(basePath, assets[p].path));
                return configuration.globalScripts && (configuration.globalScripts.forEach(function(path) {
                    if (assets.hasOwnProperty(path)) throw g.ExceptionFactory.createAssertionError("PdiUtil._resolveConfigurationBasePath: asset ID already exists: " + path);
                    assets[path] = {
                        type: /\.json$/i.test(path) ? "text" : "script",
                        virtualPath: path,
                        path: resolvePath(basePath, path),
                        global: !0
                    };
                }), delete configuration.globalScripts), configuration;
            }
            function _mergeObject(target, source) {
                for (var ks = Object.keys(source), i = 0, len = ks.length; len > i; ++i) {
                    var k = ks[i], sourceVal = source[k], sourceValType = typeof sourceVal, targetValType = typeof target[k];
                    if (sourceValType === targetValType) switch (typeof sourceVal) {
                      case "string":
                      case "number":
                      case "boolean":
                        target[k] = sourceVal;
                        break;

                      case "object":
                        null == sourceVal ? target[k] = sourceVal : Array.isArray(sourceVal) ? target[k] = target[k].concat(sourceVal) : PdiUtil._mergeObject(target[k], sourceVal);
                        break;

                      default:
                        throw new Error("PdiUtil._mergeObject(): unknown type");
                    } else target[k] = sourceVal;
                }
                return target;
            }
            function _mergeGameConfiguration(target, source) {
                return PdiUtil._mergeObject(target, source);
            }
            PdiUtil.makeLoadConfigurationFunc = makeLoadConfigurationFunc, PdiUtil._resolveConfigurationBasePath = _resolveConfigurationBasePath, 
            PdiUtil._mergeObject = _mergeObject, PdiUtil._mergeGameConfiguration = _mergeGameConfiguration;
        }(PdiUtil = exports.PdiUtil || (exports.PdiUtil = {}));
    }, {
        "@akashic/akashic-engine": "@akashic/akashic-engine",
        "es6-promise": 23
    } ],
    13: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var PointEventResolver = function() {
            function PointEventResolver(param) {
                this._game = param.game, this._pointEventMap = {};
            }
            return PointEventResolver.prototype.pointDown = function(e) {
                var player = this._game.player, source = this._game.findPointSource(e.offset), point = source.point ? source.point : e.offset, targetId = source.target ? source.target.id : null;
                this._pointEventMap[e.identifier] = {
                    targetId: targetId,
                    local: source.local,
                    point: point,
                    start: {
                        x: e.offset.x,
                        y: e.offset.y
                    },
                    prev: {
                        x: e.offset.x,
                        y: e.offset.y
                    }
                };
                var ret = [ 33, 2, player.id, e.identifier, point.x, point.y, targetId ];
                return source.local && ret.push(source.local), ret;
            }, PointEventResolver.prototype.pointMove = function(e) {
                var player = this._game.player, holder = this._pointEventMap[e.identifier];
                if (!holder) return null;
                var prev = {
                    x: 0,
                    y: 0
                }, start = {
                    x: 0,
                    y: 0
                };
                this._pointMoveAndUp(holder, e.offset, prev, start);
                var ret = [ 34, 2, player.id, e.identifier, holder.point.x, holder.point.y, start.x, start.y, prev.x, prev.y, holder.targetId ];
                return holder.local && ret.push(holder.local), ret;
            }, PointEventResolver.prototype.pointUp = function(e) {
                var player = this._game.player, holder = this._pointEventMap[e.identifier];
                if (!holder) return null;
                var prev = {
                    x: 0,
                    y: 0
                }, start = {
                    x: 0,
                    y: 0
                };
                this._pointMoveAndUp(holder, e.offset, prev, start), delete this._pointEventMap[e.identifier];
                var ret = [ 35, 2, player.id, e.identifier, holder.point.x, holder.point.y, start.x, start.y, prev.x, prev.y, holder.targetId ];
                return holder.local && ret.push(holder.local), ret;
            }, PointEventResolver.prototype._pointMoveAndUp = function(holder, offset, prevDelta, startDelta) {
                startDelta.x = offset.x - holder.start.x, startDelta.y = offset.y - holder.start.y, 
                prevDelta.x = offset.x - holder.prev.x, prevDelta.y = offset.y - holder.prev.y, 
                holder.prev.x = offset.x, holder.prev.y = offset.y;
            }, PointEventResolver;
        }();
        exports.PointEventResolver = PointEventResolver;
    }, {} ],
    14: [ function(require, module, exports) {
        "use strict";
        var __extends = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            };
            return function(d, b) {
                function __() {
                    this.constructor = d;
                }
                extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
                new __());
            };
        }();
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var Clock_1 = require("./Clock"), ProfilerClock = function(_super) {
            function ProfilerClock(param) {
                var _this = _super.call(this, param) || this;
                return _this._profiler = param.profiler, _this;
            }
            return __extends(ProfilerClock, _super), ProfilerClock.prototype._onLooperCall = function(deltaTime) {
                if (0 >= deltaTime) return this._waitTime - this._totalDeltaTime;
                deltaTime > this._deltaTimeBrokenThreshold && (deltaTime = this._waitTime);
                var totalDeltaTime = this._totalDeltaTime;
                if (totalDeltaTime += deltaTime, totalDeltaTime <= this._skipFrameWaitTime) return this._totalDeltaTime = totalDeltaTime, 
                this._waitTime - totalDeltaTime;
                this._profiler.timeEnd(1), this._profiler.time(1);
                var frameCount = totalDeltaTime < this._waitTimeDoubled ? 1 : totalDeltaTime > this._waitTimeMax ? this._realMaxFramePerOnce : totalDeltaTime / this._waitTime | 0, fc = frameCount, arg = {
                    interrupt: !1
                };
                for (this._profiler.setValue(0, fc - 1); fc > 0 && this.running && !arg.interrupt; ) --fc, 
                this._profiler.time(2), this.frameTrigger.fire(arg), this._profiler.timeEnd(2);
                return totalDeltaTime -= (frameCount - fc) * this._waitTime, this._profiler.time(3), 
                this.rawFrameTrigger.fire(), this._profiler.timeEnd(3), this._totalDeltaTime = totalDeltaTime, 
                this._profiler.flush(), this._waitTime - totalDeltaTime;
            }, ProfilerClock;
        }(Clock_1.Clock);
        exports.ProfilerClock = ProfilerClock;
    }, {
        "./Clock": 1
    } ],
    15: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), ExecutionMode_1 = require("./ExecutionMode"), StorageResolver = function() {
            function StorageResolver(param) {
                this.errorTrigger = new g.Trigger(), param.errorHandler && this.errorTrigger.add(param.errorHandler, param.errorHandlerOwner), 
                this.getStorageFunc = this._getStorage.bind(this), this.putStorageFunc = this._putStorage.bind(this), 
                this.requestValuesForJoinFunc = this._requestValuesForJoin.bind(this), this._game = param.game, 
                this._amflow = param.amflow, this._tickGenerator = param.tickGenerator, this._tickBuffer = param.tickBuffer, 
                this._executionMode = null, this.setExecutionMode(param.executionMode), this._unresolvedLoaders = {}, 
                this._unresolvedStorages = {}, this._onStoragePut_bound = this._onStoragePut.bind(this);
            }
            return StorageResolver.prototype.setExecutionMode = function(executionMode) {
                if (this._executionMode !== executionMode) {
                    this._executionMode = executionMode;
                    var tickBuf = this._tickBuffer, tickGen = this._tickGenerator;
                    executionMode === ExecutionMode_1["default"].Active ? (tickBuf.gotStorageTrigger.remove(this._onGotStorageOnTick, this), 
                    tickGen.gotStorageTrigger.add(this._onGotStorageOnTick, this)) : (tickGen.gotStorageTrigger.remove(this._onGotStorageOnTick, this), 
                    tickBuf.gotStorageTrigger.add(this._onGotStorageOnTick, this));
                }
            }, StorageResolver.prototype._onGotStorageOnTick = function(storageOnTick) {
                var resolvingAge = storageOnTick.age, storageData = storageOnTick.storageData, loader = this._unresolvedLoaders[resolvingAge];
                if (!loader) return void (this._unresolvedStorages[resolvingAge] = storageData);
                delete this._unresolvedLoaders[resolvingAge];
                var serialization = resolvingAge, values = storageData.map(function(d) {
                    return d.values;
                });
                loader._onLoaded(values, serialization);
            }, StorageResolver.prototype._getStorage = function(keys, loader, ser) {
                var resolvingAge;
                null != ser ? (resolvingAge = ser, this._tickBuffer.requestTicks(resolvingAge, 1)) : this._executionMode === ExecutionMode_1["default"].Active ? resolvingAge = this._tickGenerator.requestStorageTick(keys) : (resolvingAge = this._game.age, 
                this._tickBuffer.requestTicks(resolvingAge, 1));
                var sd = this._unresolvedStorages[resolvingAge];
                if (!sd) return void (this._unresolvedLoaders[resolvingAge] = loader);
                delete this._unresolvedStorages[resolvingAge];
                var serialization = resolvingAge, values = sd.map(function(d) {
                    return d.values;
                });
                loader._onLoaded(values, serialization);
            }, StorageResolver.prototype._putStorage = function(key, value, option) {
                this._executionMode === ExecutionMode_1["default"].Active && this._amflow.putStorageData(key, value, option, this._onStoragePut_bound);
            }, StorageResolver.prototype._requestValuesForJoin = function(keys) {
                this._tickGenerator.setRequestValuesForJoin(keys);
            }, StorageResolver.prototype._onStoragePut = function(err) {
                err && this.errorTrigger.fire(err);
            }, StorageResolver;
        }();
        exports.StorageResolver = StorageResolver;
    }, {
        "./ExecutionMode": 5,
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    16: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), ExecutionMode_1 = require("./ExecutionMode"), TickBuffer = function() {
            function TickBuffer(param) {
                this.currentAge = 0, this.knownLatestAge = -1, this.gotNextTickTrigger = new g.Trigger(), 
                this.gotStorageTrigger = new g.Trigger(), this._amflow = param.amflow, this._prefetchThreshold = param.prefetchThreshold || TickBuffer.DEFAULT_PREFETCH_THRESHOLD, 
                this._sizeRequestOnce = param.sizeRequestOnce || TickBuffer.DEFAULT_SIZE_REQUEST_ONCE, 
                this._executionMode = param.executionMode, this._receiving = !1, this._tickRanges = [], 
                this._nearestAbsentAge = this.currentAge, this._nextTickTimeCache = null, this._addTick_bound = this.addTick.bind(this), 
                this._onTicks_bound = this._onTicks.bind(this);
            }
            return TickBuffer.prototype.start = function() {
                this._receiving = !0, this._updateAmflowReceiveState();
            }, TickBuffer.prototype.stop = function() {
                this._receiving = !1, this._updateAmflowReceiveState();
            }, TickBuffer.prototype.setExecutionMode = function(execMode) {
                this._executionMode !== execMode && (this._dropUntil(this.knownLatestAge + 1), this._nextTickTimeCache = null, 
                this._nearestAbsentAge = this.currentAge, this._executionMode = execMode, this._updateAmflowReceiveState());
            }, TickBuffer.prototype.setCurrentAge = function(age) {
                this._dropUntil(age), this._nextTickTimeCache = null, this.currentAge = age, this._nearestAbsentAge = this._findNearestAbscentAge(age);
            }, TickBuffer.prototype.hasNextTick = function() {
                return this.currentAge !== this._nearestAbsentAge;
            }, TickBuffer.prototype.consume = function() {
                if (this.currentAge === this._nearestAbsentAge) return null;
                var age = this.currentAge, range = this._tickRanges[0];
                return age === range.start ? (this._nextTickTimeCache = null, ++this.currentAge, 
                ++range.start, age + this._prefetchThreshold === this._nearestAbsentAge && this.requestTicks(this._nearestAbsentAge, this._sizeRequestOnce), 
                range.start === range.end && this._tickRanges.shift(), range.ticks.length > 0 && range.ticks[0][0] === age ? range.ticks.shift() : age) : (this._dropUntil(this.currentAge), 
                this.consume());
            }, TickBuffer.prototype.readNextTickTime = function() {
                if (null != this._nextTickTimeCache) return this._nextTickTimeCache;
                if (this.currentAge === this._nearestAbsentAge) return null;
                var age = this.currentAge, range = this._tickRanges[0];
                if (age === range.start) {
                    if (0 === range.ticks.length) return null;
                    var tick = range.ticks[0];
                    if (tick[0] !== age) return null;
                    var pevs = tick[1];
                    if (!pevs) return null;
                    for (var i = 0; i < pevs.length; ++i) if (2 === pevs[i][0]) return this._nextTickTimeCache = pevs[i][3], 
                    this._nextTickTimeCache;
                    return null;
                }
                return this._dropUntil(this.currentAge), this.readNextTickTime();
            }, TickBuffer.prototype.requestTicks = function(from, len) {
                void 0 === from && (from = this.currentAge), void 0 === len && (len = this._sizeRequestOnce), 
                this._executionMode === ExecutionMode_1["default"].Passive && this._amflow.getTickList(from, from + len, this._onTicks_bound);
            }, TickBuffer.prototype.addTick = function(tick) {
                var age = tick[0], gotNext = this.currentAge === age && this._nearestAbsentAge === age;
                this.knownLatestAge < age && (this.knownLatestAge = age), tick[2] && this.gotStorageTrigger.fire({
                    age: tick[0],
                    storageData: tick[2]
                });
                for (var i = this._tickRanges.length - 1; i >= 0; --i) {
                    var range = this._tickRanges[i];
                    if (age >= range.start) break;
                }
                var nextRange = this._tickRanges[i + 1];
                if (0 > i) this._tickRanges.unshift(this._createTickRangeFromTick(tick)); else {
                    var range = this._tickRanges[i];
                    age === range.end ? (++range.end, tick[1] && range.ticks.push(tick)) : age > range.end && this._tickRanges.splice(i + 1, 0, this._createTickRangeFromTick(tick));
                }
                this._nearestAbsentAge === age && (++this._nearestAbsentAge, nextRange && this._nearestAbsentAge === nextRange.start && (this._nearestAbsentAge = this._findNearestAbscentAge(this._nearestAbsentAge))), 
                gotNext && this.gotNextTickTrigger.fire();
            }, TickBuffer.prototype.addTickList = function(tickList) {
                var start = tickList[0], end = tickList[1] + 1, ticks = tickList[2], origStart = start, origEnd = end;
                this.knownLatestAge < end - 1 && (this.knownLatestAge = end - 1);
                var i = 0, len = this._tickRanges.length;
                for (i = 0; len > i; ++i) {
                    var range_1 = this._tickRanges[i];
                    if (start < range_1.start) break;
                }
                var insertPoint = i;
                if (i > 0) {
                    --i;
                    var leftEndAge = this._tickRanges[i].end;
                    leftEndAge > start && (start = leftEndAge);
                }
                for (;len > i; ++i) {
                    var range_2 = this._tickRanges[i];
                    if (end <= range_2.end) break;
                }
                if (len > i) {
                    var rightStartAge = this._tickRanges[i].start;
                    end > rightStartAge && (end = rightStartAge);
                }
                if (start >= end) return {
                    start: start,
                    end: start,
                    ticks: []
                };
                ticks || (ticks = []), (origStart !== start || origEnd !== end) && (ticks = ticks.filter(function(tick) {
                    var age = tick[0];
                    return age >= start && end > age;
                }));
                for (var j = 0; j < ticks.length; ++j) {
                    var tick = ticks[j];
                    tick[2] && this.gotStorageTrigger.fire({
                        age: tick[0],
                        storageData: tick[2]
                    });
                }
                var range = {
                    start: start,
                    end: end,
                    ticks: ticks
                }, delLen = Math.max(0, i - insertPoint);
                return this._tickRanges.splice(insertPoint, delLen, range), start <= this._nearestAbsentAge && this._nearestAbsentAge < end && (this._nearestAbsentAge = this._findNearestAbscentAge(this._nearestAbsentAge)), 
                range;
            }, TickBuffer.prototype._updateAmflowReceiveState = function() {
                this._receiving && this._executionMode === ExecutionMode_1["default"].Passive ? this._amflow.onTick(this._addTick_bound) : this._amflow.offTick(this._addTick_bound);
            }, TickBuffer.prototype._onTicks = function(err, ticks) {
                if (err) throw new Error();
                if (ticks) {
                    var mayGotNext = this.currentAge === this._nearestAbsentAge, inserted = this.addTickList(ticks);
                    mayGotNext && inserted.start <= this.currentAge && this.currentAge < inserted.end && this.gotNextTickTrigger.fire();
                }
            }, TickBuffer.prototype._findNearestAbscentAge = function(age) {
                for (var i = 0, len = this._tickRanges.length; len > i && !(age <= this._tickRanges[i].end); ++i) ;
                for (;len > i; ++i) {
                    var range = this._tickRanges[i];
                    if (age < range.start) break;
                    age = range.end;
                }
                return age;
            }, TickBuffer.prototype._dropUntil = function(age) {
                var i;
                for (i = 0; i < this._tickRanges.length && !(age < this._tickRanges[i].end); ++i) ;
                if (this._tickRanges = this._tickRanges.slice(i), 0 !== this._tickRanges.length) {
                    var range = this._tickRanges[0];
                    if (!(age < range.start)) {
                        for (range.start = age, i = 0; i < range.ticks.length && !(age <= range.ticks[i][0]); ++i) ;
                        range.ticks = range.ticks.slice(i);
                    }
                }
            }, TickBuffer.prototype._createTickRangeFromTick = function(tick) {
                var age = tick[0], range = {
                    start: age,
                    end: age + 1,
                    ticks: []
                };
                return tick[1] && range.ticks.push(tick), range;
            }, TickBuffer.DEFAULT_PREFETCH_THRESHOLD = 1800, TickBuffer.DEFAULT_SIZE_REQUEST_ONCE = 9e3, 
            TickBuffer;
        }();
        exports.TickBuffer = TickBuffer;
    }, {
        "./ExecutionMode": 5,
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    17: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), ExecutionMode_1 = require("./ExecutionMode"), TickBuffer_1 = require("./TickBuffer"), TickGenerator_1 = require("./TickGenerator"), sr = require("./StorageResolver"), TickController = function() {
            function TickController(param) {
                this.errorTrigger = new g.Trigger(), param.errorHandler && this.errorTrigger.add(param.errorHandler, param.errorHandlerOwner), 
                this._amflow = param.amflow, this._clock = param.clock, this._started = !1, this._executionMode = param.executionMode, 
                this._generator = new TickGenerator_1.TickGenerator({
                    amflow: param.amflow,
                    eventBuffer: param.eventBuffer,
                    errorHandler: this.errorTrigger.fire,
                    errorHandlerOwner: this.errorTrigger
                }), this._buffer = new TickBuffer_1.TickBuffer({
                    amflow: param.amflow,
                    executionMode: param.executionMode
                }), this._storageResolver = new sr.StorageResolver({
                    game: param.game,
                    amflow: param.amflow,
                    tickGenerator: this._generator,
                    tickBuffer: this._buffer,
                    executionMode: param.executionMode,
                    errorHandler: this.errorTrigger.fire,
                    errorHandlerOwner: this.errorTrigger
                }), this._generator.tickTrigger.add(this._onTickGenerated, this), this._clock.frameTrigger.add(this._generator.next, this._generator);
            }
            return TickController.prototype.startTick = function() {
                this._started = !0, this._updateGeneratorState();
            }, TickController.prototype.stopTick = function() {
                this._started = !1, this._updateGeneratorState();
            }, TickController.prototype.startTickOnce = function() {
                this._started = !0, this._generator.tickTrigger.addOnce(this._stopTriggerOnTick, this), 
                this._updateGeneratorState();
            }, TickController.prototype.setNextAge = function(age) {
                this._generator.setNextAge(age);
            }, TickController.prototype.forceGenerateTick = function() {
                this._generator.forceNext();
            }, TickController.prototype.getBuffer = function() {
                return this._buffer;
            }, TickController.prototype.storageFunc = function() {
                return {
                    storageGetFunc: this._storageResolver.getStorageFunc,
                    storagePutFunc: this._storageResolver.putStorageFunc,
                    requestValuesForJoinFunc: this._storageResolver.requestValuesForJoinFunc
                };
            }, TickController.prototype.setExecutionMode = function(execMode) {
                this._executionMode !== execMode && (this._executionMode = execMode, this._updateGeneratorState(), 
                this._buffer.setExecutionMode(execMode), this._storageResolver.setExecutionMode(execMode));
            }, TickController.prototype._stopTriggerOnTick = function() {
                this.stopTick();
            }, TickController.prototype._updateGeneratorState = function() {
                var toGenerate = this._started && this._executionMode === ExecutionMode_1["default"].Active;
                this._generator.startStopGenerate(toGenerate);
            }, TickController.prototype._onTickGenerated = function(tick) {
                this._amflow.sendTick(tick), this._buffer.addTick(tick);
            }, TickController;
        }();
        exports.TickController = TickController;
    }, {
        "./ExecutionMode": 5,
        "./StorageResolver": 15,
        "./TickBuffer": 16,
        "./TickGenerator": 18,
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    18: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), JoinResolver_1 = require("./JoinResolver"), TickGenerator = function() {
            function TickGenerator(param) {
                this.tickTrigger = new g.Trigger(), this.gotStorageTrigger = new g.Trigger(), this.errorTrigger = new g.Trigger(), 
                param.errorHandler && this.errorTrigger.add(param.errorHandler, param.errorHandlerOwner), 
                this._amflow = param.amflow, this._eventBuffer = param.eventBuffer, this._joinResolver = new JoinResolver_1.JoinResolver({
                    amflow: param.amflow,
                    errorHandler: this.errorTrigger.fire,
                    errorHandlerOwner: this.errorTrigger
                }), this._nextAge = 0, this._storageDataForNext = null, this._generatingTick = !1, 
                this._waitingStorage = !1, this._onGotStorageData_bound = this._onGotStorageData.bind(this);
            }
            return TickGenerator.prototype.next = function() {
                if (this._generatingTick && !this._waitingStorage) {
                    var joinLeaves = this._eventBuffer.readJoinLeaves();
                    if (joinLeaves) for (var i = 0; i < joinLeaves.length; ++i) this._joinResolver.request(joinLeaves[i]);
                    var evs = this._eventBuffer.readEvents(), resolvedJoinLeaves = this._joinResolver.readResolved();
                    resolvedJoinLeaves && (evs ? evs.push.apply(evs, resolvedJoinLeaves) : evs = resolvedJoinLeaves);
                    var sds = this._storageDataForNext;
                    this._storageDataForNext = null, this.tickTrigger.fire([ this._nextAge++, evs, sds ]);
                }
            }, TickGenerator.prototype.forceNext = function() {
                if (this._waitingStorage) return void this.errorTrigger.fire(new Error("TickGenerator#forceNext(): cannot generate tick while waiting storage."));
                var origValue = this._generatingTick;
                this._generatingTick = !0, this.next(), this._generatingTick = origValue;
            }, TickGenerator.prototype.startStopGenerate = function(toGenerate) {
                this._generatingTick = toGenerate;
            }, TickGenerator.prototype.startTick = function() {
                this._generatingTick = !0;
            }, TickGenerator.prototype.stopTick = function() {
                this._generatingTick = !1;
            }, TickGenerator.prototype.setNextAge = function(age) {
                return this._waitingStorage ? void this.errorTrigger.fire(new Error("TickGenerator#setNextAge(): cannot change the next age while waiting storage.")) : void (this._nextAge = age);
            }, TickGenerator.prototype.requestStorageTick = function(keys) {
                if (this._waitingStorage) {
                    var err = g.ExceptionFactory.createAssertionError("TickGenerator#requestStorageTick(): Unsupported: multiple storage request");
                    return this.errorTrigger.fire(err), -1;
                }
                return this._waitingStorage = !0, this._amflow.getStorageData(keys, this._onGotStorageData_bound), 
                this._nextAge;
            }, TickGenerator.prototype.setRequestValuesForJoin = function(keys) {
                this._joinResolver.setRequestValuesForJoin(keys);
            }, TickGenerator.prototype._onGotStorageData = function(err, sds) {
                return this._waitingStorage = !1, err ? void this.errorTrigger.fire(err) : (this._storageDataForNext = sds, 
                void this.gotStorageTrigger.fire({
                    age: this._nextAge,
                    storageData: sds
                }));
            }, TickGenerator;
        }();
        exports.TickGenerator = TickGenerator;
    }, {
        "./JoinResolver": 9,
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    19: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var MemoryAmflowClient = function() {
            function MemoryAmflowClient(param) {
                this._playId = param.playId, this._putStorageDataSyncFunc = param.putStorageDataSyncFunc || function() {
                    throw new Error("Implementation not given");
                }, this._getStorageDataSyncFunc = param.getStorageDataSyncFunc || function() {
                    throw new Error("Implementation not given");
                }, this._tickHandlers = [], this._eventHandlers = [], this._events = [], this._tickList = null, 
                param.startPoints ? (this._tickList = param.tickList, this._startPoints = param.startPoints) : this._startPoints = [];
            }
            return MemoryAmflowClient.prototype.dump = function() {
                return {
                    tickList: this._tickList,
                    startPoints: this._startPoints
                };
            }, MemoryAmflowClient.prototype.open = function(playId, callback) {
                var _this = this;
                setTimeout(function() {
                    return playId !== _this._playId ? void callback(new Error("MemoryAmflowClient#open: unknown playId")) : void callback();
                }, 0);
            }, MemoryAmflowClient.prototype.close = function(callback) {
                setTimeout(function() {
                    callback();
                }, 0);
            }, MemoryAmflowClient.prototype.authenticate = function(token, callback) {
                setTimeout(function() {
                    switch (token) {
                      case MemoryAmflowClient.TOKEN_ACTIVE:
                        callback(null, {
                            writeTick: !0,
                            readTick: !0,
                            subscribeTick: !1,
                            sendEvent: !1,
                            subscribeEvent: !0,
                            maxEventPriority: 2
                        });
                        break;

                      case MemoryAmflowClient.TOKEN_PASSIVE:
                        callback(null, {
                            writeTick: !1,
                            readTick: !0,
                            subscribeTick: !0,
                            sendEvent: !0,
                            subscribeEvent: !1,
                            maxEventPriority: 2
                        });
                        break;

                      default:
                        callback(null, {
                            writeTick: !0,
                            readTick: !0,
                            subscribeTick: !0,
                            sendEvent: !0,
                            subscribeEvent: !0,
                            maxEventPriority: 2
                        });
                    }
                }, 0);
            }, MemoryAmflowClient.prototype.sendTick = function(tick) {
                if (this._tickList) {
                    if (this._tickList[0] <= tick[0] && tick[0] <= this._tickList[1]) throw new Error("illegal age tick");
                    this._tickList[1] = tick[0];
                } else this._tickList = [ tick[0], tick[0], [] ];
                (tick[1] || tick[2]) && this._tickList[2].push(tick), this._tickHandlers.forEach(function(h) {
                    return h(tick);
                });
            }, MemoryAmflowClient.prototype.onTick = function(handler) {
                this._tickHandlers.push(handler);
            }, MemoryAmflowClient.prototype.offTick = function(handler) {
                this._tickHandlers = this._tickHandlers.filter(function(h) {
                    return h !== handler;
                });
            }, MemoryAmflowClient.prototype.sendEvent = function(pev) {
                return 0 === this._eventHandlers.length ? void this._events.push(pev) : void this._eventHandlers.forEach(function(h) {
                    return h(pev);
                });
            }, MemoryAmflowClient.prototype.onEvent = function(handler) {
                var _this = this;
                this._eventHandlers.push(handler), this._events.length > 0 && (this._events.forEach(function(pev) {
                    _this._eventHandlers.forEach(function(h) {
                        return h(pev);
                    });
                }), this._events = []);
            }, MemoryAmflowClient.prototype.offEvent = function(handler) {
                this._eventHandlers = this._eventHandlers.filter(function(h) {
                    return h !== handler;
                });
            }, MemoryAmflowClient.prototype.getTickList = function(from, to, callback) {
                if (!this._tickList) return void setTimeout(function() {
                    return callback(null, null);
                }, 0);
                from = Math.max(from, this._tickList[0]), to = Math.min(to, this._tickList[1]);
                var ticks = this._tickList[2].filter(function(tick) {
                    var age = tick[0];
                    return age >= from && to >= age;
                }), tickList = [ from, to, ticks ];
                setTimeout(function() {
                    return callback(null, tickList);
                }, 0);
            }, MemoryAmflowClient.prototype.putStartPoint = function(startPoint, callback) {
                var _this = this;
                setTimeout(function() {
                    _this._startPoints.push(startPoint), callback(null);
                }, 0);
            }, MemoryAmflowClient.prototype.getStartPoint = function(opts, callback) {
                var _this = this;
                setTimeout(function() {
                    if (!_this._startPoints || 0 === _this._startPoints.length) return void callback(new Error("no startpoint"));
                    var index = 0;
                    if (null != opts.frame) for (var nearestFrame = _this._startPoints[0].frame, i = 1; i < _this._startPoints.length; ++i) {
                        var frame = _this._startPoints[i].frame;
                        frame <= opts.frame && frame > nearestFrame && (nearestFrame = frame, index = i);
                    } else for (var nearestTimestamp = _this._startPoints[0].timestamp, i = 1; i < _this._startPoints.length; ++i) {
                        var timestamp = _this._startPoints[i].timestamp;
                        timestamp <= opts.timestamp && timestamp > nearestTimestamp && (nearestTimestamp = timestamp, 
                        index = i);
                    }
                    callback(null, _this._startPoints[index]);
                }, 0);
            }, MemoryAmflowClient.prototype.putStorageData = function(key, value, options, callback) {
                var _this = this;
                setTimeout(function() {
                    try {
                        _this._putStorageDataSyncFunc(key, value, options), callback(null);
                    } catch (e) {
                        callback(e);
                    }
                }, 0);
            }, MemoryAmflowClient.prototype.getStorageData = function(keys, callback) {
                var _this = this;
                setTimeout(function() {
                    try {
                        var data = _this._getStorageDataSyncFunc(keys);
                        callback(null, data);
                    } catch (e) {
                        callback(e);
                    }
                }, 0);
            }, MemoryAmflowClient.prototype.dropAfter = function(age) {
                if (this._tickList) {
                    var from = this._tickList[0], to = this._tickList[1];
                    from >= age ? (this._tickList = null, this._startPoints = []) : to >= age && (this._tickList[1] = age - 1, 
                    this._tickList[2] = this._tickList[2].filter(function(tick) {
                        var ta = tick[0];
                        return ta >= from && age - 1 >= ta;
                    }), this._startPoints = this._startPoints.filter(function(sp) {
                        return sp.frame < age;
                    }));
                }
            }, MemoryAmflowClient.TOKEN_ACTIVE = "mamfc-token:active", MemoryAmflowClient.TOKEN_PASSIVE = "mamfc-token:passive", 
            MemoryAmflowClient;
        }();
        exports.MemoryAmflowClient = MemoryAmflowClient;
    }, {} ],
    20: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var ReplayAmflowProxy = function() {
            function ReplayAmflowProxy(param) {
                this._amflow = param.amflow, this._tickList = param.tickList, this._startPoints = param.startPoints;
            }
            return ReplayAmflowProxy.prototype.dropAfter = function(age) {
                if (this._tickList) {
                    var givenFrom = this._tickList[0], givenTo = this._tickList[1], givenTicksWithEvents = this._tickList[2];
                    givenFrom >= age ? (this._tickList = null, this._startPoints = []) : givenTo >= age && (this._tickList[1] = age - 1, 
                    this._tickList[2] = this._sliceTicks(givenTicksWithEvents, givenTo, age - 1), this._startPoints = this._startPoints.filter(function(sp) {
                        return sp.frame < age;
                    }));
                }
            }, ReplayAmflowProxy.prototype.open = function(playId, callback) {
                this._amflow.open(playId, callback);
            }, ReplayAmflowProxy.prototype.close = function(callback) {
                this._amflow.close(callback);
            }, ReplayAmflowProxy.prototype.authenticate = function(token, callback) {
                this._amflow.authenticate(token, callback);
            }, ReplayAmflowProxy.prototype.sendTick = function(tick) {
                this._amflow.sendTick(tick);
            }, ReplayAmflowProxy.prototype.onTick = function(handler) {
                this._amflow.onTick(handler);
            }, ReplayAmflowProxy.prototype.offTick = function(handler) {
                this._amflow.offTick(handler);
            }, ReplayAmflowProxy.prototype.sendEvent = function(event) {
                this._amflow.sendEvent(event);
            }, ReplayAmflowProxy.prototype.onEvent = function(handler) {
                this._amflow.onEvent(handler);
            }, ReplayAmflowProxy.prototype.offEvent = function(handler) {
                this._amflow.offEvent(handler);
            }, ReplayAmflowProxy.prototype.getTickList = function(from, to, callback) {
                var _this = this;
                if (!this._tickList) return void this._amflow.getTickList(from, to, callback);
                var givenFrom = this._tickList[0], givenTo = this._tickList[1], givenTicksWithEvents = this._tickList[2], fromInGiven = from >= givenFrom && givenTo >= from, toInGiven = to >= givenFrom && givenTo >= to;
                fromInGiven && toInGiven ? setTimeout(function() {
                    callback(null, [ from, to, _this._sliceTicks(givenTicksWithEvents, from, to) ]);
                }, 0) : this._amflow.getTickList(from, to, function(err, tickList) {
                    if (err) return void callback(err);
                    if (tickList) if (fromInGiven || toInGiven) if (fromInGiven) {
                        var ticksWithEvents = _this._sliceTicks(givenTicksWithEvents, from, to).concat(tickList[2] || []);
                        callback(null, [ from, tickList[1], ticksWithEvents ]);
                    } else {
                        var ticksWithEvents = (tickList[2] || []).concat(_this._sliceTicks(givenTicksWithEvents, from, to));
                        callback(null, [ tickList[0], to, ticksWithEvents ]);
                    } else if (givenFrom > to || from > givenTo) callback(null, tickList); else {
                        var ticksWithEvents = tickList[2];
                        if (ticksWithEvents) {
                            var beforeGiven = _this._sliceTicks(ticksWithEvents, from, givenFrom - 1), afterGiven = _this._sliceTicks(ticksWithEvents, givenTo + 1, to);
                            ticksWithEvents = beforeGiven.concat(givenTicksWithEvents, afterGiven);
                        } else ticksWithEvents = givenTicksWithEvents;
                        callback(null, [ from, to, ticksWithEvents ]);
                    } else fromInGiven || toInGiven ? fromInGiven ? callback(null, [ from, givenTo, _this._sliceTicks(givenTicksWithEvents, from, to) ]) : callback(null, [ givenFrom, to, _this._sliceTicks(givenTicksWithEvents, from, to) ]) : givenFrom > to || from > givenTo ? callback(null, tickList) : callback(null, [ givenFrom, givenTo, _this._sliceTicks(givenTicksWithEvents, from, to) ]);
                });
            }, ReplayAmflowProxy.prototype.putStartPoint = function(startPoint, callback) {
                this._amflow.putStartPoint(startPoint, callback);
            }, ReplayAmflowProxy.prototype.getStartPoint = function(opts, callback) {
                var _this = this, index = 0;
                if (this._startPoints.length > 0) if (null != opts.frame) for (var nearestFrame = this._startPoints[0].frame, i = 1; i < this._startPoints.length; ++i) {
                    var frame = this._startPoints[i].frame;
                    frame <= opts.frame && frame > nearestFrame && (nearestFrame = frame, index = i);
                } else for (var nearestTimestamp = this._startPoints[0].timestamp, i = 1; i < this._startPoints.length; ++i) {
                    var timestamp = this._startPoints[i].timestamp;
                    timestamp <= opts.timestamp && timestamp > nearestTimestamp && (nearestTimestamp = timestamp, 
                    index = i);
                }
                var givenTo = this._tickList ? this._tickList[1] : -1;
                opts.frame > givenTo ? this._amflow.getStartPoint(opts, function(err, startPoint) {
                    return err ? void callback(err) : void (givenTo < startPoint.frame ? callback(null, startPoint) : callback(null, _this._startPoints[index]));
                }) : setTimeout(function() {
                    callback(null, _this._startPoints[index]);
                }, 0);
            }, ReplayAmflowProxy.prototype.putStorageData = function(key, value, options, callback) {
                this._amflow.putStorageData(key, value, options, callback);
            }, ReplayAmflowProxy.prototype.getStorageData = function(keys, callback) {
                this._amflow.getStorageData(keys, callback);
            }, ReplayAmflowProxy.prototype._sliceTicks = function(ticks, from, to) {
                return ticks.filter(function(t) {
                    var age = t[0];
                    return age >= from && to >= age;
                });
            }, ReplayAmflowProxy;
        }();
        exports.ReplayAmflowProxy = ReplayAmflowProxy;
    }, {} ],
    21: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), SimpleProfiler = function() {
            function SimpleProfiler(param) {
                this._interval = null != param.interval ? param.interval : SimpleProfiler.DEFAULT_INTERVAL, 
                null != param.limit ? this._limit = param.limit >= SimpleProfiler.DEFAULT_LIMIT ? param.limit : SimpleProfiler.DEFAULT_LIMIT : this._limit = SimpleProfiler.DEFAULT_LIMIT, 
                this._calculateProfilerValueTrigger = new g.Trigger(), param.getValueHandler && this._calculateProfilerValueTrigger.add(param.getValueHandler, param.getValueHandlerOwner), 
                this._reset();
            }
            return SimpleProfiler.prototype.time = function(type) {
                this._beforeTimes[type] = this._getCurrentTime();
            }, SimpleProfiler.prototype.timeEnd = function(type) {
                var now = this._getCurrentTime(), value = null != this._beforeTimes[type] ? now - this._beforeTimes[type] : 0;
                this._values[type].push({
                    time: now,
                    value: value
                });
            }, SimpleProfiler.prototype.flush = function() {
                var now = this._getCurrentTime();
                if (0 === this._beforeFlushTime && (this._beforeFlushTime = now), this._beforeFlushTime + this._interval < now && (this._calculateProfilerValueTrigger.fire(this.getProfilerValue(this._interval)), 
                this._beforeFlushTime = now), this._values[1].length > this._limit) for (var i in this._values) this._values.hasOwnProperty(i) && (this._values[i] = this._values[i].slice(-SimpleProfiler.BACKUP_MARGIN));
            }, SimpleProfiler.prototype.setValue = function(type, value) {
                this._values[type].push({
                    time: this._getCurrentTime(),
                    value: value
                });
            }, SimpleProfiler.prototype.getProfilerValue = function(time) {
                var rawFrameInterval = this._calculateProfilerValue(1, time);
                return {
                    skippedFrameCount: this._calculateProfilerValue(0, time),
                    rawFrameInterval: rawFrameInterval,
                    framePerSecond: {
                        ave: 1e3 / rawFrameInterval.ave,
                        max: 1e3 / rawFrameInterval.min,
                        min: 1e3 / rawFrameInterval.max
                    },
                    frameTime: this._calculateProfilerValue(2, time),
                    renderingTime: this._calculateProfilerValue(3, time)
                };
            }, SimpleProfiler.prototype._reset = function() {
                this._startTime = this._getCurrentTime(), this._beforeFlushTime = 0, this._beforeTimes = [], 
                this._beforeTimes[1] = 0, this._beforeTimes[2] = 0, this._beforeTimes[3] = 0, this._beforeTimes[0] = 0, 
                this._values = [], this._values[1] = [], this._values[2] = [], this._values[3] = [], 
                this._values[0] = [];
            }, SimpleProfiler.prototype._calculateProfilerValue = function(type, time) {
                for (var limit = this._getCurrentTime() - time, sum = 0, num = 0, max = 0, min = Number.MAX_VALUE, i = this._values[type].length - 1; i >= 0 && !(num > 0 && this._values[type][i].time < limit); --i) {
                    var value = this._values[type][i].value;
                    value > max && (max = value), min > value && (min = value), sum += value, ++num;
                }
                return {
                    ave: sum / num,
                    max: max,
                    min: min
                };
            }, SimpleProfiler.prototype._getCurrentTime = function() {
                return +new Date();
            }, SimpleProfiler.DEFAULT_INTERVAL = 1e3, SimpleProfiler.DEFAULT_LIMIT = 1e3, SimpleProfiler.BACKUP_MARGIN = 100, 
            SimpleProfiler;
        }();
        exports.SimpleProfiler = SimpleProfiler;
    }, {
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    22: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
    }, {} ],
    23: [ function(require, module, exports) {
        (function(process, global) {
            /*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   3.3.1
 */
            !function(global, factory) {
                "object" == typeof exports && "undefined" != typeof module ? module.exports = factory() : "function" == typeof define && define.amd ? define(factory) : global.ES6Promise = factory();
            }(this, function() {
                "use strict";
                function objectOrFunction(x) {
                    return "function" == typeof x || "object" == typeof x && null !== x;
                }
                function isFunction(x) {
                    return "function" == typeof x;
                }
                function setScheduler(scheduleFn) {
                    customSchedulerFn = scheduleFn;
                }
                function setAsap(asapFn) {
                    asap = asapFn;
                }
                function useNextTick() {
                    return function() {
                        return process.nextTick(flush);
                    };
                }
                function useVertxTimer() {
                    return function() {
                        vertxNext(flush);
                    };
                }
                function useMutationObserver() {
                    var iterations = 0, observer = new BrowserMutationObserver(flush), node = document.createTextNode("");
                    return observer.observe(node, {
                        characterData: !0
                    }), function() {
                        node.data = iterations = ++iterations % 2;
                    };
                }
                function useMessageChannel() {
                    var channel = new MessageChannel();
                    return channel.port1.onmessage = flush, function() {
                        return channel.port2.postMessage(0);
                    };
                }
                function useSetTimeout() {
                    var globalSetTimeout = setTimeout;
                    return function() {
                        return globalSetTimeout(flush, 1);
                    };
                }
                function flush() {
                    for (var i = 0; len > i; i += 2) {
                        var callback = queue[i], arg = queue[i + 1];
                        callback(arg), queue[i] = void 0, queue[i + 1] = void 0;
                    }
                    len = 0;
                }
                function attemptVertx() {
                    try {
                        var r = require, vertx = r("vertx");
                        return vertxNext = vertx.runOnLoop || vertx.runOnContext, useVertxTimer();
                    } catch (e) {
                        return useSetTimeout();
                    }
                }
                function then(onFulfillment, onRejection) {
                    var _arguments = arguments, parent = this, child = new this.constructor(noop);
                    void 0 === child[PROMISE_ID] && makePromise(child);
                    var _state = parent._state;
                    return _state ? !function() {
                        var callback = _arguments[_state - 1];
                        asap(function() {
                            return invokeCallback(_state, child, callback, parent._result);
                        });
                    }() : subscribe(parent, child, onFulfillment, onRejection), child;
                }
                function resolve(object) {
                    var Constructor = this;
                    if (object && "object" == typeof object && object.constructor === Constructor) return object;
                    var promise = new Constructor(noop);
                    return _resolve(promise, object), promise;
                }
                function noop() {}
                function selfFulfillment() {
                    return new TypeError("You cannot resolve a promise with itself");
                }
                function cannotReturnOwn() {
                    return new TypeError("A promises callback cannot return that same promise.");
                }
                function getThen(promise) {
                    try {
                        return promise.then;
                    } catch (error) {
                        return GET_THEN_ERROR.error = error, GET_THEN_ERROR;
                    }
                }
                function tryThen(then, value, fulfillmentHandler, rejectionHandler) {
                    try {
                        then.call(value, fulfillmentHandler, rejectionHandler);
                    } catch (e) {
                        return e;
                    }
                }
                function handleForeignThenable(promise, thenable, then) {
                    asap(function(promise) {
                        var sealed = !1, error = tryThen(then, thenable, function(value) {
                            sealed || (sealed = !0, thenable !== value ? _resolve(promise, value) : fulfill(promise, value));
                        }, function(reason) {
                            sealed || (sealed = !0, _reject(promise, reason));
                        }, "Settle: " + (promise._label || " unknown promise"));
                        !sealed && error && (sealed = !0, _reject(promise, error));
                    }, promise);
                }
                function handleOwnThenable(promise, thenable) {
                    thenable._state === FULFILLED ? fulfill(promise, thenable._result) : thenable._state === REJECTED ? _reject(promise, thenable._result) : subscribe(thenable, void 0, function(value) {
                        return _resolve(promise, value);
                    }, function(reason) {
                        return _reject(promise, reason);
                    });
                }
                function handleMaybeThenable(promise, maybeThenable, then$$) {
                    maybeThenable.constructor === promise.constructor && then$$ === then && maybeThenable.constructor.resolve === resolve ? handleOwnThenable(promise, maybeThenable) : then$$ === GET_THEN_ERROR ? _reject(promise, GET_THEN_ERROR.error) : void 0 === then$$ ? fulfill(promise, maybeThenable) : isFunction(then$$) ? handleForeignThenable(promise, maybeThenable, then$$) : fulfill(promise, maybeThenable);
                }
                function _resolve(promise, value) {
                    promise === value ? _reject(promise, selfFulfillment()) : objectOrFunction(value) ? handleMaybeThenable(promise, value, getThen(value)) : fulfill(promise, value);
                }
                function publishRejection(promise) {
                    promise._onerror && promise._onerror(promise._result), publish(promise);
                }
                function fulfill(promise, value) {
                    promise._state === PENDING && (promise._result = value, promise._state = FULFILLED, 
                    0 !== promise._subscribers.length && asap(publish, promise));
                }
                function _reject(promise, reason) {
                    promise._state === PENDING && (promise._state = REJECTED, promise._result = reason, 
                    asap(publishRejection, promise));
                }
                function subscribe(parent, child, onFulfillment, onRejection) {
                    var _subscribers = parent._subscribers, length = _subscribers.length;
                    parent._onerror = null, _subscribers[length] = child, _subscribers[length + FULFILLED] = onFulfillment, 
                    _subscribers[length + REJECTED] = onRejection, 0 === length && parent._state && asap(publish, parent);
                }
                function publish(promise) {
                    var subscribers = promise._subscribers, settled = promise._state;
                    if (0 !== subscribers.length) {
                        for (var child = void 0, callback = void 0, detail = promise._result, i = 0; i < subscribers.length; i += 3) child = subscribers[i], 
                        callback = subscribers[i + settled], child ? invokeCallback(settled, child, callback, detail) : callback(detail);
                        promise._subscribers.length = 0;
                    }
                }
                function ErrorObject() {
                    this.error = null;
                }
                function tryCatch(callback, detail) {
                    try {
                        return callback(detail);
                    } catch (e) {
                        return TRY_CATCH_ERROR.error = e, TRY_CATCH_ERROR;
                    }
                }
                function invokeCallback(settled, promise, callback, detail) {
                    var hasCallback = isFunction(callback), value = void 0, error = void 0, succeeded = void 0, failed = void 0;
                    if (hasCallback) {
                        if (value = tryCatch(callback, detail), value === TRY_CATCH_ERROR ? (failed = !0, 
                        error = value.error, value = null) : succeeded = !0, promise === value) return void _reject(promise, cannotReturnOwn());
                    } else value = detail, succeeded = !0;
                    promise._state !== PENDING || (hasCallback && succeeded ? _resolve(promise, value) : failed ? _reject(promise, error) : settled === FULFILLED ? fulfill(promise, value) : settled === REJECTED && _reject(promise, value));
                }
                function initializePromise(promise, resolver) {
                    try {
                        resolver(function(value) {
                            _resolve(promise, value);
                        }, function(reason) {
                            _reject(promise, reason);
                        });
                    } catch (e) {
                        _reject(promise, e);
                    }
                }
                function nextId() {
                    return id++;
                }
                function makePromise(promise) {
                    promise[PROMISE_ID] = id++, promise._state = void 0, promise._result = void 0, promise._subscribers = [];
                }
                function Enumerator(Constructor, input) {
                    this._instanceConstructor = Constructor, this.promise = new Constructor(noop), this.promise[PROMISE_ID] || makePromise(this.promise), 
                    isArray(input) ? (this._input = input, this.length = input.length, this._remaining = input.length, 
                    this._result = new Array(this.length), 0 === this.length ? fulfill(this.promise, this._result) : (this.length = this.length || 0, 
                    this._enumerate(), 0 === this._remaining && fulfill(this.promise, this._result))) : _reject(this.promise, validationError());
                }
                function validationError() {
                    return new Error("Array Methods must be provided an Array");
                }
                function all(entries) {
                    return new Enumerator(this, entries).promise;
                }
                function race(entries) {
                    var Constructor = this;
                    return new Constructor(isArray(entries) ? function(resolve, reject) {
                        for (var length = entries.length, i = 0; length > i; i++) Constructor.resolve(entries[i]).then(resolve, reject);
                    } : function(_, reject) {
                        return reject(new TypeError("You must pass an array to race."));
                    });
                }
                function reject(reason) {
                    var Constructor = this, promise = new Constructor(noop);
                    return _reject(promise, reason), promise;
                }
                function needsResolver() {
                    throw new TypeError("You must pass a resolver function as the first argument to the promise constructor");
                }
                function needsNew() {
                    throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
                }
                function Promise(resolver) {
                    this[PROMISE_ID] = nextId(), this._result = this._state = void 0, this._subscribers = [], 
                    noop !== resolver && ("function" != typeof resolver && needsResolver(), this instanceof Promise ? initializePromise(this, resolver) : needsNew());
                }
                function polyfill() {
                    var local = void 0;
                    if ("undefined" != typeof global) local = global; else if ("undefined" != typeof self) local = self; else try {
                        local = Function("return this")();
                    } catch (e) {
                        throw new Error("polyfill failed because global object is unavailable in this environment");
                    }
                    var P = local.Promise;
                    if (P) {
                        var promiseToString = null;
                        try {
                            promiseToString = Object.prototype.toString.call(P.resolve());
                        } catch (e) {}
                        if ("[object Promise]" === promiseToString && !P.cast) return;
                    }
                    local.Promise = Promise;
                }
                var _isArray = void 0;
                _isArray = Array.isArray ? Array.isArray : function(x) {
                    return "[object Array]" === Object.prototype.toString.call(x);
                };
                var isArray = _isArray, len = 0, vertxNext = void 0, customSchedulerFn = void 0, asap = function(callback, arg) {
                    queue[len] = callback, queue[len + 1] = arg, len += 2, 2 === len && (customSchedulerFn ? customSchedulerFn(flush) : scheduleFlush());
                }, browserWindow = "undefined" != typeof window ? window : void 0, browserGlobal = browserWindow || {}, BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver, isNode = "undefined" == typeof self && "undefined" != typeof process && "[object process]" === {}.toString.call(process), isWorker = "undefined" != typeof Uint8ClampedArray && "undefined" != typeof importScripts && "undefined" != typeof MessageChannel, queue = new Array(1e3), scheduleFlush = void 0;
                scheduleFlush = isNode ? useNextTick() : BrowserMutationObserver ? useMutationObserver() : isWorker ? useMessageChannel() : void 0 === browserWindow && "function" == typeof require ? attemptVertx() : useSetTimeout();
                var PROMISE_ID = Math.random().toString(36).substring(16), PENDING = void 0, FULFILLED = 1, REJECTED = 2, GET_THEN_ERROR = new ErrorObject(), TRY_CATCH_ERROR = new ErrorObject(), id = 0;
                return Enumerator.prototype._enumerate = function() {
                    for (var length = this.length, _input = this._input, i = 0; this._state === PENDING && length > i; i++) this._eachEntry(_input[i], i);
                }, Enumerator.prototype._eachEntry = function(entry, i) {
                    var c = this._instanceConstructor, resolve$$ = c.resolve;
                    if (resolve$$ === resolve) {
                        var _then = getThen(entry);
                        if (_then === then && entry._state !== PENDING) this._settledAt(entry._state, i, entry._result); else if ("function" != typeof _then) this._remaining--, 
                        this._result[i] = entry; else if (c === Promise) {
                            var promise = new c(noop);
                            handleMaybeThenable(promise, entry, _then), this._willSettleAt(promise, i);
                        } else this._willSettleAt(new c(function(resolve$$) {
                            return resolve$$(entry);
                        }), i);
                    } else this._willSettleAt(resolve$$(entry), i);
                }, Enumerator.prototype._settledAt = function(state, i, value) {
                    var promise = this.promise;
                    promise._state === PENDING && (this._remaining--, state === REJECTED ? _reject(promise, value) : this._result[i] = value), 
                    0 === this._remaining && fulfill(promise, this._result);
                }, Enumerator.prototype._willSettleAt = function(promise, i) {
                    var enumerator = this;
                    subscribe(promise, void 0, function(value) {
                        return enumerator._settledAt(FULFILLED, i, value);
                    }, function(reason) {
                        return enumerator._settledAt(REJECTED, i, reason);
                    });
                }, Promise.all = all, Promise.race = race, Promise.resolve = resolve, Promise.reject = reject, 
                Promise._setScheduler = setScheduler, Promise._setAsap = setAsap, Promise._asap = asap, 
                Promise.prototype = {
                    constructor: Promise,
                    then: then,
                    "catch": function(onRejection) {
                        return this.then(null, onRejection);
                    }
                }, polyfill(), Promise.polyfill = polyfill, Promise.Promise = Promise, Promise;
            });
        }).call(this, require("_process"), "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
    }, {
        _process: 24
    } ],
    24: [ function(require, module, exports) {
        function defaultSetTimout() {
            throw new Error("setTimeout has not been defined");
        }
        function defaultClearTimeout() {
            throw new Error("clearTimeout has not been defined");
        }
        function runTimeout(fun) {
            if (cachedSetTimeout === setTimeout) return setTimeout(fun, 0);
            if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) return cachedSetTimeout = setTimeout, 
            setTimeout(fun, 0);
            try {
                return cachedSetTimeout(fun, 0);
            } catch (e) {
                try {
                    return cachedSetTimeout.call(null, fun, 0);
                } catch (e) {
                    return cachedSetTimeout.call(this, fun, 0);
                }
            }
        }
        function runClearTimeout(marker) {
            if (cachedClearTimeout === clearTimeout) return clearTimeout(marker);
            if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) return cachedClearTimeout = clearTimeout, 
            clearTimeout(marker);
            try {
                return cachedClearTimeout(marker);
            } catch (e) {
                try {
                    return cachedClearTimeout.call(null, marker);
                } catch (e) {
                    return cachedClearTimeout.call(this, marker);
                }
            }
        }
        function cleanUpNextTick() {
            draining && currentQueue && (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, 
            queue.length && drainQueue());
        }
        function drainQueue() {
            if (!draining) {
                var timeout = runTimeout(cleanUpNextTick);
                draining = !0;
                for (var len = queue.length; len; ) {
                    for (currentQueue = queue, queue = []; ++queueIndex < len; ) currentQueue && currentQueue[queueIndex].run();
                    queueIndex = -1, len = queue.length;
                }
                currentQueue = null, draining = !1, runClearTimeout(timeout);
            }
        }
        function Item(fun, array) {
            this.fun = fun, this.array = array;
        }
        function noop() {}
        var cachedSetTimeout, cachedClearTimeout, process = module.exports = {};
        !function() {
            try {
                cachedSetTimeout = "function" == typeof setTimeout ? setTimeout : defaultSetTimout;
            } catch (e) {
                cachedSetTimeout = defaultSetTimout;
            }
            try {
                cachedClearTimeout = "function" == typeof clearTimeout ? clearTimeout : defaultClearTimeout;
            } catch (e) {
                cachedClearTimeout = defaultClearTimeout;
            }
        }();
        var currentQueue, queue = [], draining = !1, queueIndex = -1;
        process.nextTick = function(fun) {
            var args = new Array(arguments.length - 1);
            if (arguments.length > 1) for (var i = 1; i < arguments.length; i++) args[i - 1] = arguments[i];
            queue.push(new Item(fun, args)), 1 !== queue.length || draining || runTimeout(drainQueue);
        }, Item.prototype.run = function() {
            this.fun.apply(null, this.array);
        }, process.title = "browser", process.browser = !0, process.env = {}, process.argv = [], 
        process.version = "", process.versions = {}, process.on = noop, process.addListener = noop, 
        process.once = noop, process.off = noop, process.removeListener = noop, process.removeAllListeners = noop, 
        process.emit = noop, process.prependListener = noop, process.prependOnceListener = noop, 
        process.listeners = function(name) {
            return [];
        }, process.binding = function(name) {
            throw new Error("process.binding is not supported");
        }, process.cwd = function() {
            return "/";
        }, process.chdir = function(dir) {
            throw new Error("process.chdir is not supported");
        }, process.umask = function() {
            return 0;
        };
    }, {} ],
    "@akashic/game-driver": [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var EventIndex = require("./EventIndex");
        exports.EventIndex = EventIndex;
        var LoopMode_1 = require("./LoopMode");
        exports.LoopMode = LoopMode_1["default"];
        var LoopRenderMode_1 = require("./LoopRenderMode");
        exports.LoopRenderMode = LoopRenderMode_1["default"];
        var ExecutionMode_1 = require("./ExecutionMode");
        exports.ExecutionMode = ExecutionMode_1["default"];
        var GameDriver_1 = require("./GameDriver");
        exports.GameDriver = GameDriver_1.GameDriver;
        var Game_1 = require("./Game");
        exports.Game = Game_1.Game;
        var ReplayAmflowProxy_1 = require("./auxiliary/ReplayAmflowProxy");
        exports.ReplayAmflowProxy = ReplayAmflowProxy_1.ReplayAmflowProxy;
        var MemoryAmflowClient_1 = require("./auxiliary/MemoryAmflowClient");
        exports.MemoryAmflowClient = MemoryAmflowClient_1.MemoryAmflowClient;
        var SimpleProfiler_1 = require("./auxiliary/SimpleProfiler");
        exports.SimpleProfiler = SimpleProfiler_1.SimpleProfiler;
    }, {
        "./EventIndex": 4,
        "./ExecutionMode": 5,
        "./Game": 6,
        "./GameDriver": 7,
        "./LoopMode": 10,
        "./LoopRenderMode": 11,
        "./auxiliary/MemoryAmflowClient": 19,
        "./auxiliary/ReplayAmflowProxy": 20,
        "./auxiliary/SimpleProfiler": 21
    } ]
}, {}, []);	require = function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = "function" == typeof require && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                var f = new Error("Cannot find module '" + o + "'");
                throw f.code = "MODULE_NOT_FOUND", f;
            }
            var l = n[o] = {
                exports: {}
            };
            t[o][0].call(l.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    for (var i = "function" == typeof require && require, o = 0; o < r.length; o++) s(r[o]);
    return s;
}({
    1: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var AudioManager = function() {
            function AudioManager() {
                this.audioAssets = [], this._masterVolume = 1;
            }
            return AudioManager.prototype.registerAudioAsset = function(asset) {
                -1 === this.audioAssets.indexOf(asset) && this.audioAssets.push(asset);
            }, AudioManager.prototype.removeAudioAsset = function(asset) {
                var index = this.audioAssets.indexOf(asset);
                -1 === index && this.audioAssets.splice(index, 1);
            }, AudioManager.prototype.setMasterVolume = function(volume) {
                this._masterVolume = volume;
                for (var i = 0; i < this.audioAssets.length; i++) this.audioAssets[i]._lastPlayedPlayer && this.audioAssets[i]._lastPlayedPlayer.notifyMasterVolumeChanged();
            }, AudioManager.prototype.getMasterVolume = function() {
                return this._masterVolume;
            }, AudioManager;
        }();
        exports.AudioManager = AudioManager;
    }, {} ],
    2: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), RenderingHelper_1 = require("./canvas/RenderingHelper"), InputHandlerLayer_1 = require("./InputHandlerLayer"), ContainerController = function() {
            function ContainerController() {
                this.container = null, this.surface = null, this.inputHandlerLayer = null, this.rootView = null, 
                this.useResizeForScaling = !1, this.pointEventTrigger = new g.Trigger(), this._rendererReq = null, 
                this._disablePreventDefault = !1;
            }
            return ContainerController.prototype.initialize = function(param) {
                this._rendererReq = param.rendererRequirement, this._disablePreventDefault = !!param.disablePreventDefault, 
                this._loadView();
            }, ContainerController.prototype.setRootView = function(rootView) {
                rootView !== this.rootView && (this.rootView && (this.unloadView(), this._loadView()), 
                this.rootView = rootView, this._appendToRootView(rootView));
            }, ContainerController.prototype.resetView = function(rendererReq) {
                this.unloadView(), this._rendererReq = rendererReq, this._loadView(), this._appendToRootView(this.rootView);
            }, ContainerController.prototype.getRenderer = function() {
                if (!this.surface) throw new Error("this container has no surface");
                return this.surface.renderer();
            }, ContainerController.prototype.changeScale = function(xScale, yScale) {
                this.useResizeForScaling ? this.surface.changePhysicalScale(xScale, yScale) : this.surface.changeVisualScale(xScale, yScale), 
                this.inputHandlerLayer._inputHandler.setScale(xScale, yScale);
            }, ContainerController.prototype.unloadView = function() {
                if (this.inputHandlerLayer.disablePointerEvent(), this.rootView) for (;this.rootView.firstChild; ) this.rootView.removeChild(this.rootView.firstChild);
            }, ContainerController.prototype._loadView = function() {
                var _a = this._rendererReq, width = _a.primarySurfaceWidth, height = _a.primarySurfaceHeight, rc = _a.rendererCandidates, disablePreventDefault = this._disablePreventDefault;
                this.container = document.createDocumentFragment(), this.inputHandlerLayer ? (this.inputHandlerLayer.setViewSize({
                    width: width,
                    height: height
                }), this.inputHandlerLayer.pointEventTrigger.removeAll(), this.inputHandlerLayer.view.removeChild(this.surface.canvas), 
                this.surface.destroy()) : this.inputHandlerLayer = new InputHandlerLayer_1.InputHandlerLayer({
                    width: width,
                    height: height,
                    disablePreventDefault: disablePreventDefault
                }), this.surface = RenderingHelper_1.RenderingHelper.createPrimarySurface(width, height, rc), 
                this.inputHandlerLayer.view.appendChild(this.surface.getHTMLElement()), this.container.appendChild(this.inputHandlerLayer.view);
            }, ContainerController.prototype._appendToRootView = function(rootView) {
                rootView.appendChild(this.container), this.inputHandlerLayer.enablePointerEvent(), 
                this.inputHandlerLayer.pointEventTrigger.add(this.pointEventTrigger.fire, this.pointEventTrigger);
            }, ContainerController;
        }();
        exports.ContainerController = ContainerController;
    }, {
        "./InputHandlerLayer": 3,
        "./canvas/RenderingHelper": 16,
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    3: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), MouseHandler_1 = require("./handler/MouseHandler"), TouchHandler_1 = require("./handler/TouchHandler"), InputHandlerLayer = function() {
            function InputHandlerLayer(param) {
                this.view = this._createInputView(param.width, param.height), this._inputHandler = void 0, 
                this.pointEventTrigger = new g.Trigger(), this._disablePreventDefault = !!param.disablePreventDefault;
            }
            return InputHandlerLayer.prototype.enablePointerEvent = function() {
                var _this = this;
                TouchHandler_1.TouchHandler.isSupported() ? this._inputHandler = new TouchHandler_1.TouchHandler(this.view, this._disablePreventDefault) : this._inputHandler = new MouseHandler_1.MouseHandler(this.view, this._disablePreventDefault), 
                this._inputHandler.pointTrigger.add(function(e) {
                    _this.pointEventTrigger.fire(e);
                }), this._inputHandler.start();
            }, InputHandlerLayer.prototype.disablePointerEvent = function() {
                this._inputHandler && this._inputHandler.stop();
            }, InputHandlerLayer.prototype.setOffset = function(offset) {
                var inputViewStyle = "position:relative; left:" + offset.x + "px; top:" + offset.y + "px";
                this._inputHandler.inputView.setAttribute("style", inputViewStyle);
            }, InputHandlerLayer.prototype.setViewSize = function(size) {
                var view = this.view;
                view.style.width = size.width + "px", view.style.height = size.height + "px";
            }, InputHandlerLayer.prototype._createInputView = function(width, height) {
                var view = document.createElement("div");
                return view.setAttribute("tabindex", "1"), view.className = "input-handler", view.setAttribute("style", "display:inline-block; outline:none;"), 
                view.style.width = width + "px", view.style.height = height + "px", view;
            }, InputHandlerLayer;
        }();
        exports.InputHandlerLayer = InputHandlerLayer;
    }, {
        "./handler/MouseHandler": 19,
        "./handler/TouchHandler": 20,
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    4: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var RafLooper_1 = require("./RafLooper"), ResourceFactory_1 = require("./ResourceFactory"), ContainerController_1 = require("./ContainerController"), AudioPluginManager_1 = require("./plugin/AudioPluginManager"), AudioManager_1 = require("./AudioManager"), AudioPluginRegistry_1 = require("./plugin/AudioPluginRegistry"), XHRTextAsset_1 = require("./asset/XHRTextAsset"), Platform = function() {
            function Platform(param) {
                this.containerView = param.containerView, this.containerController = new ContainerController_1.ContainerController(), 
                this.audioPluginManager = new AudioPluginManager_1.AudioPluginManager(), param.audioPlugins && this.audioPluginManager.tryInstallPlugin(param.audioPlugins), 
                this.audioPluginManager.tryInstallPlugin(AudioPluginRegistry_1.AudioPluginRegistry.getRegisteredAudioPlugins()), 
                this._audioManager = new AudioManager_1.AudioManager(), this.amflow = param.amflow, 
                this._platformEventHandler = null, this._resourceFactory = param.resourceFactory || new ResourceFactory_1.ResourceFactory({
                    audioPluginManager: this.audioPluginManager,
                    platform: this,
                    audioManager: this._audioManager
                }), this._rendererReq = null, this._disablePreventDefault = !!param.disablePreventDefault;
            }
            return Platform.prototype.setPlatformEventHandler = function(handler) {
                this.containerController && (this.containerController.pointEventTrigger.removeAll({
                    owner: this._platformEventHandler
                }), this.containerController.pointEventTrigger.add(handler.onPointEvent, handler)), 
                this._platformEventHandler = handler;
            }, Platform.prototype.loadGameConfiguration = function(url, callback) {
                var a = new XHRTextAsset_1.XHRTextAsset("(game.json)", url);
                a._load({
                    _onAssetLoad: function(asset) {
                        callback(null, JSON.parse(a.data));
                    },
                    _onAssetError: function(asset, error) {
                        callback(error, null);
                    }
                });
            }, Platform.prototype.getResourceFactory = function() {
                return this._resourceFactory;
            }, Platform.prototype.setRendererRequirement = function(requirement) {
                if (!requirement) return void (this.containerController && this.containerController.unloadView());
                if (this._rendererReq = requirement, this._resourceFactory._rendererCandidates = this._rendererReq.rendererCandidates, 
                this.containerController && !this.containerController.inputHandlerLayer) this.containerController.initialize({
                    rendererRequirement: requirement,
                    disablePreventDefault: this._disablePreventDefault
                }), this.containerController.setRootView(this.containerView), this._platformEventHandler && this.containerController.pointEventTrigger.add(this._platformEventHandler.onPointEvent, this._platformEventHandler); else {
                    var surface = this.getPrimarySurface();
                    surface && !surface.destroyed() && surface.destroy(), this.containerController.resetView(requirement);
                }
            }, Platform.prototype.getPrimarySurface = function() {
                return this.containerController.surface;
            }, Platform.prototype.getOperationPluginViewInfo = function() {
                var _this = this;
                return {
                    type: "pdi-browser",
                    view: this.containerController.inputHandlerLayer.view,
                    getScale: function() {
                        return _this.containerController.inputHandlerLayer._inputHandler.getScale();
                    }
                };
            }, Platform.prototype.createLooper = function(fun) {
                return new RafLooper_1.RafLooper(fun);
            }, Platform.prototype.sendToExternal = function(playId, data) {}, Platform.prototype.registerAudioPlugins = function(plugins) {
                return this.audioPluginManager.tryInstallPlugin(plugins);
            }, Platform.prototype.setScale = function(xScale, yScale) {
                this.containerController.changeScale(xScale, yScale);
            }, Platform.prototype.notifyViewMoved = function() {}, Platform.prototype.setMasterVolume = function(volume) {
                this._audioManager && this._audioManager.setMasterVolume(volume);
            }, Platform.prototype.getMasterVolume = function() {
                return this._audioManager ? this._audioManager.getMasterVolume() : void 0;
            }, Platform;
        }();
        exports.Platform = Platform;
    }, {
        "./AudioManager": 1,
        "./ContainerController": 2,
        "./RafLooper": 5,
        "./ResourceFactory": 6,
        "./asset/XHRTextAsset": 12,
        "./plugin/AudioPluginManager": 21,
        "./plugin/AudioPluginRegistry": 22
    } ],
    5: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var RafLooper = function() {
            function RafLooper(fun) {
                this._fun = fun, this._timerId = void 0, this._prev = 0;
            }
            return RafLooper.prototype.start = function() {
                var _this = this, onAnimationFrame = function(deltaTime) {
                    null != _this._timerId && (_this._timerId = requestAnimationFrame(onAnimationFrame), 
                    _this._fun(deltaTime - _this._prev), _this._prev = deltaTime);
                }, onFirstFrame = function(deltaTime) {
                    _this._timerId = requestAnimationFrame(onAnimationFrame), _this._fun(0), _this._prev = deltaTime;
                };
                this._timerId = requestAnimationFrame(onFirstFrame);
            }, RafLooper.prototype.stop = function() {
                cancelAnimationFrame(this._timerId), this._timerId = void 0, this._prev = 0;
            }, RafLooper;
        }();
        exports.RafLooper = RafLooper;
    }, {} ],
    6: [ function(require, module, exports) {
        "use strict";
        var __extends = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            };
            return function(d, b) {
                function __() {
                    this.constructor = d;
                }
                extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
                new __());
            };
        }();
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), HTMLImageAsset_1 = require("./asset/HTMLImageAsset"), HTMLVideoAsset_1 = require("./asset/HTMLVideoAsset"), XHRTextAsset_1 = require("./asset/XHRTextAsset"), XHRScriptAsset_1 = require("./asset/XHRScriptAsset"), RenderingHelper_1 = require("./canvas/RenderingHelper"), GlyphFactory_1 = require("./canvas/GlyphFactory"), ResourceFactory = function(_super) {
            function ResourceFactory(param) {
                var _this = _super.call(this) || this;
                return _this._audioPluginManager = param.audioPluginManager, _this._audioManager = param.audioManager, 
                _this._platform = param.platform, _this;
            }
            return __extends(ResourceFactory, _super), ResourceFactory.prototype.createAudioAsset = function(id, assetPath, duration, system, loop, hint) {
                var activePlugin = this._audioPluginManager.getActivePlugin(), audioAsset = activePlugin.createAsset(id, assetPath, duration, system, loop, hint);
                return audioAsset.onDestroyed && (this._audioManager.registerAudioAsset(audioAsset), 
                audioAsset.onDestroyed.add(this._onAudioAssetDestroyed, this)), audioAsset;
            }, ResourceFactory.prototype.createAudioPlayer = function(system) {
                var activePlugin = this._audioPluginManager.getActivePlugin();
                return activePlugin.createPlayer(system, this._audioManager);
            }, ResourceFactory.prototype.createImageAsset = function(id, assetPath, width, height) {
                return new HTMLImageAsset_1.HTMLImageAsset(id, assetPath, width, height);
            }, ResourceFactory.prototype.createVideoAsset = function(id, assetPath, width, height, system, loop, useRealSize) {
                return new HTMLVideoAsset_1.HTMLVideoAsset(id, assetPath, width, height, system, loop, useRealSize);
            }, ResourceFactory.prototype.createTextAsset = function(id, assetPath) {
                return new XHRTextAsset_1.XHRTextAsset(id, assetPath);
            }, ResourceFactory.prototype.createScriptAsset = function(id, assetPath) {
                return new XHRScriptAsset_1.XHRScriptAsset(id, assetPath);
            }, ResourceFactory.prototype.createSurface = function(width, height) {
                return RenderingHelper_1.RenderingHelper.createBackSurface(width, height, this._platform, this._rendererCandidates);
            }, ResourceFactory.prototype.createGlyphFactory = function(fontFamily, fontSize, baseline, fontColor, strokeWidth, strokeColor, strokeOnly, fontWeight) {
                return new GlyphFactory_1.GlyphFactory(fontFamily, fontSize, baseline, fontColor, strokeWidth, strokeColor, strokeOnly, fontWeight);
            }, ResourceFactory.prototype._onAudioAssetDestroyed = function(asset) {
                this._audioManager.removeAudioAsset(asset);
            }, ResourceFactory;
        }(g.ResourceFactory);
        exports.ResourceFactory = ResourceFactory;
    }, {
        "./asset/HTMLImageAsset": 8,
        "./asset/HTMLVideoAsset": 9,
        "./asset/XHRScriptAsset": 11,
        "./asset/XHRTextAsset": 12,
        "./canvas/GlyphFactory": 15,
        "./canvas/RenderingHelper": 16,
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    7: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var RuntimeInfo;
        !function(RuntimeInfo) {
            function pointerEnabled() {
                return "pointerEnabled" in window.navigator;
            }
            function msPointerEnabled() {
                return "msPointerEnabled" in window.navigator;
            }
            function touchEnabled() {
                return "ontouchstart" in window;
            }
            RuntimeInfo.pointerEnabled = pointerEnabled, RuntimeInfo.msPointerEnabled = msPointerEnabled, 
            RuntimeInfo.touchEnabled = touchEnabled;
        }(RuntimeInfo = exports.RuntimeInfo || (exports.RuntimeInfo = {}));
    }, {} ],
    8: [ function(require, module, exports) {
        "use strict";
        var __extends = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            };
            return function(d, b) {
                function __() {
                    this.constructor = d;
                }
                extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
                new __());
            };
        }();
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), ImageAssetSurface = function(_super) {
            function ImageAssetSurface(width, height, drawable) {
                return _super.call(this, width, height, drawable) || this;
            }
            return __extends(ImageAssetSurface, _super), ImageAssetSurface.prototype.renderer = function() {
                throw g.ExceptionFactory.createAssertionError("ImageAssetSurface cannot be rendered.");
            }, ImageAssetSurface.prototype.isPlaying = function() {
                return !1;
            }, ImageAssetSurface;
        }(g.Surface);
        exports.ImageAssetSurface = ImageAssetSurface;
        var HTMLImageAsset = function(_super) {
            function HTMLImageAsset(id, path, width, height) {
                var _this = _super.call(this, id, path, width, height) || this;
                return _this.data = void 0, _this._surface = void 0, _this;
            }
            return __extends(HTMLImageAsset, _super), HTMLImageAsset.prototype.destroy = function() {
                this._surface && !this._surface.destroyed() && this._surface.destroy(), this.data = void 0, 
                this._surface = void 0, _super.prototype.destroy.call(this);
            }, HTMLImageAsset.prototype._load = function(loader) {
                var _this = this, image = new Image();
                image.onerror = function() {
                    loader._onAssetError(_this, g.ExceptionFactory.createAssetLoadError("HTMLImageAsset unknown loading error"));
                }, image.onload = function() {
                    _this.data = image, loader._onAssetLoad(_this);
                }, image.src = this.path;
            }, HTMLImageAsset.prototype.asSurface = function() {
                if (!this.data) throw g.ExceptionFactory.createAssertionError("ImageAssetImpl#asSurface: not yet loaded.");
                return this._surface ? this._surface : (this._surface = new ImageAssetSurface(this.width, this.height, this.data), 
                this._surface);
            }, HTMLImageAsset;
        }(g.ImageAsset);
        exports.HTMLImageAsset = HTMLImageAsset;
    }, {
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    9: [ function(require, module, exports) {
        "use strict";
        var __extends = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            };
            return function(d, b) {
                function __() {
                    this.constructor = d;
                }
                extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
                new __());
            };
        }();
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), HTMLVideoPlayer_1 = require("./HTMLVideoPlayer"), VideoAssetSurface = function(_super) {
            function VideoAssetSurface(width, height, drawable) {
                return _super.call(this, width, height, drawable, !0) || this;
            }
            return __extends(VideoAssetSurface, _super), VideoAssetSurface.prototype.renderer = function() {
                throw g.ExceptionFactory.createAssertionError("VideoAssetSurface cannot be rendered.");
            }, VideoAssetSurface.prototype.isPlaying = function() {
                return !1;
            }, VideoAssetSurface;
        }(g.Surface), HTMLVideoAsset = function(_super) {
            function HTMLVideoAsset(id, assetPath, width, height, system, loop, useRealSize) {
                var _this = _super.call(this, id, assetPath, width, height, system, loop, useRealSize) || this;
                return _this._player = new HTMLVideoPlayer_1.HTMLVideoPlayer(), _this._surface = new VideoAssetSurface(width, height, null), 
                _this;
            }
            return __extends(HTMLVideoAsset, _super), HTMLVideoAsset.prototype.inUse = function() {
                return !1;
            }, HTMLVideoAsset.prototype._load = function(loader) {
                var _this = this;
                setTimeout(function() {
                    loader._onAssetLoad(_this);
                }, 0);
            }, HTMLVideoAsset.prototype.getPlayer = function() {
                return this._player;
            }, HTMLVideoAsset.prototype.asSurface = function() {
                return this._surface;
            }, HTMLVideoAsset;
        }(g.VideoAsset);
        exports.HTMLVideoAsset = HTMLVideoAsset;
    }, {
        "./HTMLVideoPlayer": 10,
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    10: [ function(require, module, exports) {
        "use strict";
        var __extends = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            };
            return function(d, b) {
                function __() {
                    this.constructor = d;
                }
                extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
                new __());
            };
        }();
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), HTMLVideoPlayer = function(_super) {
            function HTMLVideoPlayer(loop) {
                var _this = _super.call(this, loop) || this;
                return _this.isDummy = !0, _this;
            }
            return __extends(HTMLVideoPlayer, _super), HTMLVideoPlayer.prototype.play = function(videoAsset) {}, 
            HTMLVideoPlayer.prototype.stop = function() {}, HTMLVideoPlayer.prototype.changeVolume = function(volume) {}, 
            HTMLVideoPlayer;
        }(g.VideoPlayer);
        exports.HTMLVideoPlayer = HTMLVideoPlayer;
    }, {
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    11: [ function(require, module, exports) {
        "use strict";
        var __extends = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            };
            return function(d, b) {
                function __() {
                    this.constructor = d;
                }
                extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
                new __());
            };
        }();
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), XHRLoader_1 = require("../utils/XHRLoader"), XHRScriptAsset = function(_super) {
            function XHRScriptAsset(id, path) {
                var _this = _super.call(this, id, path) || this;
                return _this.script = void 0, _this;
            }
            return __extends(XHRScriptAsset, _super), XHRScriptAsset.prototype._load = function(handler) {
                var _this = this, loader = new XHRLoader_1.XHRLoader();
                loader.get(this.path, function(error, responseText) {
                    return error ? void handler._onAssetError(_this, error) : (_this.script = responseText + "\n", 
                    void handler._onAssetLoad(_this));
                });
            }, XHRScriptAsset.prototype.execute = function(execEnv) {
                var func = this._wrap();
                return func(execEnv), execEnv.module.exports;
            }, XHRScriptAsset.prototype._wrap = function() {
                var func = new Function("g", XHRScriptAsset.PRE_SCRIPT + this.script + XHRScriptAsset.POST_SCRIPT);
                return func;
            }, XHRScriptAsset.PRE_SCRIPT = "(function(exports, require, module, __filename, __dirname) {", 
            XHRScriptAsset.POST_SCRIPT = "})(g.module.exports, g.module.require, g.module, g.filename, g.dirname);", 
            XHRScriptAsset;
        }(g.ScriptAsset);
        exports.XHRScriptAsset = XHRScriptAsset;
    }, {
        "../utils/XHRLoader": 30,
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    12: [ function(require, module, exports) {
        "use strict";
        var __extends = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            };
            return function(d, b) {
                function __() {
                    this.constructor = d;
                }
                extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
                new __());
            };
        }();
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), XHRLoader_1 = require("../utils/XHRLoader"), XHRTextAsset = function(_super) {
            function XHRTextAsset(id, path) {
                var _this = _super.call(this, id, path) || this;
                return _this.data = void 0, _this;
            }
            return __extends(XHRTextAsset, _super), XHRTextAsset.prototype._load = function(handler) {
                var _this = this, loader = new XHRLoader_1.XHRLoader();
                loader.get(this.path, function(error, responseText) {
                    return error ? void handler._onAssetError(_this, error) : (_this.data = responseText, 
                    void handler._onAssetLoad(_this));
                });
            }, XHRTextAsset;
        }(g.TextAsset);
        exports.XHRTextAsset = XHRTextAsset;
    }, {
        "../utils/XHRLoader": 30,
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    13: [ function(require, module, exports) {
        "use strict";
        var __extends = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            };
            return function(d, b) {
                function __() {
                    this.constructor = d;
                }
                extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
                new __());
            };
        }();
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), Context2DRenderer_1 = require("./Context2DRenderer"), CanvasSurface = function(_super) {
            function CanvasSurface(width, height) {
                var _this = this, canvas = document.createElement("canvas");
                return _this = _super.call(this, width, height, canvas) || this, canvas.width = width, 
                canvas.height = height, _this.canvas = canvas, _this._context = canvas.getContext("2d"), 
                _this._renderer = void 0, _this;
            }
            return __extends(CanvasSurface, _super), CanvasSurface.prototype.renderer = function() {
                return this._renderer || (this._renderer = new Context2DRenderer_1.Context2DRenderer(this, this._context)), 
                this._renderer;
            }, CanvasSurface.prototype.getHTMLElement = function() {
                return this.canvas;
            }, CanvasSurface.prototype.changePhysicalScale = function(xScale, yScale) {
                this.canvas.width = this.width * xScale, this.canvas.height = this.height * yScale, 
                this._context.scale(xScale, yScale);
            }, CanvasSurface.prototype.changeVisualScale = function(xScale, yScale) {
                var canvasStyle = this.canvas.style;
                "transform" in canvasStyle ? (canvasStyle.transformOrigin = "0 0", canvasStyle.transform = "scale(" + xScale + "," + yScale + ")") : "webkitTransform" in canvasStyle ? (canvasStyle.webkitTransformOrigin = "0 0", 
                canvasStyle.webkitTransform = "scale(" + xScale + "," + yScale + ")") : (canvasStyle.width = Math.floor(xScale * this.width) + "px", 
                canvasStyle.height = Math.floor(yScale * this.width) + "px");
            }, CanvasSurface.prototype.isPlaying = function() {
                throw g.ExceptionFactory.createAssertionError("CanvasSurface#isPlaying() is not implemented");
            }, CanvasSurface;
        }(g.Surface);
        exports.CanvasSurface = CanvasSurface;
    }, {
        "./Context2DRenderer": 14,
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    14: [ function(require, module, exports) {
        "use strict";
        var __extends = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            };
            return function(d, b) {
                function __() {
                    this.constructor = d;
                }
                extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
                new __());
            };
        }();
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), RenderingHelper_1 = require("./RenderingHelper"), Context2DRenderer = function(_super) {
            function Context2DRenderer(surface, context) {
                var _this = _super.call(this) || this;
                return _this.surface = surface, _this.context = context, _this;
            }
            return __extends(Context2DRenderer, _super), Context2DRenderer.prototype.clear = function() {
                this.context.clearRect(0, 0, this.surface.width, this.surface.height);
            }, Context2DRenderer.prototype.drawImage = function(surface, offsetX, offsetY, width, height, canvasOffsetX, canvasOffsetY) {
                this.context.drawImage(surface._drawable, offsetX, offsetY, width, height, canvasOffsetX, canvasOffsetY, width, height);
            }, Context2DRenderer.prototype.drawSprites = function(surface, offsetX, offsetY, width, height, canvasOffsetX, canvasOffsetY, count) {
                for (var i = 0; count > i; ++i) this.drawImage(surface, offsetX[i], offsetY[i], width[i], height[i], canvasOffsetX[i], canvasOffsetY[i]);
            }, Context2DRenderer.prototype.drawSystemText = function(text, x, y, maxWidth, fontSize, textAlign, textBaseline, textColor, fontFamily, strokeWidth, strokeColor, strokeOnly) {
                RenderingHelper_1.RenderingHelper.drawSystemTextByContext2D(this.context, text, x, y, maxWidth, fontSize, textAlign, textBaseline, textColor, fontFamily, strokeWidth, strokeColor, strokeOnly);
            }, Context2DRenderer.prototype.translate = function(x, y) {
                this.context.translate(x, y);
            }, Context2DRenderer.prototype.transform = function(matrix) {
                this.context.transform.apply(this.context, matrix);
            }, Context2DRenderer.prototype.opacity = function(opacity) {
                this.context.globalAlpha *= opacity;
            }, Context2DRenderer.prototype.save = function() {
                this.context.save();
            }, Context2DRenderer.prototype.restore = function() {
                this.context.restore();
            }, Context2DRenderer.prototype.fillRect = function(x, y, width, height, cssColor) {
                var _fillStyle = this.context.fillStyle;
                this.context.fillStyle = cssColor, this.context.fillRect(x, y, width, height), this.context.fillStyle = _fillStyle;
            }, Context2DRenderer.prototype.setCompositeOperation = function(operation) {
                this.context.globalCompositeOperation = RenderingHelper_1.RenderingHelper.toTextFromCompositeOperation(operation);
            }, Context2DRenderer.prototype.setOpacity = function(opacity) {
                throw g.ExceptionFactory.createAssertionError("Context2DRenderer#setOpacity() is not implemented");
            }, Context2DRenderer.prototype.setTransform = function(matrix) {
                throw g.ExceptionFactory.createAssertionError("Context2DRenderer#setTransform() is not implemented");
            }, Context2DRenderer.prototype._getImageData = function(sx, sy, sw, sh) {
                return this.context.getImageData(sx, sy, sw, sh);
            }, Context2DRenderer.prototype._putImageData = function(imageData, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight) {
                void 0 === dirtyX && (dirtyX = 0), void 0 === dirtyY && (dirtyY = 0), void 0 === dirtyWidth && (dirtyWidth = imageData.width), 
                void 0 === dirtyHeight && (dirtyHeight = imageData.height), this.context.putImageData(imageData, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
            }, Context2DRenderer;
        }(g.Renderer);
        exports.Context2DRenderer = Context2DRenderer;
    }, {
        "./RenderingHelper": 16,
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    15: [ function(require, module, exports) {
        "use strict";
        function createGlyphRenderedSurface(code, fontSize, cssFontFamily, baselineHeight, marginW, marginH, needImageData, fontColor, strokeWidth, strokeColor, strokeOnly, fontWeight) {
            var scale = fontSize < GlyphFactory._environmentMinimumFontSize ? fontSize / GlyphFactory._environmentMinimumFontSize : 1, surfaceWidth = Math.ceil((fontSize + 2 * marginW) * scale), surfaceHeight = Math.ceil((fontSize + 2 * marginH) * scale), surface = new CanvasSurface_1.CanvasSurface(surfaceWidth, surfaceHeight), canvas = surface.canvas, context = canvas.getContext("2d"), str = 4294901760 & code ? String.fromCharCode((4294901760 & code) >>> 16, 65535 & code) : String.fromCharCode(code), fontWeightValue = fontWeight === g.FontWeight.Bold ? "bold " : "";
            context.save(), context.font = fontWeightValue + fontSize + "px " + cssFontFamily, 
            context.textAlign = "left", context.textBaseline = "alphabetic", context.lineJoin = "bevel", 
            1 !== scale && context.scale(scale, scale), strokeWidth > 0 && (context.lineWidth = strokeWidth, 
            context.strokeStyle = strokeColor, context.strokeText(str, marginW, marginH + baselineHeight)), 
            strokeOnly || (context.fillStyle = fontColor, context.fillText(str, marginW, marginH + baselineHeight));
            var advanceWidth = context.measureText(str).width;
            context.restore();
            var result = {
                surface: surface,
                advanceWidth: advanceWidth,
                imageData: needImageData ? context.getImageData(0, 0, canvas.width, canvas.height) : void 0
            };
            return result;
        }
        function calcGlyphArea(imageData) {
            for (var sx = imageData.width, sy = imageData.height, ex = 0, ey = 0, currentPos = 0, y = 0, height = imageData.height; height > y; y = y + 1 | 0) for (var x = 0, width = imageData.width; width > x; x = x + 1 | 0) {
                var a = imageData.data[currentPos + 3];
                0 !== a && (sx > x && (sx = x), x > ex && (ex = x), sy > y && (sy = y), y > ey && (ey = y)), 
                currentPos += 4;
            }
            var glyphArea = void 0;
            return glyphArea = sx === imageData.width ? {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            } : {
                x: sx,
                y: sy,
                width: ex - sx + 1,
                height: ey - sy + 1
            };
        }
        function isGlyphAreaEmpty(glyphArea) {
            return 0 === glyphArea.width || 0 === glyphArea.height;
        }
        function fontFamily2FontFamilyName(fontFamily) {
            switch (fontFamily) {
              case g.FontFamily.Monospace:
                return "monospace";

              case g.FontFamily.Serif:
                return "serif";

              default:
                return "sans-serif";
            }
        }
        function quoteIfNotGeneric(name) {
            return -1 !== genericFontFamilyNames.indexOf(name) ? name : '"' + name + '"';
        }
        function fontFamily2CSSFontFamily(fontFamily) {
            return "number" == typeof fontFamily ? fontFamily2FontFamilyName(fontFamily) : "string" == typeof fontFamily ? quoteIfNotGeneric(fontFamily) : fontFamily.map(function(font) {
                return "string" == typeof font ? quoteIfNotGeneric(font) : fontFamily2FontFamilyName(font);
            }).join(",");
        }
        var __extends = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            };
            return function(d, b) {
                function __() {
                    this.constructor = d;
                }
                extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
                new __());
            };
        }();
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), CanvasSurface_1 = require("./CanvasSurface"), genericFontFamilyNames = [ "serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui" ], GlyphFactory = function(_super) {
            function GlyphFactory(fontFamily, fontSize, baselineHeight, fontColor, strokeWidth, strokeColor, strokeOnly, fontWeight) {
                var _this = _super.call(this, fontFamily, fontSize, baselineHeight, fontColor, strokeWidth, strokeColor, strokeOnly, fontWeight) || this;
                _this._glyphAreas = {}, _this._cssFontFamily = fontFamily2CSSFontFamily(fontFamily);
                var fallbackFontFamilyName = fontFamily2FontFamilyName(g.FontFamily.SansSerif);
                return -1 === _this._cssFontFamily.indexOf(fallbackFontFamilyName) && (_this._cssFontFamily += "," + fallbackFontFamilyName), 
                _this._marginW = Math.ceil(.3 * _this.fontSize + _this.strokeWidth / 2), _this._marginH = Math.ceil(.3 * _this.fontSize + _this.strokeWidth / 2), 
                void 0 === GlyphFactory._environmentMinimumFontSize && (GlyphFactory._environmentMinimumFontSize = _this.measureMinimumFontSize()), 
                _this;
            }
            return __extends(GlyphFactory, _super), GlyphFactory.prototype.create = function(code) {
                var result, glyphArea = this._glyphAreas[code];
                return glyphArea || (result = createGlyphRenderedSurface(code, this.fontSize, this._cssFontFamily, this.baselineHeight, this._marginW, this._marginH, !0, this.fontColor, this.strokeWidth, this.strokeColor, this.strokeOnly, this.fontWeight), 
                glyphArea = calcGlyphArea(result.imageData), glyphArea.advanceWidth = result.advanceWidth, 
                this._glyphAreas[code] = glyphArea), isGlyphAreaEmpty(glyphArea) ? (result && result.surface.destroy(), 
                new g.Glyph(code, 0, 0, 0, 0, 0, 0, glyphArea.advanceWidth, void 0, !0)) : (result || (result = createGlyphRenderedSurface(code, this.fontSize, this._cssFontFamily, this.baselineHeight, this._marginW, this._marginH, !1, this.fontColor, this.strokeWidth, this.strokeColor, this.strokeOnly, this.fontWeight)), 
                new g.Glyph(code, glyphArea.x, glyphArea.y, glyphArea.width, glyphArea.height, glyphArea.x - this._marginW, glyphArea.y - this._marginH, glyphArea.advanceWidth, result.surface, !0));
            }, GlyphFactory.prototype.measureMinimumFontSize = function() {
                var fontSize = 1, str = "M", canvas = document.createElement("canvas"), context = canvas.getContext("2d");
                context.textAlign = "left", context.textBaseline = "alphabetic", context.lineJoin = "bevel";
                var preWidth;
                context.font = fontSize + "px sans-serif";
                var width = context.measureText(str).width;
                do preWidth = width, fontSize += 1, context.font = fontSize + "px sans-serif", width = context.measureText(str).width; while (preWidth === width || fontSize > 50);
                return fontSize;
            }, GlyphFactory;
        }(g.GlyphFactory);
        exports.GlyphFactory = GlyphFactory;
    }, {
        "./CanvasSurface": 13,
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    16: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var RenderingHelper, g = require("@akashic/akashic-engine"), SurfaceFactory_1 = require("./SurfaceFactory");
        !function(RenderingHelper) {
            function toTextFromCompositeOperation(operation) {
                var operationText;
                switch (operation) {
                  case g.CompositeOperation.SourceAtop:
                    operationText = "source-atop";
                    break;

                  case g.CompositeOperation.Lighter:
                    operationText = "lighter";
                    break;

                  case g.CompositeOperation.Copy:
                    operationText = "copy";
                    break;

                  case g.CompositeOperation.ExperimentalSourceIn:
                    operationText = "source-in";
                    break;

                  case g.CompositeOperation.ExperimentalSourceOut:
                    operationText = "source-out";
                    break;

                  case g.CompositeOperation.ExperimentalDestinationAtop:
                    operationText = "destination-atop";
                    break;

                  case g.CompositeOperation.ExperimentalDestinationIn:
                    operationText = "destination-in";
                    break;

                  case g.CompositeOperation.DestinationOut:
                    operationText = "destination-out";
                    break;

                  case g.CompositeOperation.DestinationOver:
                    operationText = "destination-over";
                    break;

                  case g.CompositeOperation.Xor:
                    operationText = "xor";
                    break;

                  default:
                    operationText = "source-over";
                }
                return operationText;
            }
            function drawSystemTextByContext2D(context, text, x, y, maxWidth, fontSize, textAlign, textBaseline, textColor, fontFamily, strokeWidth, strokeColor, strokeOnly) {
                var fontFamilyValue, textAlignValue, textBaselineValue;
                switch (context.save(), fontFamily) {
                  case g.FontFamily.Monospace:
                    fontFamilyValue = "monospace";
                    break;

                  case g.FontFamily.Serif:
                    fontFamilyValue = "serif";
                    break;

                  default:
                    fontFamilyValue = "sans-serif";
                }
                switch (context.font = fontSize + "px " + fontFamilyValue, textAlign) {
                  case g.TextAlign.Right:
                    textAlignValue = "right";
                    break;

                  case g.TextAlign.Center:
                    textAlignValue = "center";
                    break;

                  default:
                    textAlignValue = "left";
                }
                switch (context.textAlign = textAlignValue, textBaseline) {
                  case g.TextBaseline.Top:
                    textBaselineValue = "top";
                    break;

                  case g.TextBaseline.Middle:
                    textBaselineValue = "middle";
                    break;

                  case g.TextBaseline.Bottom:
                    textBaselineValue = "bottom";
                    break;

                  default:
                    textBaselineValue = "alphabetic";
                }
                context.textBaseline = textBaselineValue, context.lineJoin = "bevel", strokeWidth > 0 && (context.lineWidth = strokeWidth, 
                context.strokeStyle = strokeColor, "undefined" == typeof maxWidth ? context.strokeText(text, x, y) : context.strokeText(text, x, y, maxWidth)), 
                strokeOnly || (context.fillStyle = textColor, "undefined" == typeof maxWidth ? context.fillText(text, x, y) : context.fillText(text, x, y, maxWidth)), 
                context.restore();
            }
            function createPrimarySurface(width, height, rendererCandidates) {
                return SurfaceFactory_1.SurfaceFactory.createPrimarySurface(width, height, rendererCandidates);
            }
            function createBackSurface(width, height, platform, rendererCandidates) {
                return SurfaceFactory_1.SurfaceFactory.createBackSurface(width, height, platform, rendererCandidates);
            }
            RenderingHelper.toTextFromCompositeOperation = toTextFromCompositeOperation, RenderingHelper.drawSystemTextByContext2D = drawSystemTextByContext2D, 
            RenderingHelper.createPrimarySurface = createPrimarySurface, RenderingHelper.createBackSurface = createBackSurface;
        }(RenderingHelper = exports.RenderingHelper || (exports.RenderingHelper = {}));
    }, {
        "./SurfaceFactory": 17,
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    17: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var SurfaceFactory, CanvasSurface_1 = require("./CanvasSurface");
        !function(SurfaceFactory) {
            function createPrimarySurface(width, height, rendererCandidates) {
                return new CanvasSurface_1.CanvasSurface(width, height);
            }
            function createBackSurface(width, height, platform, rendererCandidates) {
                return new CanvasSurface_1.CanvasSurface(width, height);
            }
            SurfaceFactory.createPrimarySurface = createPrimarySurface, SurfaceFactory.createBackSurface = createBackSurface;
        }(SurfaceFactory = exports.SurfaceFactory || (exports.SurfaceFactory = {}));
    }, {
        "./CanvasSurface": 13
    } ],
    18: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), InputAbstractHandler = (require("@akashic/akashic-pdi"), 
        function() {
            function InputAbstractHandler(inputView, disablePreventDefault) {
                if (Object.getPrototypeOf && Object.getPrototypeOf(this) === InputAbstractHandler.prototype) throw new Error("InputAbstractHandler is abstract and should not be directly instantiated");
                this.inputView = inputView, this.pointerEventLock = {}, this._xScale = 1, this._yScale = 1, 
                this._disablePreventDefault = !!disablePreventDefault, this.pointTrigger = new g.Trigger();
            }
            return InputAbstractHandler.isSupported = function() {
                return !1;
            }, InputAbstractHandler.prototype.start = function() {
                throw new Error("This method is abstract");
            }, InputAbstractHandler.prototype.stop = function() {
                throw new Error("This method is abstract");
            }, InputAbstractHandler.prototype.setScale = function(xScale, yScale) {
                void 0 === yScale && (yScale = xScale), this._xScale = xScale, this._yScale = yScale;
            }, InputAbstractHandler.prototype.pointDown = function(identifier, pagePosition) {
                this.pointTrigger.fire({
                    type: 0,
                    identifier: identifier,
                    offset: this.getOffsetFromEvent(pagePosition)
                }), this.pointerEventLock[identifier] = !0;
            }, InputAbstractHandler.prototype.pointMove = function(identifier, pagePosition) {
                this.pointerEventLock.hasOwnProperty(identifier + "") && this.pointTrigger.fire({
                    type: 1,
                    identifier: identifier,
                    offset: this.getOffsetFromEvent(pagePosition)
                });
            }, InputAbstractHandler.prototype.pointUp = function(identifier, pagePosition) {
                this.pointerEventLock.hasOwnProperty(identifier + "") && (this.pointTrigger.fire({
                    type: 2,
                    identifier: identifier,
                    offset: this.getOffsetFromEvent(pagePosition)
                }), delete this.pointerEventLock[identifier]);
            }, InputAbstractHandler.prototype.getOffsetFromEvent = function(e) {
                return {
                    x: e.offsetX,
                    y: e.offsetY
                };
            }, InputAbstractHandler.prototype.getScale = function() {
                return {
                    x: this._xScale,
                    y: this._yScale
                };
            }, InputAbstractHandler;
        }());
        exports.InputAbstractHandler = InputAbstractHandler;
    }, {
        "@akashic/akashic-engine": "@akashic/akashic-engine",
        "@akashic/akashic-pdi": 31
    } ],
    19: [ function(require, module, exports) {
        "use strict";
        var __extends = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            };
            return function(d, b) {
                function __() {
                    this.constructor = d;
                }
                extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
                new __());
            };
        }();
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var InputAbstractHandler_1 = require("./InputAbstractHandler"), MouseHandler = function(_super) {
            function MouseHandler(inputView, disablePreventDefault) {
                var _this = _super.call(this, inputView, disablePreventDefault) || this, identifier = 1;
                return _this.onMouseDown = function(e) {
                    0 === e.button && (_this.pointDown(identifier, e), window.addEventListener("mousemove", _this.onMouseMove, !1), 
                    window.addEventListener("mouseup", _this.onMouseUp, !1), _this._disablePreventDefault || (e.stopPropagation(), 
                    e.preventDefault()));
                }, _this.onMouseMove = function(e) {
                    _this.pointMove(identifier, e), _this._disablePreventDefault || (e.stopPropagation(), 
                    e.preventDefault());
                }, _this.onMouseUp = function(e) {
                    _this.pointUp(identifier, e), window.removeEventListener("mousemove", _this.onMouseMove, !1), 
                    window.removeEventListener("mouseup", _this.onMouseUp, !1), _this._disablePreventDefault || (e.stopPropagation(), 
                    e.preventDefault());
                }, _this;
            }
            return __extends(MouseHandler, _super), MouseHandler.isSupported = function() {
                return !0;
            }, MouseHandler.prototype.start = function() {
                this.inputView.addEventListener("mousedown", this.onMouseDown, !1);
            }, MouseHandler.prototype.stop = function() {
                this.inputView.removeEventListener("mousedown", this.onMouseDown, !1);
            }, MouseHandler;
        }(InputAbstractHandler_1.InputAbstractHandler);
        exports.MouseHandler = MouseHandler;
    }, {
        "./InputAbstractHandler": 18
    } ],
    20: [ function(require, module, exports) {
        "use strict";
        var __extends = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            };
            return function(d, b) {
                function __() {
                    this.constructor = d;
                }
                extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
                new __());
            };
        }();
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var MouseHandler_1 = require("./MouseHandler"), RuntimeInfo_1 = require("../RuntimeInfo"), TouchHandler = function(_super) {
            function TouchHandler(inputView, disablePreventDefault) {
                var _this = _super.call(this, inputView, disablePreventDefault) || this;
                return _this.onTouchDown = function(e) {
                    for (var touches = e.changedTouches, i = 0, len = touches.length; len > i; i++) {
                        var touch = touches[i];
                        _this.pointDown(touch.identifier, _this.convertToPagePosition(touch));
                    }
                    _this._disablePreventDefault || (e.stopPropagation(), e.preventDefault());
                }, _this.onTouchMove = function(e) {
                    for (var touches = e.changedTouches, i = 0, len = touches.length; len > i; i++) {
                        var touch = touches[i];
                        _this.pointMove(touch.identifier, _this.convertToPagePosition(touch));
                    }
                    _this._disablePreventDefault || (e.stopPropagation(), e.preventDefault());
                }, _this.onTouchUp = function(e) {
                    for (var touches = e.changedTouches, i = 0, len = touches.length; len > i; i++) {
                        var touch = touches[i];
                        _this.pointUp(touch.identifier, _this.convertToPagePosition(touch));
                    }
                    _this._disablePreventDefault || (e.stopPropagation(), e.preventDefault());
                }, _this;
            }
            return __extends(TouchHandler, _super), TouchHandler.isSupported = function() {
                return RuntimeInfo_1.RuntimeInfo.touchEnabled();
            }, TouchHandler.prototype.start = function() {
                _super.prototype.start.call(this), this.inputView.addEventListener("touchstart", this.onTouchDown), 
                this.inputView.addEventListener("touchmove", this.onTouchMove), this.inputView.addEventListener("touchend", this.onTouchUp);
            }, TouchHandler.prototype.stop = function() {
                _super.prototype.stop.call(this), this.inputView.removeEventListener("touchstart", this.onTouchDown), 
                this.inputView.removeEventListener("touchmove", this.onTouchMove), this.inputView.removeEventListener("touchend", this.onTouchUp);
            }, TouchHandler.prototype.convertToPagePosition = function(e) {
                var bounding = this.inputView.getBoundingClientRect(), scale = this.getScale();
                return {
                    offsetX: (e.pageX - Math.round(window.pageXOffset + bounding.left)) / scale.x,
                    offsetY: (e.pageY - Math.round(window.pageYOffset + bounding.top)) / scale.y
                };
            }, TouchHandler;
        }(MouseHandler_1.MouseHandler);
        exports.TouchHandler = TouchHandler;
    }, {
        "../RuntimeInfo": 7,
        "./MouseHandler": 19
    } ],
    21: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var AudioPluginManager = function() {
            function AudioPluginManager() {
                this._activePlugin = void 0;
            }
            return AudioPluginManager.prototype.getActivePlugin = function() {
                return void 0 === this._activePlugin ? null : this._activePlugin;
            }, AudioPluginManager.prototype.tryInstallPlugin = function(plugins) {
                var PluginConstructor = this.findFirstAvailablePlugin(plugins);
                return PluginConstructor ? (this._activePlugin = new PluginConstructor(), !0) : !1;
            }, AudioPluginManager.prototype.findFirstAvailablePlugin = function(plugins) {
                for (var i = 0, len = plugins.length; len > i; i++) {
                    var plugin = plugins[i];
                    if (plugin.isSupported()) return plugin;
                }
            }, AudioPluginManager;
        }();
        exports.AudioPluginManager = AudioPluginManager;
    }, {} ],
    22: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var audioPlugins = [];
        exports.AudioPluginRegistry = {
            addPlugin: function(plugin) {
                -1 === audioPlugins.indexOf(plugin) && audioPlugins.push(plugin);
            },
            getRegisteredAudioPlugins: function() {
                return audioPlugins;
            },
            clear: function() {
                audioPlugins = [];
            }
        };
    }, {} ],
    23: [ function(require, module, exports) {
        "use strict";
        var __extends = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            };
            return function(d, b) {
                function __() {
                    this.constructor = d;
                }
                extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
                new __());
            };
        }();
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), HTMLAudioAsset = function(_super) {
            function HTMLAudioAsset() {
                return null !== _super && _super.apply(this, arguments) || this;
            }
            return __extends(HTMLAudioAsset, _super), HTMLAudioAsset.prototype._load = function(loader) {
                var _this = this;
                if (null == this.path) return this.data = null, void setTimeout(function() {
                    return loader._onAssetLoad(_this);
                }, 0);
                var audio = new Audio(), startLoadingAudio = function(path, handlers) {
                    audio.autoplay = !1, audio.preload = "none", audio.src = path, _this._attachAll(audio, handlers), 
                    audio.preload = "auto", setAudioLoadInterval(audio, handlers), audio.load();
                }, handlers = {
                    success: function() {
                        _this._detachAll(audio, handlers), _this.data = audio, loader._onAssetLoad(_this), 
                        window.clearInterval(_this._intervalId);
                    },
                    error: function() {
                        _this._detachAll(audio, handlers), _this.data = audio, loader._onAssetError(_this, g.ExceptionFactory.createAssetLoadError("HTMLAudioAsset loading error")), 
                        window.clearInterval(_this._intervalId);
                    }
                }, setAudioLoadInterval = function(audio, handlers) {
                    _this._intervalCount = 0, _this._intervalId = window.setInterval(function() {
                        4 === audio.readyState ? handlers.success() : (++_this._intervalCount, 600 === _this._intervalCount && handlers.error());
                    }, 100);
                };
                if (".aac" === this.path.slice(-4) && -1 !== HTMLAudioAsset.supportedFormats.indexOf("mp4")) {
                    var altHandlers = {
                        success: handlers.success,
                        error: function() {
                            _this._detachAll(audio, altHandlers), window.clearInterval(_this._intervalId);
                            var altPath = _this.path.slice(0, _this.path.length - 4) + ".mp4";
                            startLoadingAudio(altPath, handlers);
                        }
                    };
                    return void startLoadingAudio(this.path, altHandlers);
                }
                startLoadingAudio(this.path, handlers);
            }, HTMLAudioAsset.prototype.cloneElement = function() {
                return this.data ? new Audio(this.data.src) : null;
            }, HTMLAudioAsset.prototype._assetPathFilter = function(path) {
                return -1 !== HTMLAudioAsset.supportedFormats.indexOf("ogg") ? g.PathUtil.addExtname(path, "ogg") : -1 !== HTMLAudioAsset.supportedFormats.indexOf("aac") ? g.PathUtil.addExtname(path, "aac") : null;
            }, HTMLAudioAsset.prototype._attachAll = function(audio, handlers) {
                handlers.success && audio.addEventListener("canplaythrough", handlers.success, !1), 
                handlers.error && (audio.addEventListener("stalled", handlers.error, !1), audio.addEventListener("error", handlers.error, !1), 
                audio.addEventListener("abort", handlers.error, !1));
            }, HTMLAudioAsset.prototype._detachAll = function(audio, handlers) {
                handlers.success && audio.removeEventListener("canplaythrough", handlers.success, !1), 
                handlers.error && (audio.removeEventListener("stalled", handlers.error, !1), audio.removeEventListener("error", handlers.error, !1), 
                audio.removeEventListener("abort", handlers.error, !1));
            }, HTMLAudioAsset;
        }(g.AudioAsset);
        exports.HTMLAudioAsset = HTMLAudioAsset;
    }, {
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    24: [ function(require, module, exports) {
        "use strict";
        var __extends = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            };
            return function(d, b) {
                function __() {
                    this.constructor = d;
                }
                extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
                new __());
            };
        }();
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), HTMLAudioPlayer = function(_super) {
            function HTMLAudioPlayer(system, manager) {
                var _this = _super.call(this, system) || this;
                return _this._manager = manager, _this._endedEventHandler = function() {
                    _this._onAudioEnded();
                }, _this._onPlayEventHandler = function() {
                    _this._onPlayEvent();
                }, _this._dummyDurationWaitTimer = null, _this;
            }
            return __extends(HTMLAudioPlayer, _super), HTMLAudioPlayer.prototype.play = function(asset) {
                this.currentAudio && this.stop();
                var audio = asset.cloneElement();
                audio ? (audio.volume = this.volume * this._system.volume * this._manager.getMasterVolume(), 
                audio.play(), audio.loop = asset.loop, audio.addEventListener("ended", this._endedEventHandler, !1), 
                audio.addEventListener("play", this._onPlayEventHandler, !1), this._isWaitingPlayEvent = !0, 
                this._audioInstance = audio) : this._dummyDurationWaitTimer = setTimeout(this._endedEventHandler, asset.duration), 
                _super.prototype.play.call(this, asset);
            }, HTMLAudioPlayer.prototype.stop = function() {
                this.currentAudio && (this._clearEndedEventHandler(), this._audioInstance && (this._isWaitingPlayEvent ? this._isStopRequested = !0 : (this._audioInstance.pause(), 
                this._audioInstance = null)), _super.prototype.stop.call(this));
            }, HTMLAudioPlayer.prototype.changeVolume = function(volume) {
                this._audioInstance && (this._audioInstance.volume = volume * this._system.volume * this._manager.getMasterVolume()), 
                _super.prototype.changeVolume.call(this, volume);
            }, HTMLAudioPlayer.prototype.notifyMasterVolumeChanged = function() {
                this._audioInstance && (this._audioInstance.volume = this.volume * this._system.volume * this._manager.getMasterVolume());
            }, HTMLAudioPlayer.prototype._onAudioEnded = function() {
                this._clearEndedEventHandler(), _super.prototype.stop.call(this);
            }, HTMLAudioPlayer.prototype._clearEndedEventHandler = function() {
                this._audioInstance && this._audioInstance.removeEventListener("ended", this._endedEventHandler, !1), 
                null != this._dummyDurationWaitTimer && (clearTimeout(this._dummyDurationWaitTimer), 
                this._dummyDurationWaitTimer = null);
            }, HTMLAudioPlayer.prototype._onPlayEvent = function() {
                this._isWaitingPlayEvent && (this._isWaitingPlayEvent = !1, this._isStopRequested && (this._isStopRequested = !1, 
                this._audioInstance.pause(), this._audioInstance = null));
            }, HTMLAudioPlayer;
        }(g.AudioPlayer);
        exports.HTMLAudioPlayer = HTMLAudioPlayer;
    }, {
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    25: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var HTMLAudioAsset_1 = require("./HTMLAudioAsset"), HTMLAudioPlayer_1 = require("./HTMLAudioPlayer"), HTMLAudioPlugin = function() {
            function HTMLAudioPlugin() {
                this._supportedFormats = this._detectSupportedFormats(), HTMLAudioAsset_1.HTMLAudioAsset.supportedFormats = this.supportedFormats;
            }
            return HTMLAudioPlugin.isSupported = function() {
                var audioElement = document.createElement("audio"), result = !1;
                try {
                    result = void 0 !== audioElement.canPlayType;
                } catch (e) {}
                return result;
            }, Object.defineProperty(HTMLAudioPlugin.prototype, "supportedFormats", {
                get: function() {
                    return this._supportedFormats;
                },
                set: function(supportedFormats) {
                    this._supportedFormats = supportedFormats, HTMLAudioAsset_1.HTMLAudioAsset.supportedFormats = supportedFormats;
                },
                enumerable: !0,
                configurable: !0
            }), HTMLAudioPlugin.prototype.createAsset = function(id, assetPath, duration, system, loop, hint) {
                return new HTMLAudioAsset_1.HTMLAudioAsset(id, assetPath, duration, system, loop, hint);
            }, HTMLAudioPlugin.prototype.createPlayer = function(system, manager) {
                return new HTMLAudioPlayer_1.HTMLAudioPlayer(system, manager);
            }, HTMLAudioPlugin.prototype._detectSupportedFormats = function() {
                if (-1 !== navigator.userAgent.indexOf("Edge/")) return [ "aac" ];
                var audioElement = document.createElement("audio"), supportedFormats = [];
                try {
                    for (var supportedExtensions = [ "ogg", "aac", "mp4" ], i = 0, len = supportedExtensions.length; len > i; i++) {
                        var ext = supportedExtensions[i], canPlay = audioElement.canPlayType("audio/" + ext), supported = "no" !== canPlay && "" !== canPlay;
                        supported && supportedFormats.push(ext);
                    }
                } catch (e) {}
                return supportedFormats;
            }, HTMLAudioPlugin;
        }();
        exports.HTMLAudioPlugin = HTMLAudioPlugin;
    }, {
        "./HTMLAudioAsset": 23,
        "./HTMLAudioPlayer": 24
    } ],
    26: [ function(require, module, exports) {
        "use strict";
        var __extends = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            };
            return function(d, b) {
                function __() {
                    this.constructor = d;
                }
                extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
                new __());
            };
        }();
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), XHRLoader_1 = require("../../utils/XHRLoader"), helper = require("./WebAudioHelper"), WebAudioAsset = function(_super) {
            function WebAudioAsset() {
                return null !== _super && _super.apply(this, arguments) || this;
            }
            return __extends(WebAudioAsset, _super), WebAudioAsset.prototype._load = function(loader) {
                var _this = this;
                if (null == this.path) return this.data = null, void setTimeout(function() {
                    return loader._onAssetLoad(_this);
                }, 0);
                var successHandler = function(decodedAudio) {
                    _this.data = decodedAudio, loader._onAssetLoad(_this);
                }, errorHandler = function() {
                    loader._onAssetError(_this, g.ExceptionFactory.createAssetLoadError("WebAudioAsset unknown loading error"));
                }, onLoadArrayBufferHandler = function(response) {
                    var audioContext = helper.getAudioContext();
                    audioContext.decodeAudioData(response, successHandler, errorHandler);
                }, xhrLoader = new XHRLoader_1.XHRLoader(), loadArrayBuffer = function(path, onSuccess, onFailed) {
                    xhrLoader.getArrayBuffer(path, function(error, response) {
                        error ? onFailed(error) : onSuccess(response);
                    });
                };
                return ".aac" === this.path.slice(-4) ? void loadArrayBuffer(this.path, onLoadArrayBufferHandler, function(error) {
                    var altPath = _this.path.slice(0, _this.path.length - 4) + ".mp4";
                    loadArrayBuffer(altPath, function(response) {
                        _this.path = altPath, onLoadArrayBufferHandler(response);
                    }, errorHandler);
                }) : void loadArrayBuffer(this.path, onLoadArrayBufferHandler, errorHandler);
            }, WebAudioAsset.prototype._assetPathFilter = function(path) {
                return -1 !== WebAudioAsset.supportedFormats.indexOf("ogg") ? g.PathUtil.addExtname(path, "ogg") : -1 !== WebAudioAsset.supportedFormats.indexOf("aac") ? g.PathUtil.addExtname(path, "aac") : null;
            }, WebAudioAsset.supportedFormats = [], WebAudioAsset;
        }(g.AudioAsset);
        exports.WebAudioAsset = WebAudioAsset;
    }, {
        "../../utils/XHRLoader": 30,
        "./WebAudioHelper": 27,
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    27: [ function(require, module, exports) {
        "use strict";
        var WebAudioHelper, AudioContext = window.AudioContext || window.webkitAudioContext, singleContext = null;
        !function(WebAudioHelper) {
            function getAudioContext() {
                return singleContext || (singleContext = new AudioContext(), WebAudioHelper._workAroundSafari()), 
                singleContext;
            }
            function createGainNode(context) {
                return context.createGain ? context.createGain() : context.createGainNode();
            }
            function createBufferNode(context) {
                var sourceNode = context.createBufferSource();
                return sourceNode.start ? sourceNode : (sourceNode.start = sourceNode.noteOn, sourceNode.stop = sourceNode.noteOff, 
                sourceNode);
            }
            function _workAroundSafari() {
                document.addEventListener("touchstart", function touchInitializeHandler() {
                    document.removeEventListener("touchstart", touchInitializeHandler), singleContext.createBufferSource().start(0);
                }, !0);
            }
            WebAudioHelper.getAudioContext = getAudioContext, WebAudioHelper.createGainNode = createGainNode, 
            WebAudioHelper.createBufferNode = createBufferNode, WebAudioHelper._workAroundSafari = _workAroundSafari;
        }(WebAudioHelper || (WebAudioHelper = {})), module.exports = WebAudioHelper;
    }, {} ],
    28: [ function(require, module, exports) {
        "use strict";
        var __extends = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            };
            return function(d, b) {
                function __() {
                    this.constructor = d;
                }
                extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
                new __());
            };
        }();
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), helper = require("./WebAudioHelper"), WebAudioPlayer = function(_super) {
            function WebAudioPlayer(system, manager) {
                var _this = _super.call(this, system) || this;
                return _this._audioContext = helper.getAudioContext(), _this._manager = manager, 
                _this._gainNode = helper.createGainNode(_this._audioContext), _this._gainNode.connect(_this._audioContext.destination), 
                _this._sourceNode = void 0, _this._dummyDurationWaitTimer = null, _this._endedEventHandler = function() {
                    _this._onAudioEnded();
                }, _this;
            }
            return __extends(WebAudioPlayer, _super), WebAudioPlayer.prototype.changeVolume = function(volume) {
                this._gainNode.gain.value = volume * this._system.volume * this._manager.getMasterVolume(), 
                _super.prototype.changeVolume.call(this, volume);
            }, WebAudioPlayer.prototype.play = function(asset) {
                if (this.currentAudio && this.stop(), asset.data) {
                    var bufferNode = helper.createBufferNode(this._audioContext);
                    bufferNode.loop = asset.loop, bufferNode.buffer = asset.data, this._gainNode.gain.value = this.volume * this._system.volume * this._manager.getMasterVolume(), 
                    bufferNode.connect(this._gainNode), this._sourceNode = bufferNode, this._sourceNode.onended = this._endedEventHandler, 
                    this._sourceNode.start(0);
                } else this._dummyDurationWaitTimer = setTimeout(this._endedEventHandler, asset.duration);
                _super.prototype.play.call(this, asset);
            }, WebAudioPlayer.prototype.stop = function() {
                this.currentAudio && (this._clearEndedEventHandler(), this._sourceNode && this._sourceNode.stop(0), 
                _super.prototype.stop.call(this));
            }, WebAudioPlayer.prototype.notifyMasterVolumeChanged = function() {
                this._gainNode.gain.value = this.volume * this._system.volume * this._manager.getMasterVolume();
            }, WebAudioPlayer.prototype._onAudioEnded = function() {
                this._clearEndedEventHandler(), _super.prototype.stop.call(this);
            }, WebAudioPlayer.prototype._clearEndedEventHandler = function() {
                this._sourceNode && (this._sourceNode.onended = null), null != this._dummyDurationWaitTimer && (clearTimeout(this._dummyDurationWaitTimer), 
                this._dummyDurationWaitTimer = null);
            }, WebAudioPlayer;
        }(g.AudioPlayer);
        exports.WebAudioPlayer = WebAudioPlayer;
    }, {
        "./WebAudioHelper": 27,
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    29: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var WebAudioAsset_1 = require("./WebAudioAsset"), WebAudioPlayer_1 = require("./WebAudioPlayer"), WebAudioPlugin = function() {
            function WebAudioPlugin() {
                this.supportedFormats = this._detectSupportedFormats();
            }
            return WebAudioPlugin.isSupported = function() {
                return "AudioContext" in window ? !0 : "webkitAudioContext" in window ? !0 : !1;
            }, Object.defineProperty(WebAudioPlugin.prototype, "supportedFormats", {
                get: function() {
                    return this._supportedFormats;
                },
                set: function(supportedFormats) {
                    this._supportedFormats = supportedFormats, WebAudioAsset_1.WebAudioAsset.supportedFormats = supportedFormats;
                },
                enumerable: !0,
                configurable: !0
            }), WebAudioPlugin.prototype.createAsset = function(id, assetPath, duration, system, loop, hint) {
                return new WebAudioAsset_1.WebAudioAsset(id, assetPath, duration, system, loop, hint);
            }, WebAudioPlugin.prototype.createPlayer = function(system, manager) {
                return new WebAudioPlayer_1.WebAudioPlayer(system, manager);
            }, WebAudioPlugin.prototype._detectSupportedFormats = function() {
                if (-1 !== navigator.userAgent.indexOf("Edge/")) return [ "aac" ];
                var audioElement = document.createElement("audio"), supportedFormats = [];
                try {
                    for (var supportedExtensions = [ "ogg", "aac", "mp4" ], i = 0, len = supportedExtensions.length; len > i; i++) {
                        var ext = supportedExtensions[i], canPlay = audioElement.canPlayType("audio/" + ext), supported = "no" !== canPlay && "" !== canPlay;
                        supported && supportedFormats.push(ext);
                    }
                } catch (e) {}
                return supportedFormats;
            }, WebAudioPlugin;
        }();
        exports.WebAudioPlugin = WebAudioPlugin;
    }, {
        "./WebAudioAsset": 26,
        "./WebAudioPlayer": 28
    } ],
    30: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), XHRLoader = function() {
            function XHRLoader(options) {
                void 0 === options && (options = {}), this.timeout = options.timeout || 15e3;
            }
            return XHRLoader.prototype.get = function(url, callback) {
                this._getRequestObject({
                    url: url,
                    responseType: "text"
                }, callback);
            }, XHRLoader.prototype.getArrayBuffer = function(url, callback) {
                this._getRequestObject({
                    url: url,
                    responseType: "arraybuffer"
                }, callback);
            }, XHRLoader.prototype._getRequestObject = function(requestObject, callback) {
                var request = new XMLHttpRequest();
                request.open("GET", requestObject.url, !0), request.responseType = requestObject.responseType, 
                request.timeout = this.timeout, request.addEventListener("timeout", function() {
                    callback(g.ExceptionFactory.createAssetLoadError("loading timeout"));
                }, !1), request.addEventListener("load", function() {
                    if (request.status >= 200 && request.status < 300) {
                        var response = "text" === requestObject.responseType ? request.responseText : request.response;
                        callback(null, response);
                    } else callback(g.ExceptionFactory.createAssetLoadError("loading error. status: " + request.status));
                }, !1), request.addEventListener("error", function() {
                    callback(g.ExceptionFactory.createAssetLoadError("loading error. status: " + request.status));
                }, !1), request.send();
            }, XHRLoader;
        }();
        exports.XHRLoader = XHRLoader;
    }, {
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    31: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
    }, {} ],
    "@akashic/pdi-browser": [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var Platform_1 = require("./Platform");
        exports.Platform = Platform_1.Platform;
        var ResourceFactory_1 = require("./ResourceFactory");
        exports.ResourceFactory = ResourceFactory_1.ResourceFactory;
        var g = require("@akashic/akashic-engine");
        exports.g = g;
        var AudioPluginRegistry_1 = require("./plugin/AudioPluginRegistry");
        exports.AudioPluginRegistry = AudioPluginRegistry_1.AudioPluginRegistry;
        var AudioPluginManager_1 = require("./plugin/AudioPluginManager");
        exports.AudioPluginManager = AudioPluginManager_1.AudioPluginManager;
        var HTMLAudioPlugin_1 = require("./plugin/HTMLAudioPlugin/HTMLAudioPlugin");
        exports.HTMLAudioPlugin = HTMLAudioPlugin_1.HTMLAudioPlugin;
        var WebAudioPlugin_1 = require("./plugin/WebAudioPlugin/WebAudioPlugin");
        exports.WebAudioPlugin = WebAudioPlugin_1.WebAudioPlugin;
    }, {
        "./Platform": 4,
        "./ResourceFactory": 6,
        "./plugin/AudioPluginManager": 21,
        "./plugin/AudioPluginRegistry": 22,
        "./plugin/HTMLAudioPlugin/HTMLAudioPlugin": 25,
        "./plugin/WebAudioPlugin/WebAudioPlugin": 29,
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ]
}, {}, []);</script>

<script>
if (! ("optionProps" in window)) {
	window.optionProps = {};
}
window.optionProps.magnify = false
window.g = require("@akashic/akashic-engine");
</script>
<script>
if (! ("gLocalAssetContainer" in window)) {
	window.gLocalAssetContainer = {};
}

			window.gLocalAssetContainer["game.json"] = "{%0A%09%22width%22: 800,%0A%09%22height%22: 600,%0A%09%22fps%22: 30,%0A%09%22main%22: %22./script/main.js%22,%0A%09%22assets%22: {%0A%09%09%22main%22: {%0A%09%09%09%22type%22: %22script%22,%0A%09%09%09%22path%22: %22script/main.js%22,%0A%09%09%09%22global%22: true%0A%09%09},%0A%09%09%22config%22: {%0A%09%09%09%22type%22: %22script%22,%0A%09%09%09%22path%22: %22script/config.js%22,%0A%09%09%09%22global%22: true%0A%09%09},%0A%09%09%22player%22: {%0A%09%09%09%22type%22: %22script%22,%0A%09%09%09%22path%22: %22script/player.js%22,%0A%09%09%09%22global%22: true%0A%09%09},%0A%09%09%22slot%22: {%0A%09%09%09%22type%22: %22script%22,%0A%09%09%09%22path%22: %22script/slot.js%22,%0A%09%09%09%22global%22: true%0A%09%09},%0A%09%09%22nataslot_reel%22: {%0A%09%09%09%22type%22: %22image%22,%0A%09%09%09%22width%22: 512,%0A%09%09%09%22height%22: 199,%0A%09%09%09%22path%22: %22image/nataslot_reel.png%22%0A%09%09},%0A%09%09%22nataslot_line0_0%22: {%0A%09%09%09%22type%22: %22image%22,%0A%09%09%09%22width%22: 200,%0A%09%09%09%22height%22: 800,%0A%09%09%09%22path%22: %22image/nataslot_line0_0.png%22%0A%09%09},%0A%09%09%22nataslot_line0_1%22: {%0A%09%09%09%22type%22: %22image%22,%0A%09%09%09%22width%22: 200,%0A%09%09%09%22height%22: 800,%0A%09%09%09%22path%22: %22image/nataslot_line0_1.png%22%0A%09%09},%0A%09%09%22nataslot_line0_2%22: {%0A%09%09%09%22type%22: %22image%22,%0A%09%09%09%22width%22: 200,%0A%09%09%09%22height%22: 800,%0A%09%09%09%22path%22: %22image/nataslot_line0_2.png%22%0A%09%09},%0A%09%09%22nataslot_line0_3%22: {%0A%09%09%09%22type%22: %22image%22,%0A%09%09%09%22width%22: 200,%0A%09%09%09%22height%22: 800,%0A%09%09%09%22path%22: %22image/nataslot_line0_3.png%22%0A%09%09},%0A%09%09%22nataslot_line0_4%22: {%0A%09%09%09%22type%22: %22image%22,%0A%09%09%09%22width%22: 200,%0A%09%09%09%22height%22: 800,%0A%09%09%09%22path%22: %22image/nataslot_line0_4.png%22%0A%09%09},%0A%09%09%22nataslot_line1_0%22: {%0A%09%09%09%22type%22: %22image%22,%0A%09%09%09%22width%22: 200,%0A%09%09%09%22height%22: 800,%0A%09%09%09%22path%22: %22image/nataslot_line1_0.png%22%0A%09%09},%0A%09%09%22nataslot_line1_1%22: {%0A%09%09%09%22type%22: %22image%22,%0A%09%09%09%22width%22: 200,%0A%09%09%09%22height%22: 800,%0A%09%09%09%22path%22: %22image/nataslot_line1_1.png%22%0A%09%09},%0A%09%09%22nataslot_line1_2%22: {%0A%09%09%09%22type%22: %22image%22,%0A%09%09%09%22width%22: 200,%0A%09%09%09%22height%22: 800,%0A%09%09%09%22path%22: %22image/nataslot_line1_2.png%22%0A%09%09},%0A%09%09%22nataslot_line1_3%22: {%0A%09%09%09%22type%22: %22image%22,%0A%09%09%09%22width%22: 200,%0A%09%09%09%22height%22: 800,%0A%09%09%09%22path%22: %22image/nataslot_line1_3.png%22%0A%09%09},%0A%09%09%22nataslot_line1_4%22: {%0A%09%09%09%22type%22: %22image%22,%0A%09%09%09%22width%22: 200,%0A%09%09%09%22height%22: 800,%0A%09%09%09%22path%22: %22image/nataslot_line1_4.png%22%0A%09%09},%0A%09%09%22nataslot_line2_0%22: {%0A%09%09%09%22type%22: %22image%22,%0A%09%09%09%22width%22: 200,%0A%09%09%09%22height%22: 800,%0A%09%09%09%22path%22: %22image/nataslot_line2_0.png%22%0A%09%09},%0A%09%09%22nataslot_line2_1%22: {%0A%09%09%09%22type%22: %22image%22,%0A%09%09%09%22width%22: 200,%0A%09%09%09%22height%22: 800,%0A%09%09%09%22path%22: %22image/nataslot_line2_1.png%22%0A%09%09},%0A%09%09%22nataslot_line2_2%22: {%0A%09%09%09%22type%22: %22image%22,%0A%09%09%09%22width%22: 200,%0A%09%09%09%22height%22: 800,%0A%09%09%09%22path%22: %22image/nataslot_line2_2.png%22%0A%09%09},%0A%09%09%22nataslot_line2_3%22: {%0A%09%09%09%22type%22: %22image%22,%0A%09%09%09%22width%22: 200,%0A%09%09%09%22height%22: 800,%0A%09%09%09%22path%22: %22image/nataslot_line2_3.png%22%0A%09%09},%0A%09%09%22nataslot_line2_4%22: {%0A%09%09%09%22type%22: %22image%22,%0A%09%09%09%22width%22: 200,%0A%09%09%09%22height%22: 800,%0A%09%09%09%22path%22: %22image/nataslot_line2_4.png%22%0A%09%09},%0A%09%09%22nataslot_bg%22: {%0A%09%09%09%22type%22: %22image%22,%0A%09%09%09%22width%22: 1920,%0A%09%09%09%22height%22: 1280,%0A%09%09%09%22path%22: %22image/nataslot_bg.jpg%22%0A%09%09},%0A%09%09%22start_button%22: {%0A%09%09%09%22type%22: %22image%22,%0A%09%09%09%22width%22: 169,%0A%09%09%09%22height%22: 89,%0A%09%09%09%22path%22: %22image/start_button.png%22%0A%09%09},%0A%09%09%22stop_button%22: {%0A%09%09%09%22type%22: %22image%22,%0A%09%09%09%22width%22: 111,%0A%09%09%09%22height%22: 98,%0A%09%09%09%22path%22: %22image/stop_button.png%22%0A%09%09},%0A%09%09%22main_bgm%22: {%0A%09%09%09%22type%22: %22audio%22,%0A%09%09%09%22path%22: %22audio/main_bgm%22,%0A%09%09%09%22systemId%22: %22music%22,%0A%09%09%09%22duration%22: 24000%0A%09%09},%0A%09%09%22hit_se%22: {%0A%09%09%09%22type%22: %22audio%22,%0A%09%09%09%22path%22: %22audio/hit_se%22,%0A%09%09%09%22systemId%22: %22sound%22,%0A%09%09%09%22duration%22: 1057%0A%09%09},%0A%09%09%22start_se%22: {%0A%09%09%09%22type%22: %22audio%22,%0A%09%09%09%22path%22: %22audio/start_se%22,%0A%09%09%09%22systemId%22: %22sound%22,%0A%09%09%09%22duration%22: 1626%0A%09%09},%0A%09%09%22stop_se%22: {%0A%09%09%09%22type%22: %22audio%22,%0A%09%09%09%22path%22: %22audio/stop_se%22,%0A%09%09%09%22systemId%22: %22sound%22,%0A%09%09%09%22duration%22: 575%0A%09%09},%0A%09%09%22DynamicFontRepository%22: {%0A%09%09%09%22type%22: %22script%22,%0A%09%09%09%22path%22: %22script/repository/DynamicFontRepository.js%22,%0A%09%09%09%22global%22: true%0A%09%09},%0A%09%09%22nata_mu1%22: {%0A%09%09%09%22type%22: %22image%22,%0A%09%09%09%22width%22: 300,%0A%09%09%09%22height%22: 300,%0A%09%09%09%22path%22: %22image/nata_mu1.png%22%0A%09%09},%0A%09%09%22nata_mu2%22: {%0A%09%09%09%22type%22: %22image%22,%0A%09%09%09%22width%22: 300,%0A%09%09%09%22height%22: 300,%0A%09%09%09%22path%22: %22image/nata_mu2.png%22%0A%09%09},%0A%09%09%22nata_muri%22: {%0A%09%09%09%22type%22: %22image%22,%0A%09%09%09%22width%22: 300,%0A%09%09%09%22height%22: 300,%0A%09%09%09%22path%22: %22image/nata_muri.png%22%0A%09%09},%0A%09%09%22nata_suki%22: {%0A%09%09%09%22type%22: %22image%22,%0A%09%09%09%22width%22: 300,%0A%09%09%09%22height%22: 300,%0A%09%09%09%22path%22: %22image/nata_suki.png%22%0A%09%09},%0A%09%09%22nata_sushi%22: {%0A%09%09%09%22type%22: %22image%22,%0A%09%09%09%22width%22: 300,%0A%09%09%09%22height%22: 300,%0A%09%09%09%22path%22: %22image/nata_sushi.png%22%0A%09%09},%0A%09%09%22nata_toutoi1%22: {%0A%09%09%09%22type%22: %22image%22,%0A%09%09%09%22width%22: 300,%0A%09%09%09%22height%22: 300,%0A%09%09%09%22path%22: %22image/nata_toutoi1.png%22%0A%09%09},%0A%09%09%22nata_toutoi2%22: {%0A%09%09%09%22type%22: %22image%22,%0A%09%09%09%22width%22: 300,%0A%09%09%09%22height%22: 300,%0A%09%09%09%22path%22: %22image/nata_toutoi2.png%22%0A%09%09}%0A%09},%0A%09%22environment%22: {%0A%09%09%22sandbox-runtime%22: %222%22%0A%09}%0A}";
				window.gLocalAssetContainer["main"] = function(g) {
			(function(exports, require, module, __filename, __dirname) {
"use strict";
var slot_1 = require("./slot");
var config_1 = require("./config");
var player_1 = require("./player");
var DynamicFontRepository_1 = require("./repository/DynamicFontRepository");
module.exports = function (param) {
    var scene = new g.Scene({
        game: g.game,
        assetIds: [
            "nataslot_line0_0",
            "nataslot_line0_1",
            "nataslot_line0_2",
            "nataslot_line0_3",
            "nataslot_line0_4",
            "nataslot_line1_0",
            "nataslot_line1_1",
            "nataslot_line1_2",
            "nataslot_line1_3",
            "nataslot_line1_4",
            "nataslot_line2_0",
            "nataslot_line2_1",
            "nataslot_line2_2",
            "nataslot_line2_3",
            "nataslot_line2_4",
            "nataslot_reel",
            "nata_mu1",
            "nata_mu2",
            "nata_muri",
            "nata_suki",
            "nata_sushi",
            "nata_toutoi1",
            "nata_toutoi2",
            "nataslot_bg",
            "start_button",
            "stop_button",
            "main_bgm",
            "hit_se",
            "start_se",
            "stop_se"
        ]
    });
    scene.loaded.add(function () {
        // フォントの生成
        var playerFont = new g.DynamicFont({
            game: scene.game,
            fontFamily: g.FontFamily.Monospace,
            size: config_1.config.game.player.label.size
        });
        DynamicFontRepository_1.DynamicFontRepository.instance.setDynamicFont("player", playerFont);
        // 背景画像
        var bgSprite = new g.Sprite({
            scene: scene,
            src: scene.assets["nataslot_bg"],
            width: g.game.width,
            height: g.game.height,
            srcWidth: 1920,
            srcHeight: 1280,
            x: 0,
            y: 0
        });
        scene.append(bgSprite);
        // ナターリア画像
        var nataliaFaceSpriteKeys = [
            "nata_mu1",
            "nata_mu2",
            "nata_muri",
            "nata_suki",
            "nata_sushi",
            "nata_toutoi1",
            "nata_toutoi2",
        ];
        var nataliaFaceSprites = {};
        nataliaFaceSpriteKeys.forEach(function (key) {
            nataliaFaceSprites[key] = new g.Sprite({
                scene: scene,
                src: scene.assets[key],
                width: config_1.config.game.player.character.width,
                height: config_1.config.game.player.character.height,
                srcWidth: 300,
                srcHeight: 300,
                x: config_1.config.game.player.character.x,
                y: config_1.config.game.player.character.y
            });
        });
        var player = new player_1.Player(nataliaFaceSprites);
        scene.append(player.charaSprite);
        scene.append(player.getMoneyLabel(scene));
        // リール画像
        var reelSprite = new g.Sprite({
            scene: scene,
            src: scene.assets["nataslot_reel"],
            width: config_1.config.game.slot.reel.width,
            height: config_1.config.game.slot.reel.height,
            srcWidth: 512,
            srcHeight: 199,
            x: config_1.config.game.slot.reel.x,
            y: config_1.config.game.slot.reel.y
        });
        scene.append(reelSprite);
        // リール・スロットの生成
        var reels = [];
        var _loop_1 = function (i) {
            var pane = new g.Pane({
                scene: scene,
                width: config_1.config.game.slot.reel.pane.width,
                height: config_1.config.game.slot.reel.pane.height,
                x: config_1.config.game.slot.reel.x + config_1.config.game.slot.reel.pane.dx + i * config_1.config.game.slot.reel.pane.intervalX,
                y: config_1.config.game.slot.reel.y + config_1.config.game.slot.reel.pane.dy
            });
            var sprites = [0, 1, 2, 3, 4].map(function (num) {
                var imageKey = "nataslot_line" + i + "_" + num;
                return new g.Sprite({
                    scene: scene,
                    src: scene.assets[imageKey],
                    width: config_1.config.game.slot.reel.element.width,
                    height: config_1.config.game.slot.reel.element.height * config_1.config.game.slot.reel.element.count_per_set,
                    srcWidth: 200,
                    srcHeight: 800
                });
            });
            var reel = new slot_1.Reel(pane, sprites, i);
            scene.append(reel.image);
            reels.push(reel);
        };
        for (var i = 0; i < config_1.config.game.slot.reel.count; i++) {
            _loop_1(i);
        }
        var slot = new slot_1.Slot(reels);
        // ボタン画像
        var startButtonSprite = new g.Sprite({
            scene: scene,
            src: scene.assets["start_button"],
            width: config_1.config.game.slot.button.start.width,
            height: config_1.config.game.slot.button.start.height,
            x: config_1.config.game.slot.button.start.x,
            y: config_1.config.game.slot.button.start.y,
            touchable: true
        });
        startButtonSprite.pointUp.add(function () {
            // TODO ボタン押したらBETとスロットスタート同時にやっているが、あとで分けたいね
            if (player.canContinue() && slot.canBet()) {
                // とりあえず自動でミニマムバイインを払う感じになっている
                player.addMoney(-1 * slot_1.Slot.getMinimumBuyIn());
                slot.addBetValue(slot_1.Slot.getMinimumBuyIn());
            }
            if (slot.canStart()) {
                scene.assets["start_se"].play();
                slot.start();
            }
        });
        scene.append(startButtonSprite);
        var stopButtonSprites = [0, 1, 2].map(function (index) {
            return new g.Sprite({
                scene: scene,
                src: scene.assets["stop_button"],
                width: config_1.config.game.slot.button.stop.width,
                height: config_1.config.game.slot.button.stop.height,
                x: config_1.config.game.slot.button.stop.x + index * config_1.config.game.slot.button.stop.intervalX,
                y: config_1.config.game.slot.button.stop.y,
                touchable: true
            });
        });
        var _loop_2 = function (index) {
            var sprite = stopButtonSprites[index];
            sprite.pointUp.add(function () {
                if (slot.canStop(index)) {
                    scene.assets["stop_se"].play();
                    slot.stop(index);
                }
            });
            scene.append(sprite);
        };
        for (var index = 0; index < stopButtonSprites.length; index++) {
            _loop_2(index);
        }
        scene.update.add(function () {
            slot.spin();
            if (slot.isComplete()) {
                // TODO お金が増えたエフェクトと演出
                player.addMoney(slot.calculateScore());
                slot.refresh();
            }
            // 表情変化 TODO: なんかRepositoryクラスとかで管理したい
            if (player.currentCharaStatus !== "nata_muri" && !player.canContinue()) {
                player.changeFaceSprite(scene, "nata_muri");
            }
        });
        scene.assets["main_bgm"].play();
        // const url = "https://api.search.nicovideo.jp/api/v2/illust/contents/search?q=%E3%83%8A%E3%82%BF%E3%83%BC%E3%83%AA%E3%82%A2"
        // 	+ "&targets=tags&fields=title,description,tags,viewCounter,mylistCounter,commentCounter,thumbnailUrl"
        // 	+ "&_sort=-viewCounter&_context=imaslot";
        // const a = xhr({
        // 	"url": url,
        // 	"responseType": "json",
        // }).then((resoponse) => {
        // 	console.log(resoponse);
        // }).catch((e) => {
        // 	console.error(e);
        // });
    });
    g.game.pushScene(scene);
};

})(g.module.exports, g.module.require, g.module, g.filename, g.dirname);
		};
				window.gLocalAssetContainer["config"] = function(g) {
			(function(exports, require, module, __filename, __dirname) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.config = {
    game: {
        slot: {
            reel: {
                element: {
                    width: 165,
                    height: 165,
                    count_per_set: 5,
                    set_count: 5,
                    dy: -15
                },
                pane: {
                    width: 150,
                    height: 170,
                    dx: 18,
                    dy: 20,
                    intervalX: 165
                },
                width: 512,
                height: 199,
                x: 0,
                y: 20,
                count: 3
            },
            button: {
                start: {
                    x: 0,
                    y: 400,
                    width: 169,
                    height: 89
                },
                stop: {
                    x: 50,
                    y: 230,
                    intervalX: 160,
                    width: 111,
                    height: 98
                }
            }
        },
        player: {
            default_money: 20,
            character: {
                default_status: "nata_sushi",
                width: 200,
                height: 200,
                x: 556,
                y: 400
            },
            label: {
                x: 556,
                y: 360,
                size: 30
            }
        }
    }
};

})(g.module.exports, g.module.require, g.module, g.filename, g.dirname);
		};
				window.gLocalAssetContainer["player"] = function(g) {
			(function(exports, require, module, __filename, __dirname) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var config_1 = require("./config");
var DynamicFontRepository_1 = require("./repository/DynamicFontRepository");
var Player = /** @class */ (function () {
    function Player(charaSprites) {
        this._charaSprites = charaSprites;
        this._money = config_1.config.game.player.default_money;
        this._currentCharaStatus = config_1.config.game.player.character.default_status;
    }
    Player.prototype.canContinue = function () {
        return this._money > 0;
    };
    Object.defineProperty(Player.prototype, "currentCharaStatus", {
        get: function () {
            return this._currentCharaStatus;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Player.prototype, "charaSprite", {
        get: function () {
            return this._charaSprites[this._currentCharaStatus];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Player.prototype, "money", {
        get: function () {
            return this._money;
        },
        enumerable: true,
        configurable: true
    });
    Player.prototype.addMoney = function (money) {
        this._money += money;
        this.changeMoneyLabel(this._money);
    };
    Player.prototype.changeFaceSprite = function (scene, status) {
        scene.remove(this._charaSprites[this._currentCharaStatus]);
        this._currentCharaStatus = status;
        scene.append(this._charaSprites[this._currentCharaStatus]);
    };
    Player.prototype.getMoneyLabel = function (scene) {
        var font = DynamicFontRepository_1.DynamicFontRepository.instance.getDynamicFont("player");
        if (this._moneyLabel === undefined) {
            this._moneyLabel = new g.Label({
                scene: scene,
                text: "残チップ数：" + this._money,
                textColor: "white",
                font: font,
                fontSize: config_1.config.game.player.label.size,
                x: config_1.config.game.player.label.x,
                y: config_1.config.game.player.label.y
            });
        }
        return this._moneyLabel;
    };
    Player.prototype.changeMoneyLabel = function (money) {
        this._moneyLabel.text = "残チップ数：" + money;
        this._moneyLabel.invalidate();
    };
    return Player;
}());
exports.Player = Player;

})(g.module.exports, g.module.require, g.module, g.filename, g.dirname);
		};
				window.gLocalAssetContainer["slot"] = function(g) {
			(function(exports, require, module, __filename, __dirname) {
"use strict";
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var config_1 = require("./config");
var prise = 20;
var minimumBuyIn = 1;
var displayedIndex = 20;
var maxSpeed = 2000 / 30; // スロットのスピンの最大速度(フレーム単位)
var acceleration = maxSpeed / 45; // スロットのスピンの加速度
var minusAcceleration = maxSpeed / 30; // ストップボタン押された後のスロットのスピンの加速度
var lineElements = [
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24],
    [24, 22, 20, 18, 16, 14, 12, 10, 8, 6, 4, 2, 0, 23, 21, 19, 17, 15, 13, 11, 9, 7, 5, 3, 1],
    [4, 7, 10, 13, 16, 19, 22, 0, 3, 6, 9, 12, 15, 18, 21, 24, 2, 5, 8, 11, 14, 17, 20, 23, 1]
];
var Slot = /** @class */ (function () {
    function Slot(reels) {
        this._reels = [];
        this._reels = reels;
        this.betValue = 0;
        this.magnification = 0;
    }
    Slot.getMinimumBuyIn = function () {
        return minimumBuyIn;
    };
    Slot.prototype.addBetValue = function (value) {
        this.betValue += value;
    };
    Slot.prototype.canBet = function () {
        return this.magnification === 0;
    };
    Slot.prototype.canStart = function () {
        // 「倍率が0でないこと=スロット動かしている」と判断しているけど、個別にフラグを用意した方がいいかなぁ？？
        return this.betValue >= minimumBuyIn && this.magnification === 0;
    };
    Slot.prototype.start = function () {
        this.magnification = this.betValue;
        this.betValue = 0;
        this._reels.forEach(function (reel) {
            reel.allowSpin = true;
        });
    };
    Slot.prototype.spin = function () {
        this._reels.forEach(function (reel) {
            reel.spin();
        });
    };
    Slot.prototype.canStop = function (index) {
        return this._reels[index].isMaxSpeed();
    };
    Slot.prototype.stop = function (index) {
        this._reels[index].allowSpin = false;
    };
    // ゲームが終わったかどうか
    Slot.prototype.isComplete = function () {
        if (this.magnification === 0) {
            return false;
        }
        return this._reels.every(function (reel) {
            return reel.isStop();
        });
    };
    Slot.prototype.calculateScore = function () {
        // 1列のみ評価
        var currentNumber;
        console.log("calculate");
        try {
            for (var _a = __values(this._reels), _b = _a.next(); !_b.done; _b = _a.next()) {
                var reel = _b.value;
                console.log(reel.getCurrentNumber());
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_1) throw e_1.error; }
        }
        try {
            for (var _d = __values(this._reels), _e = _d.next(); !_e.done; _e = _d.next()) {
                var reel = _e.value;
                if (currentNumber === undefined) {
                    currentNumber = reel.getCurrentNumber();
                }
                else if (reel.getCurrentNumber() !== currentNumber) {
                    return 0;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_e && !_e.done && (_f = _d.return)) _f.call(_d);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return prise * this.magnification;
        var e_1, _c, e_2, _f;
    };
    Slot.prototype.refresh = function () {
        this.betValue = 0;
        this.magnification = 0;
    };
    return Slot;
}());
exports.Slot = Slot;
var Reel = /** @class */ (function () {
    function Reel(pane, sprites, index) {
        this._pane = pane;
        this._sprites = sprites;
        this._elements = lineElements[index];
        this._allowSpin = false;
        this._spinSpeed = 0;
        this._currentIndex = displayedIndex;
        this.initialize();
    }
    Object.defineProperty(Reel.prototype, "image", {
        get: function () {
            return this._pane;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Reel.prototype, "allowSpin", {
        set: function (allowSpin) {
            this._allowSpin = allowSpin;
        },
        enumerable: true,
        configurable: true
    });
    Reel.prototype.getCurrentNumber = function () {
        return this._elements[this._currentIndex];
    };
    Reel.prototype.spin = function () {
        var _this = this;
        this.updateSpeed();
        this._sprites.forEach(function (sprite) {
            sprite.y += _this._spinSpeed;
            if (sprite.y >= config_1.config.game.slot.reel.y + config_1.config.game.slot.reel.height) {
                sprite.y -= config_1.config.game.slot.reel.element.height * config_1.config.game.slot.reel.element.count_per_set * _this._sprites.length;
            }
            sprite.modified();
        });
        this.setCurrentIndex();
        // 位置の調整
        // TODO できれば調整もアニメーション付けたいけど手抜きでいきなりずらす
        if (this._spinSpeed === 0) {
            this.setYPlace();
        }
    };
    Reel.prototype.isStop = function () {
        return this._allowSpin === false && this._spinSpeed === 0;
    };
    Reel.prototype.isMaxSpeed = function () {
        return this._spinSpeed === maxSpeed;
    };
    Reel.prototype.initialize = function () {
        var _this = this;
        this.setYPlace();
        this._sprites.forEach(function (sprite) {
            _this._pane.append(sprite);
        });
    };
    Reel.prototype.setYPlace = function () {
        for (var i = 0; i < this._sprites.length; i++) {
            var sprite = this._sprites[i];
            sprite.y = config_1.config.game.slot.reel.element.dy
                + config_1.config.game.slot.reel.element.height * config_1.config.game.slot.reel.element.count_per_set * i
                - config_1.config.game.slot.reel.element.height * this._currentIndex;
            if (sprite.y >= config_1.config.game.slot.reel.pane.height) {
                sprite.y -= config_1.config.game.slot.reel.element.height * config_1.config.game.slot.reel.element.count_per_set * this._sprites.length;
            }
        }
    };
    Reel.prototype.updateSpeed = function () {
        if (this._allowSpin) {
            if (this._spinSpeed >= maxSpeed) {
                this._spinSpeed = maxSpeed;
            }
            else {
                this._spinSpeed += acceleration;
            }
        }
        else {
            if (this._spinSpeed <= 0) {
                this._spinSpeed = 0;
            }
            else {
                this._spinSpeed -= minusAcceleration;
            }
        }
    };
    Reel.prototype.setCurrentIndex = function () {
        for (var i = 0; i < this._sprites.length; i++) {
            var sprite = this._sprites[i];
            var elementCount = config_1.config.game.slot.reel.element.count_per_set;
            var min = (0.5 - elementCount) * config_1.config.game.slot.reel.element.height + config_1.config.game.slot.reel.element.dy;
            var max = config_1.config.game.slot.reel.element.height + config_1.config.game.slot.reel.element.dy;
            if (min <= sprite.y && sprite.y < max) {
                this._currentIndex = i * elementCount + elementCount - Math.ceil((sprite.y - min) / config_1.config.game.slot.reel.element.width);
                break;
            }
        }
    };
    return Reel;
}());
exports.Reel = Reel;

})(g.module.exports, g.module.require, g.module, g.filename, g.dirname);
		};
				window.gLocalAssetContainer["DynamicFontRepository"] = function(g) {
			(function(exports, require, module, __filename, __dirname) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var DynamicFontRepository = /** @class */ (function () {
    function DynamicFontRepository() {
        this.dynamicFontMap = {};
    }
    Object.defineProperty(DynamicFontRepository, "instance", {
        get: function () {
            if (DynamicFontRepository._repository === undefined) {
                this._repository = new DynamicFontRepository();
            }
            return DynamicFontRepository._repository;
        },
        enumerable: true,
        configurable: true
    });
    DynamicFontRepository.prototype.getDynamicFont = function (key) {
        return this.dynamicFontMap[key];
    };
    DynamicFontRepository.prototype.setDynamicFont = function (key, font) {
        this.dynamicFontMap[key] = font;
    };
    return DynamicFontRepository;
}());
exports.DynamicFontRepository = DynamicFontRepository;

})(g.module.exports, g.module.require, g.module, g.filename, g.dirname);
		};
	</script>

<script>
	var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var LocalScriptAsset = /** @class */ (function (_super) {
    __extends(LocalScriptAsset, _super);
    function LocalScriptAsset(id, path) {
        var _this = _super.call(this, id, path) || this;
        _this.func = window.gLocalAssetContainer[id]; // gLocalScriptContainer は index.ect 上のscriptタグ内で宣言されている 
        return _this;
    }
    LocalScriptAsset.prototype._load = function (loader) {
        var _this = this;
        if (this.func !== undefined) {
            setTimeout(function () {
                loader._onAssetLoad(_this);
            }, 0);
        }
        else {
            setTimeout(function () {
                loader._onAssetError(_this, g.ExceptionFactory.createAssetLoadError("can not load script asset"));
            }, 0);
        }
    };
    LocalScriptAsset.prototype.execute = function (execEnv) {
        this.func(execEnv);
        return execEnv.module.exports;
    };
    return LocalScriptAsset;
}(g.ScriptAsset));
	var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var LocalTextAsset = /** @class */ (function (_super) {
    __extends(LocalTextAsset, _super);
    function LocalTextAsset(id, path) {
        var _this = _super.call(this, id, path) || this;
        _this.data = decodeURIComponent(window.gLocalAssetContainer[id]);
        return _this;
    }
    LocalTextAsset.prototype._load = function (loader) {
        var _this = this;
        if (this.data !== undefined) {
            setTimeout(function () {
                loader._onAssetLoad(_this);
            }, 0);
        }
        else {
            setTimeout(function () {
                loader._onAssetError(_this, g.ExceptionFactory.createAssetLoadError("can not load text asset"));
            }, 0);
        }
    };
    return LocalTextAsset;
}(g.TextAsset));
	!function(f) {
    if ("object" == typeof exports && "undefined" != typeof module) module.exports = f(); else if ("function" == typeof define && define.amd) define([], f); else {
        var g;
        g = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this, 
        g.gameStorage = f();
    }
}(function() {
    return function e(t, n, r) {
        function s(o, u) {
            if (!n[o]) {
                if (!t[o]) {
                    var a = "function" == typeof require && require;
                    if (!u && a) return a(o, !0);
                    if (i) return i(o, !0);
                    var f = new Error("Cannot find module '" + o + "'");
                    throw f.code = "MODULE_NOT_FOUND", f;
                }
                var l = n[o] = {
                    exports: {}
                };
                t[o][0].call(l.exports, function(e) {
                    var n = t[o][1][e];
                    return s(n ? n : e);
                }, l, l.exports, e, t, n, r);
            }
            return n[o].exports;
        }
        for (var i = "function" == typeof require && require, o = 0; o < r.length; o++) s(r[o]);
        return s;
    }({
        1: [ function(require, module, exports) {
            "use strict";
            var g = require("@akashic/akashic-engine"), validator = require("./validator"), KEY_PREFIX = "akst:", GameStorage = function() {
                function GameStorage(localStorage, metaData) {
                    this._localStorage = localStorage, this._metaData = metaData;
                }
                return GameStorage.prototype.set = function(key, value, option) {
                    validator.validateStorageKey(key), this.expandVariables(key);
                    var strKey = this.storageKeyToStringKey(key), current = this.getValue(strKey), newValue = null;
                    switch (key.region) {
                      case g.StorageRegion.Values:
                        newValue = this.createValuesValue(current, value, option);
                        break;

                      case g.StorageRegion.Counts:
                        newValue = this.createCountsValue(current, value, option);
                        break;

                      case g.StorageRegion.Scores:
                        newValue = this.createScoresValue(current, value, option);
                        break;

                      case g.StorageRegion.Slots:
                        throw new Error("Slots is not supported.");

                      default:
                        throw new Error("Unknown region.");
                    }
                    if (newValue) {
                        var finalValue = null, date = new Date();
                        finalValue = current ? {
                            data: newValue.data,
                            tag: newValue.tag,
                            createdAt: current.createdAt,
                            updatedAt: date
                        } : {
                            data: newValue.data,
                            tag: newValue.tag,
                            createdAt: date,
                            updatedAt: date
                        }, this.setValue(strKey, finalValue);
                    }
                }, GameStorage.prototype.load = function(readKeys) {
                    var _this = this, allValues = {};
                    Object.keys(this._localStorage).forEach(function(key) {
                        if (0 === key.indexOf(KEY_PREFIX)) {
                            var k = key.slice(KEY_PREFIX.length);
                            allValues[k] = _this.getValue(k);
                        }
                    });
                    var results = [];
                    return readKeys.forEach(function(readKey) {
                        validator.validateStorageReadKey(readKey), _this.expandVariables(readKey);
                        var values = [];
                        if (-1 !== readKey.regionKey.indexOf("*") || "*" === readKey.userId) {
                            var regexp = _this.storageReadKeyToRegExp(readKey);
                            Object.keys(allValues).forEach(function(key) {
                                if (regexp.test(key)) {
                                    var lv = allValues[key], sv = {
                                        data: lv.data,
                                        storageKey: _this.stringKeyToStorageKey(key)
                                    };
                                    null != lv.tag && (sv.tag = lv.tag), values.push(sv);
                                }
                            }), readKey.option && (void 0 !== readKey.option.valueOrder && _this.sortByValue(values, readKey.option.valueOrder), 
                            void 0 !== readKey.option.keyOrder && _this.sortByRegionKey(values, readKey.option.keyOrder));
                        } else {
                            var readStrKey = _this.storageKeyToStringKey(readKey), v = allValues[readStrKey];
                            if (v) {
                                var sv = {
                                    data: v.data,
                                    storageKey: {
                                        region: readKey.region,
                                        regionKey: readKey.regionKey,
                                        userId: readKey.userId,
                                        gameId: readKey.gameId
                                    }
                                };
                                null != v.tag && (sv.tag = v.tag), values.push(sv);
                            }
                        }
                        results.push(values);
                    }), results;
                }, GameStorage.prototype.clearAll = function() {
                    var _this = this;
                    Object.keys(this._localStorage).forEach(function(key) {
                        0 === key.indexOf(KEY_PREFIX) && _this._localStorage.removeItem(key);
                    });
                }, GameStorage.prototype.createValuesValue = function(current, value, option) {
                    if (!value) return null;
                    if (option && null != option.condition && null != option.comparisonValue && current && null != current.data) {
                        if (option.condition !== g.StorageCondition.Equal) throw new Error("Invalid condition.");
                        if (current.data !== option.comparisonValue) return null;
                    }
                    var result = {
                        data: value.data
                    };
                    return null != value.tag ? result.tag = value.tag : current && null != current.tag && (result.tag = current.tag), 
                    result;
                }, GameStorage.prototype.createScoresValue = function(current, value, option) {
                    if (!value) return null;
                    if (option && null != option.condition && null != option.comparisonValue && current && null != current.data) switch (option.condition) {
                      case g.StorageCondition.Equal:
                        if (current.data !== option.comparisonValue) return null;
                        break;

                      case g.StorageCondition.GreaterThan:
                        if (!(current.data > option.comparisonValue)) return null;
                        break;

                      case g.StorageCondition.LessThan:
                        if (!(current.data < option.comparisonValue)) return null;
                    }
                    var result = {
                        data: value.data
                    };
                    return null != value.tag ? result.tag = value.tag : current && null != current.tag && (result.tag = current.tag), 
                    result;
                }, GameStorage.prototype.createCountsIncrDecrValue = function(current, value, option) {
                    var result = {
                        data: 0
                    }, currentCount = 0;
                    if (current && (currentCount = Number(current.data)), null != option.condition && null != option.comparisonValue) switch (option.condition) {
                      case g.StorageCondition.Equal:
                        if (currentCount !== option.comparisonValue) return current ? null : result;
                        break;

                      case g.StorageCondition.GreaterThan:
                        if (!(currentCount > option.comparisonValue)) return current ? null : result;
                        break;

                      case g.StorageCondition.LessThan:
                        if (!(currentCount < option.comparisonValue)) return current ? null : result;
                    }
                    if (option.operation === g.StorageCountsOperation.Incr) value && null != value.data ? result.data = currentCount + Number(value.data) : result.data = currentCount + 1; else {
                        if (option.operation !== g.StorageCountsOperation.Decr) throw new Error("Unknown StorageCountsOperation");
                        value && null != value.data ? result.data = currentCount - Number(value.data) : result.data = currentCount - 1;
                    }
                    return value && null != value.tag ? result.tag = value.tag : current && null != current.tag && (result.tag = current.tag), 
                    result;
                }, GameStorage.prototype.createCountsValue = function(current, value, option) {
                    if (option) {
                        if (option.operation === g.StorageCountsOperation.Incr || option.operation === g.StorageCountsOperation.Decr) return this.createCountsIncrDecrValue(current, value, option);
                        if (null != option.condition && null != option.comparisonValue && current && null != current.data) switch (option.condition) {
                          case g.StorageCondition.Equal:
                            if (current.data !== option.comparisonValue) return null;
                            break;

                          case g.StorageCondition.GreaterThan:
                            if (!(current.data > option.comparisonValue)) return null;
                            break;

                          case g.StorageCondition.LessThan:
                            if (!(current.data < option.comparisonValue)) return null;
                        }
                    }
                    var result = {
                        data: value.data
                    };
                    return value && null != value.tag ? result.tag = value.tag : current && null != current.tag && (result.tag = current.tag), 
                    result;
                }, GameStorage.prototype.setValue = function(key, value) {
                    this._localStorage.setItem("" + KEY_PREFIX + key, JSON.stringify(value));
                }, GameStorage.prototype.getValue = function(key) {
                    var v = JSON.parse(this._localStorage.getItem("" + KEY_PREFIX + key));
                    return v;
                }, GameStorage.prototype.storageKeyToStringKey = function(key) {
                    var region = key.region || "", gameId = null != key.gameId ? String(key.gameId) : "", userId = null != key.userId ? String(key.userId) : "", regionKey = key.regionKey || "";
                    return region + "/" + gameId + "/" + userId + "/" + regionKey;
                }, GameStorage.prototype.stringKeyToStorageKey = function(key) {
                    var s = key.split("/"), res = {
                        region: Number(s[0]),
                        regionKey: s[3]
                    };
                    return s[1] && (res.gameId = s[1]), s[2] && (res.userId = s[2]), res;
                }, GameStorage.prototype.storageReadKeyToRegExp = function(key) {
                    var region = key.region || "", gameId = null != key.gameId ? String(key.gameId) : "", userId = null != key.userId ? String(key.userId) : "", regionKey = "";
                    if ("*" === userId && (userId = "[0-9]+"), -1 !== key.regionKey.indexOf("*")) {
                        var layerKeys = key.regionKey.split(".");
                        layerKeys.forEach(function(layerKey, index) {
                            regionKey += "*" === layerKey ? "[.a-z0-9]*" : -1 !== layerKey.indexOf("*") ? layerKey.replace("*", "[a-z0-9]*") : layerKey, 
                            index !== layerKeys.length - 1 && (regionKey += ".");
                        });
                    } else regionKey = key.regionKey.replace(".", ".");
                    return new RegExp("^" + region + "/" + gameId + "/" + userId + "/" + regionKey + "$");
                }, GameStorage.prototype.sortByValue = function(values, order) {
                    values.sort(function(a, b) {
                        var va = a.data, vb = b.data;
                        if (order === g.StorageOrder.Asc) {
                            if (vb > va) return -1;
                            if (va > vb) return 1;
                        } else if (order === g.StorageOrder.Desc) {
                            if (vb > va) return 1;
                            if (va > vb) return -1;
                        }
                        return 0;
                    });
                }, GameStorage.prototype.sortByRegionKey = function(values, order) {
                    values.sort(function(a, b) {
                        var ka = a.storageKey.regionKey, kb = b.storageKey.regionKey;
                        if (order === g.StorageOrder.Asc) {
                            if (kb > ka) return -1;
                            if (ka > kb) return 1;
                        } else if (order === g.StorageOrder.Desc) {
                            if (kb > ka) return 1;
                            if (ka > kb) return -1;
                        }
                        return 0;
                    });
                }, GameStorage.prototype.expandVariables = function(key) {
                    key.gameId && -1 !== key.gameId.indexOf("$gameId") && this._metaData.gameId && (key.gameId = key.gameId.replace(/\$gameId/g, this._metaData.gameId));
                }, GameStorage;
            }();
            exports.GameStorage = GameStorage;
        }, {
            "./validator": 3,
            "@akashic/akashic-engine": "@akashic/akashic-engine"
        } ],
        2: [ function(require, module, exports) {
            "use strict";
            var gs = require("./GameStorage");
            exports.GameStorage = gs.GameStorage;
        }, {
            "./GameStorage": 1
        } ],
        3: [ function(require, module, exports) {
            "use strict";
            function validateRegionKey(regionKey, forReading) {
                assert(regionKey.length > 0, "regionKey is empty.");
                var layerKeys = regionKey.split(".");
                assert(layerKeys.length <= REGIONKEY_MAX_LAYER_NUM, "The maximum number of layers in the region key is " + REGIONKEY_MAX_LAYER_NUM + ".");
                for (var hasWildcard = !1, i = 0; i < layerKeys.length; ++i) forReading ? "*" === layerKeys[i] ? (assert(!hasWildcard, "The only one layer of the region key for reading consists of a wildcard character."), 
                hasWildcard = !0) : assert(/^(\*|[a-z])[a-z0-9]{0,31}\*?$/.test(layerKeys[i]), "The layer of the region key for reading must match '^(*|[a-z])[a-z0-9]{0,31}*?$'.") : assert(/^[a-z][a-z0-9]{0,31}$/.test(layerKeys[i]), "The layer of the region key for writing must match '^[a-z][a-z0-9]{0,31}$'.");
            }
            function validateStorageKey(key, forReading) {
                void 0 === forReading && (forReading = !1), assert(key.region === g.StorageRegion.Counts || key.region === g.StorageRegion.Scores || key.region === g.StorageRegion.Values, "Invalid region."), 
                assert(key.regionKey, "regionKey must be set."), validateRegionKey(key.regionKey, forReading), 
                assert(key.gameId || key.userId, "StorageKey must have any one at least from gameId and userId."), 
                null != key.gameId && (assert.equal(typeof key.gameId, "string", "gameId must be a string type."), 
                assert(key.gameId.length > 0, "gameId is empty.")), null != key.userId && (assert.equal(typeof key.userId, "string", "userId must be a string type."), 
                assert(key.userId.length > 0, "userId is empty."), forReading ? "*" === key.userId && (assert(key.gameId, 'gameId for reading must be set when userId is "*".'), 
                assert(-1 === key.regionKey.indexOf("*"), 'regionKey for reading must not include "*" when userId is "*".')) : assert("*" !== key.userId, 'userId for writing must not include "*".'));
            }
            function validateStorageReadKey(key) {
                if (validateStorageKey(key, !0), null != key.option) {
                    var opt = key.option;
                    null != opt.keyOrder && assert(opt.keyOrder === g.StorageOrder.Asc || opt.keyOrder === g.StorageOrder.Desc, "Invalid keyOrder."), 
                    null != opt.valueOrder && assert(opt.valueOrder === g.StorageOrder.Asc || opt.valueOrder === g.StorageOrder.Desc, "Invalid valueOrder.");
                }
            }
            function validateStorageWriteOption(option) {}
            var assert = require("assert"), g = require("@akashic/akashic-engine"), REGIONKEY_MAX_LAYER_NUM = 4;
            exports.validateRegionKey = validateRegionKey, exports.validateStorageKey = validateStorageKey, 
            exports.validateStorageReadKey = validateStorageReadKey, exports.validateStorageWriteOption = validateStorageWriteOption;
        }, {
            "@akashic/akashic-engine": "@akashic/akashic-engine",
            assert: 4
        } ],
        4: [ function(require, module, exports) {
            (function(global) {
                "use strict";
                /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
                function compare(a, b) {
                    if (a === b) return 0;
                    for (var x = a.length, y = b.length, i = 0, len = Math.min(x, y); len > i; ++i) if (a[i] !== b[i]) {
                        x = a[i], y = b[i];
                        break;
                    }
                    return y > x ? -1 : x > y ? 1 : 0;
                }
                function isBuffer(b) {
                    return global.Buffer && "function" == typeof global.Buffer.isBuffer ? global.Buffer.isBuffer(b) : !(null == b || !b._isBuffer);
                }
                function pToString(obj) {
                    return Object.prototype.toString.call(obj);
                }
                function isView(arrbuf) {
                    return isBuffer(arrbuf) ? !1 : "function" != typeof global.ArrayBuffer ? !1 : "function" == typeof ArrayBuffer.isView ? ArrayBuffer.isView(arrbuf) : arrbuf ? arrbuf instanceof DataView ? !0 : arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer ? !0 : !1 : !1;
                }
                function getName(func) {
                    if (util.isFunction(func)) {
                        if (functionsHaveNames) return func.name;
                        var str = func.toString(), match = str.match(regex);
                        return match && match[1];
                    }
                }
                function truncate(s, n) {
                    return "string" == typeof s ? s.length < n ? s : s.slice(0, n) : s;
                }
                function inspect(something) {
                    if (functionsHaveNames || !util.isFunction(something)) return util.inspect(something);
                    var rawname = getName(something), name = rawname ? ": " + rawname : "";
                    return "[Function" + name + "]";
                }
                function getMessage(self) {
                    return truncate(inspect(self.actual), 128) + " " + self.operator + " " + truncate(inspect(self.expected), 128);
                }
                function fail(actual, expected, message, operator, stackStartFunction) {
                    throw new assert.AssertionError({
                        message: message,
                        actual: actual,
                        expected: expected,
                        operator: operator,
                        stackStartFunction: stackStartFunction
                    });
                }
                function ok(value, message) {
                    value || fail(value, !0, message, "==", assert.ok);
                }
                function _deepEqual(actual, expected, strict, memos) {
                    if (actual === expected) return !0;
                    if (isBuffer(actual) && isBuffer(expected)) return 0 === compare(actual, expected);
                    if (util.isDate(actual) && util.isDate(expected)) return actual.getTime() === expected.getTime();
                    if (util.isRegExp(actual) && util.isRegExp(expected)) return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
                    if (null !== actual && "object" == typeof actual || null !== expected && "object" == typeof expected) {
                        if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) return 0 === compare(new Uint8Array(actual.buffer), new Uint8Array(expected.buffer));
                        if (isBuffer(actual) !== isBuffer(expected)) return !1;
                        memos = memos || {
                            actual: [],
                            expected: []
                        };
                        var actualIndex = memos.actual.indexOf(actual);
                        return -1 !== actualIndex && actualIndex === memos.expected.indexOf(expected) ? !0 : (memos.actual.push(actual), 
                        memos.expected.push(expected), objEquiv(actual, expected, strict, memos));
                    }
                    return strict ? actual === expected : actual == expected;
                }
                function isArguments(object) {
                    return "[object Arguments]" == Object.prototype.toString.call(object);
                }
                function objEquiv(a, b, strict, actualVisitedObjects) {
                    if (null === a || void 0 === a || null === b || void 0 === b) return !1;
                    if (util.isPrimitive(a) || util.isPrimitive(b)) return a === b;
                    if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)) return !1;
                    var aIsArgs = isArguments(a), bIsArgs = isArguments(b);
                    if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs) return !1;
                    if (aIsArgs) return a = pSlice.call(a), b = pSlice.call(b), _deepEqual(a, b, strict);
                    var key, i, ka = objectKeys(a), kb = objectKeys(b);
                    if (ka.length !== kb.length) return !1;
                    for (ka.sort(), kb.sort(), i = ka.length - 1; i >= 0; i--) if (ka[i] !== kb[i]) return !1;
                    for (i = ka.length - 1; i >= 0; i--) if (key = ka[i], !_deepEqual(a[key], b[key], strict, actualVisitedObjects)) return !1;
                    return !0;
                }
                function notDeepStrictEqual(actual, expected, message) {
                    _deepEqual(actual, expected, !0) && fail(actual, expected, message, "notDeepStrictEqual", notDeepStrictEqual);
                }
                function expectedException(actual, expected) {
                    if (!actual || !expected) return !1;
                    if ("[object RegExp]" == Object.prototype.toString.call(expected)) return expected.test(actual);
                    try {
                        if (actual instanceof expected) return !0;
                    } catch (e) {}
                    return Error.isPrototypeOf(expected) ? !1 : expected.call({}, actual) === !0;
                }
                function _tryBlock(block) {
                    var error;
                    try {
                        block();
                    } catch (e) {
                        error = e;
                    }
                    return error;
                }
                function _throws(shouldThrow, block, expected, message) {
                    var actual;
                    if ("function" != typeof block) throw new TypeError('"block" argument must be a function');
                    "string" == typeof expected && (message = expected, expected = null), actual = _tryBlock(block), 
                    message = (expected && expected.name ? " (" + expected.name + ")." : ".") + (message ? " " + message : "."), 
                    shouldThrow && !actual && fail(actual, expected, "Missing expected exception" + message);
                    var userProvidedMessage = "string" == typeof message, isUnwantedException = !shouldThrow && util.isError(actual), isUnexpectedException = !shouldThrow && actual && !expected;
                    if ((isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) && fail(actual, expected, "Got unwanted exception" + message), 
                    shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) throw actual;
                }
                // Copyright (c) 2009 Thomas Robinson <280north.com>
                //
                // Permission is hereby granted, free of charge, to any person obtaining a copy
                // of this software and associated documentation files (the 'Software'), to
                // deal in the Software without restriction, including without limitation the
                // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
                // sell copies of the Software, and to permit persons to whom the Software is
                // furnished to do so, subject to the following conditions:
                //
                // The above copyright notice and this permission notice shall be included in
                // all copies or substantial portions of the Software.
                //
                // THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                // AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
                // ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
                // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                var util = require("util/"), hasOwn = Object.prototype.hasOwnProperty, pSlice = Array.prototype.slice, functionsHaveNames = function() {
                    return "foo" === function() {}.name;
                }(), assert = module.exports = ok, regex = /\s*function\s+([^\(\s]*)\s*/;
                assert.AssertionError = function(options) {
                    this.name = "AssertionError", this.actual = options.actual, this.expected = options.expected, 
                    this.operator = options.operator, options.message ? (this.message = options.message, 
                    this.generatedMessage = !1) : (this.message = getMessage(this), this.generatedMessage = !0);
                    var stackStartFunction = options.stackStartFunction || fail;
                    if (Error.captureStackTrace) Error.captureStackTrace(this, stackStartFunction); else {
                        var err = new Error();
                        if (err.stack) {
                            var out = err.stack, fn_name = getName(stackStartFunction), idx = out.indexOf("\n" + fn_name);
                            if (idx >= 0) {
                                var next_line = out.indexOf("\n", idx + 1);
                                out = out.substring(next_line + 1);
                            }
                            this.stack = out;
                        }
                    }
                }, util.inherits(assert.AssertionError, Error), assert.fail = fail, assert.ok = ok, 
                assert.equal = function(actual, expected, message) {
                    actual != expected && fail(actual, expected, message, "==", assert.equal);
                }, assert.notEqual = function(actual, expected, message) {
                    actual == expected && fail(actual, expected, message, "!=", assert.notEqual);
                }, assert.deepEqual = function(actual, expected, message) {
                    _deepEqual(actual, expected, !1) || fail(actual, expected, message, "deepEqual", assert.deepEqual);
                }, assert.deepStrictEqual = function(actual, expected, message) {
                    _deepEqual(actual, expected, !0) || fail(actual, expected, message, "deepStrictEqual", assert.deepStrictEqual);
                }, assert.notDeepEqual = function(actual, expected, message) {
                    _deepEqual(actual, expected, !1) && fail(actual, expected, message, "notDeepEqual", assert.notDeepEqual);
                }, assert.notDeepStrictEqual = notDeepStrictEqual, assert.strictEqual = function(actual, expected, message) {
                    actual !== expected && fail(actual, expected, message, "===", assert.strictEqual);
                }, assert.notStrictEqual = function(actual, expected, message) {
                    actual === expected && fail(actual, expected, message, "!==", assert.notStrictEqual);
                }, assert["throws"] = function(block, error, message) {
                    _throws(!0, block, error, message);
                }, assert.doesNotThrow = function(block, error, message) {
                    _throws(!1, block, error, message);
                }, assert.ifError = function(err) {
                    if (err) throw err;
                };
                var objectKeys = Object.keys || function(obj) {
                    var keys = [];
                    for (var key in obj) hasOwn.call(obj, key) && keys.push(key);
                    return keys;
                };
            }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
        }, {
            "util/": 8
        } ],
        5: [ function(require, module, exports) {
            function defaultSetTimout() {
                throw new Error("setTimeout has not been defined");
            }
            function defaultClearTimeout() {
                throw new Error("clearTimeout has not been defined");
            }
            function runTimeout(fun) {
                if (cachedSetTimeout === setTimeout) return setTimeout(fun, 0);
                if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) return cachedSetTimeout = setTimeout, 
                setTimeout(fun, 0);
                try {
                    return cachedSetTimeout(fun, 0);
                } catch (e) {
                    try {
                        return cachedSetTimeout.call(null, fun, 0);
                    } catch (e) {
                        return cachedSetTimeout.call(this, fun, 0);
                    }
                }
            }
            function runClearTimeout(marker) {
                if (cachedClearTimeout === clearTimeout) return clearTimeout(marker);
                if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) return cachedClearTimeout = clearTimeout, 
                clearTimeout(marker);
                try {
                    return cachedClearTimeout(marker);
                } catch (e) {
                    try {
                        return cachedClearTimeout.call(null, marker);
                    } catch (e) {
                        return cachedClearTimeout.call(this, marker);
                    }
                }
            }
            function cleanUpNextTick() {
                draining && currentQueue && (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, 
                queue.length && drainQueue());
            }
            function drainQueue() {
                if (!draining) {
                    var timeout = runTimeout(cleanUpNextTick);
                    draining = !0;
                    for (var len = queue.length; len; ) {
                        for (currentQueue = queue, queue = []; ++queueIndex < len; ) currentQueue && currentQueue[queueIndex].run();
                        queueIndex = -1, len = queue.length;
                    }
                    currentQueue = null, draining = !1, runClearTimeout(timeout);
                }
            }
            function Item(fun, array) {
                this.fun = fun, this.array = array;
            }
            function noop() {}
            var cachedSetTimeout, cachedClearTimeout, process = module.exports = {};
            !function() {
                try {
                    cachedSetTimeout = "function" == typeof setTimeout ? setTimeout : defaultSetTimout;
                } catch (e) {
                    cachedSetTimeout = defaultSetTimout;
                }
                try {
                    cachedClearTimeout = "function" == typeof clearTimeout ? clearTimeout : defaultClearTimeout;
                } catch (e) {
                    cachedClearTimeout = defaultClearTimeout;
                }
            }();
            var currentQueue, queue = [], draining = !1, queueIndex = -1;
            process.nextTick = function(fun) {
                var args = new Array(arguments.length - 1);
                if (arguments.length > 1) for (var i = 1; i < arguments.length; i++) args[i - 1] = arguments[i];
                queue.push(new Item(fun, args)), 1 !== queue.length || draining || runTimeout(drainQueue);
            }, Item.prototype.run = function() {
                this.fun.apply(null, this.array);
            }, process.title = "browser", process.browser = !0, process.env = {}, process.argv = [], 
            process.version = "", process.versions = {}, process.on = noop, process.addListener = noop, 
            process.once = noop, process.off = noop, process.removeListener = noop, process.removeAllListeners = noop, 
            process.emit = noop, process.binding = function(name) {
                throw new Error("process.binding is not supported");
            }, process.cwd = function() {
                return "/";
            }, process.chdir = function(dir) {
                throw new Error("process.chdir is not supported");
            }, process.umask = function() {
                return 0;
            };
        }, {} ],
        6: [ function(require, module, exports) {
            "function" == typeof Object.create ? module.exports = function(ctor, superCtor) {
                ctor.super_ = superCtor, ctor.prototype = Object.create(superCtor.prototype, {
                    constructor: {
                        value: ctor,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                });
            } : module.exports = function(ctor, superCtor) {
                ctor.super_ = superCtor;
                var TempCtor = function() {};
                TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor(), ctor.prototype.constructor = ctor;
            };
        }, {} ],
        7: [ function(require, module, exports) {
            module.exports = function(arg) {
                return arg && "object" == typeof arg && "function" == typeof arg.copy && "function" == typeof arg.fill && "function" == typeof arg.readUInt8;
            };
        }, {} ],
        8: [ function(require, module, exports) {
            (function(process, global) {
                function inspect(obj, opts) {
                    var ctx = {
                        seen: [],
                        stylize: stylizeNoColor
                    };
                    return arguments.length >= 3 && (ctx.depth = arguments[2]), arguments.length >= 4 && (ctx.colors = arguments[3]), 
                    isBoolean(opts) ? ctx.showHidden = opts : opts && exports._extend(ctx, opts), isUndefined(ctx.showHidden) && (ctx.showHidden = !1), 
                    isUndefined(ctx.depth) && (ctx.depth = 2), isUndefined(ctx.colors) && (ctx.colors = !1), 
                    isUndefined(ctx.customInspect) && (ctx.customInspect = !0), ctx.colors && (ctx.stylize = stylizeWithColor), 
                    formatValue(ctx, obj, ctx.depth);
                }
                function stylizeWithColor(str, styleType) {
                    var style = inspect.styles[styleType];
                    return style ? "[" + inspect.colors[style][0] + "m" + str + "[" + inspect.colors[style][1] + "m" : str;
                }
                function stylizeNoColor(str, styleType) {
                    return str;
                }
                function arrayToHash(array) {
                    var hash = {};
                    return array.forEach(function(val, idx) {
                        hash[val] = !0;
                    }), hash;
                }
                function formatValue(ctx, value, recurseTimes) {
                    if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && (!value.constructor || value.constructor.prototype !== value)) {
                        var ret = value.inspect(recurseTimes, ctx);
                        return isString(ret) || (ret = formatValue(ctx, ret, recurseTimes)), ret;
                    }
                    var primitive = formatPrimitive(ctx, value);
                    if (primitive) return primitive;
                    var keys = Object.keys(value), visibleKeys = arrayToHash(keys);
                    if (ctx.showHidden && (keys = Object.getOwnPropertyNames(value)), isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) return formatError(value);
                    if (0 === keys.length) {
                        if (isFunction(value)) {
                            var name = value.name ? ": " + value.name : "";
                            return ctx.stylize("[Function" + name + "]", "special");
                        }
                        if (isRegExp(value)) return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                        if (isDate(value)) return ctx.stylize(Date.prototype.toString.call(value), "date");
                        if (isError(value)) return formatError(value);
                    }
                    var base = "", array = !1, braces = [ "{", "}" ];
                    if (isArray(value) && (array = !0, braces = [ "[", "]" ]), isFunction(value)) {
                        var n = value.name ? ": " + value.name : "";
                        base = " [Function" + n + "]";
                    }
                    if (isRegExp(value) && (base = " " + RegExp.prototype.toString.call(value)), isDate(value) && (base = " " + Date.prototype.toUTCString.call(value)), 
                    isError(value) && (base = " " + formatError(value)), 0 === keys.length && (!array || 0 == value.length)) return braces[0] + base + braces[1];
                    if (0 > recurseTimes) return isRegExp(value) ? ctx.stylize(RegExp.prototype.toString.call(value), "regexp") : ctx.stylize("[Object]", "special");
                    ctx.seen.push(value);
                    var output;
                    return output = array ? formatArray(ctx, value, recurseTimes, visibleKeys, keys) : keys.map(function(key) {
                        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
                    }), ctx.seen.pop(), reduceToSingleString(output, base, braces);
                }
                function formatPrimitive(ctx, value) {
                    if (isUndefined(value)) return ctx.stylize("undefined", "undefined");
                    if (isString(value)) {
                        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                        return ctx.stylize(simple, "string");
                    }
                    return isNumber(value) ? ctx.stylize("" + value, "number") : isBoolean(value) ? ctx.stylize("" + value, "boolean") : isNull(value) ? ctx.stylize("null", "null") : void 0;
                }
                function formatError(value) {
                    return "[" + Error.prototype.toString.call(value) + "]";
                }
                function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
                    for (var output = [], i = 0, l = value.length; l > i; ++i) hasOwnProperty(value, String(i)) ? output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), !0)) : output.push("");
                    return keys.forEach(function(key) {
                        key.match(/^\d+$/) || output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, !0));
                    }), output;
                }
                function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
                    var name, str, desc;
                    if (desc = Object.getOwnPropertyDescriptor(value, key) || {
                        value: value[key]
                    }, desc.get ? str = desc.set ? ctx.stylize("[Getter/Setter]", "special") : ctx.stylize("[Getter]", "special") : desc.set && (str = ctx.stylize("[Setter]", "special")), 
                    hasOwnProperty(visibleKeys, key) || (name = "[" + key + "]"), str || (ctx.seen.indexOf(desc.value) < 0 ? (str = isNull(recurseTimes) ? formatValue(ctx, desc.value, null) : formatValue(ctx, desc.value, recurseTimes - 1), 
                    str.indexOf("\n") > -1 && (str = array ? str.split("\n").map(function(line) {
                        return "  " + line;
                    }).join("\n").substr(2) : "\n" + str.split("\n").map(function(line) {
                        return "   " + line;
                    }).join("\n"))) : str = ctx.stylize("[Circular]", "special")), isUndefined(name)) {
                        if (array && key.match(/^\d+$/)) return str;
                        name = JSON.stringify("" + key), name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (name = name.substr(1, name.length - 2), 
                        name = ctx.stylize(name, "name")) : (name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), 
                        name = ctx.stylize(name, "string"));
                    }
                    return name + ": " + str;
                }
                function reduceToSingleString(output, base, braces) {
                    var numLinesEst = 0, length = output.reduce(function(prev, cur) {
                        return numLinesEst++, cur.indexOf("\n") >= 0 && numLinesEst++, prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
                    }, 0);
                    return length > 60 ? braces[0] + ("" === base ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1] : braces[0] + base + " " + output.join(", ") + " " + braces[1];
                }
                function isArray(ar) {
                    return Array.isArray(ar);
                }
                function isBoolean(arg) {
                    return "boolean" == typeof arg;
                }
                function isNull(arg) {
                    return null === arg;
                }
                function isNullOrUndefined(arg) {
                    return null == arg;
                }
                function isNumber(arg) {
                    return "number" == typeof arg;
                }
                function isString(arg) {
                    return "string" == typeof arg;
                }
                function isSymbol(arg) {
                    return "symbol" == typeof arg;
                }
                function isUndefined(arg) {
                    return void 0 === arg;
                }
                function isRegExp(re) {
                    return isObject(re) && "[object RegExp]" === objectToString(re);
                }
                function isObject(arg) {
                    return "object" == typeof arg && null !== arg;
                }
                function isDate(d) {
                    return isObject(d) && "[object Date]" === objectToString(d);
                }
                function isError(e) {
                    return isObject(e) && ("[object Error]" === objectToString(e) || e instanceof Error);
                }
                function isFunction(arg) {
                    return "function" == typeof arg;
                }
                function isPrimitive(arg) {
                    return null === arg || "boolean" == typeof arg || "number" == typeof arg || "string" == typeof arg || "symbol" == typeof arg || "undefined" == typeof arg;
                }
                function objectToString(o) {
                    return Object.prototype.toString.call(o);
                }
                function pad(n) {
                    return 10 > n ? "0" + n.toString(10) : n.toString(10);
                }
                function timestamp() {
                    var d = new Date(), time = [ pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds()) ].join(":");
                    return [ d.getDate(), months[d.getMonth()], time ].join(" ");
                }
                function hasOwnProperty(obj, prop) {
                    return Object.prototype.hasOwnProperty.call(obj, prop);
                }
                // Copyright Joyent, Inc. and other Node contributors.
                //
                // Permission is hereby granted, free of charge, to any person obtaining a
                // copy of this software and associated documentation files (the
                // "Software"), to deal in the Software without restriction, including
                // without limitation the rights to use, copy, modify, merge, publish,
                // distribute, sublicense, and/or sell copies of the Software, and to permit
                // persons to whom the Software is furnished to do so, subject to the
                // following conditions:
                //
                // The above copyright notice and this permission notice shall be included
                // in all copies or substantial portions of the Software.
                //
                // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
                // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
                // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
                // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
                // USE OR OTHER DEALINGS IN THE SOFTWARE.
                var formatRegExp = /%[sdj%]/g;
                exports.format = function(f) {
                    if (!isString(f)) {
                        for (var objects = [], i = 0; i < arguments.length; i++) objects.push(inspect(arguments[i]));
                        return objects.join(" ");
                    }
                    for (var i = 1, args = arguments, len = args.length, str = String(f).replace(formatRegExp, function(x) {
                        if ("%%" === x) return "%";
                        if (i >= len) return x;
                        switch (x) {
                          case "%s":
                            return String(args[i++]);

                          case "%d":
                            return Number(args[i++]);

                          case "%j":
                            try {
                                return JSON.stringify(args[i++]);
                            } catch (_) {
                                return "[Circular]";
                            }

                          default:
                            return x;
                        }
                    }), x = args[i]; len > i; x = args[++i]) str += isNull(x) || !isObject(x) ? " " + x : " " + inspect(x);
                    return str;
                }, exports.deprecate = function(fn, msg) {
                    function deprecated() {
                        if (!warned) {
                            if (process.throwDeprecation) throw new Error(msg);
                            process.traceDeprecation ? console.trace(msg) : console.error(msg), warned = !0;
                        }
                        return fn.apply(this, arguments);
                    }
                    if (isUndefined(global.process)) return function() {
                        return exports.deprecate(fn, msg).apply(this, arguments);
                    };
                    if (process.noDeprecation === !0) return fn;
                    var warned = !1;
                    return deprecated;
                };
                var debugEnviron, debugs = {};
                exports.debuglog = function(set) {
                    if (isUndefined(debugEnviron) && (debugEnviron = process.env.NODE_DEBUG || ""), 
                    set = set.toUpperCase(), !debugs[set]) if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
                        var pid = process.pid;
                        debugs[set] = function() {
                            var msg = exports.format.apply(exports, arguments);
                            console.error("%s %d: %s", set, pid, msg);
                        };
                    } else debugs[set] = function() {};
                    return debugs[set];
                }, exports.inspect = inspect, inspect.colors = {
                    bold: [ 1, 22 ],
                    italic: [ 3, 23 ],
                    underline: [ 4, 24 ],
                    inverse: [ 7, 27 ],
                    white: [ 37, 39 ],
                    grey: [ 90, 39 ],
                    black: [ 30, 39 ],
                    blue: [ 34, 39 ],
                    cyan: [ 36, 39 ],
                    green: [ 32, 39 ],
                    magenta: [ 35, 39 ],
                    red: [ 31, 39 ],
                    yellow: [ 33, 39 ]
                }, inspect.styles = {
                    special: "cyan",
                    number: "yellow",
                    "boolean": "yellow",
                    undefined: "grey",
                    "null": "bold",
                    string: "green",
                    date: "magenta",
                    regexp: "red"
                }, exports.isArray = isArray, exports.isBoolean = isBoolean, exports.isNull = isNull, 
                exports.isNullOrUndefined = isNullOrUndefined, exports.isNumber = isNumber, exports.isString = isString, 
                exports.isSymbol = isSymbol, exports.isUndefined = isUndefined, exports.isRegExp = isRegExp, 
                exports.isObject = isObject, exports.isDate = isDate, exports.isError = isError, 
                exports.isFunction = isFunction, exports.isPrimitive = isPrimitive, exports.isBuffer = require("./support/isBuffer");
                var months = [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ];
                exports.log = function() {
                    console.log("%s - %s", timestamp(), exports.format.apply(exports, arguments));
                }, exports.inherits = require("inherits"), exports._extend = function(origin, add) {
                    if (!add || !isObject(add)) return origin;
                    for (var keys = Object.keys(add), i = keys.length; i--; ) origin[keys[i]] = add[keys[i]];
                    return origin;
                };
            }).call(this, require("_process"), "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
        }, {
            "./support/isBuffer": 7,
            _process: 5,
            inherits: 6
        } ]
    }, {}, [ 2 ])(2);
});	function enableLogger(game) {
	if (! "console" in window) {
		// 最低限のpolyfillはするがそこまでサポートはしない
		window.console = {
			log: function(x) {
			},
			error: function(x) {
			},
			info: function(x) {
			},
			warn: function(x) {
			}
		};
	}
	var logLevel = g.LogLevel.Debug;
	var loggerMap = {};
	loggerMap[g.LogLevel.Debug] = console.log;
	loggerMap[g.LogLevel.Warn] = console.warn;
	loggerMap[g.LogLevel.Info] = console.info;
	loggerMap[g.LogLevel.Error] = console.error;
	function onLogging(log) {
		if (log.level > logLevel) return;
		var prefix = log.level in g.LogLevel ? "[" + g.LogLevel[log.level].toUpperCase() + "]\t" : "";
		var method = loggerMap[log.level] ? loggerMap[log.level] : console.log;
		method.call(console, prefix + log.message);
		if (log.cause)
			method.call(console, log.cause);
	}
	game.logger.logging.add(onLogging);
}
	window.addEventListener("load", function() {

	start("exportHTML");

	function start(gamePath) {
		// TODO WebGL有効化
		// // webgl=1でRendererを問答無用でWebGLのみにする
		// if (getParameterByName("webgl")) {
		// 	conf.renderers = ["webgl"];
		// }

		// 本来であればgameIdはBIGINTとして扱われるので数値だけども、export html用なのでgamePathをそのまま使う
		var sandboxGameId = gamePath;
		var sandboxPlayer = { id: "9999", name: "sandbox-player" };
		var sandboxPlayId = "sandboxDummyPlayId";
		var storage = new gameStorage.GameStorage(window.localStorage, { gameId: sandboxGameId });

		var pdiBrowser = require("@akashic/pdi-browser");
		var gdr = require("@akashic/game-driver");

		var amflowClient = new gdr.MemoryAmflowClient({
			playId: sandboxPlayId,
			putStorageDataSyncFunc: storage.set.bind(storage),
			getStorageDataSyncFunc: function (readKeys) {
				var svs = storage.load(readKeys);
				// StorageValue[][]からStorageData[]に変換する
				// TODO: StorageValue[][]が返ってくる必然性はない。game-storage側の仕様を変えるべき。
				return readKeys.map(function (k, i) { return { readKey: k, values: svs[i] }; });
			}
		});

		var audioPlugins;
		if (location.protocol !== "file:") {
			// 特にSafariの制約(user activationなしでは音が鳴らない)回避のため、可能ならWebAudioを使う
			audioPlugins = [pdiBrowser.WebAudioPlugin, pdiBrowser.HTMLAudioPlugin];
		} else {
			// file:の場合ブラウザによってCORSの制約にひっかかるWebAudioは避ける
			audioPlugins = [pdiBrowser.HTMLAudioPlugin];
		}
		var pf = new pdiBrowser.Platform({
			amflow: amflowClient,
			containerView: document.getElementById("container"),
			audioPlugins: audioPlugins
		});

		pf.loadGameConfiguration = function(url, callback) {
			try {
				var gameJsonText = window.gLocalAssetContainer["game.json"];
				gameJsonText = decodeURIComponent(gameJsonText);
				callback(null, JSON.parse(gameJsonText));
			} catch(error) {
				callback(error, null);
			}
		};

		pf._resourceFactory.createScriptAsset = function(id, assetPath) {
			return new LocalScriptAsset(id, assetPath);
		};

		pf._resourceFactory.createTextAsset = function(id, assetPath) {
			return new LocalTextAsset(id, assetPath);
		};

		driver = new gdr.GameDriver({
			platform: pf,
			player: sandboxPlayer,
			errorHandler: function (e) { console.log("ERRORHANDLER:", e); }
		});

		driver.gameCreatedTrigger.add(function (game) {
			if (window.optionProps.magnify) {
				if (!pf.containerController) return;
				var viewportSize = {
					width: window.innerWidth || document.documentElement.clientWidth,
					height: window.innerHeight || document.documentElement.clientHeight
				};
				var gameScale = Math.min(
					viewportSize.width / game.width,
					viewportSize.height / game.height
				);
				var gameSize = {
					width: Math.floor(game.width * gameScale),
					height: Math.floor(game.height * gameScale)
				};
				pf.containerController.changeScale(gameScale, gameScale);
				var gameOffset = {
					x: Math.floor((viewportSize.width - gameSize.width) / 2),
					y: Math.floor((viewportSize.height - gameSize.height) / 2)
				};
				pf.containerController.inputHandlerLayer.setOffset(gameOffset);
			}
		});

		driver.initialize({
			configurationUrl: "game.json",
			assetBase: "./",
			driverConfiguration: {
				playId: sandboxPlayId,
				playToken: "dummyToken",
				executionMode: gdr.ExecutionMode.Active
			},
			loopConfiguration: {
				loopMode: gdr.LoopMode.Realtime
			}
		}, function (e) {
			if (e) {
				throw e;
			}
			driver.startGame();
		});
	}
});
	window.g = require("@akashic/akashic-engine");

if (! ("gLocalAssetContainer" in window)) {
	window.gLocalAssetContainer = {};
}
</script>

<style type="text/css">
* {
	margin: 0;
	border: 0;
	padding: 0;
}
body{
	overflow: hidden;
}

#container {
	margin: 0px;
	padding: 0px;
	overflow: hidden;
	touch-action: none;
}

#container canvas{
	background-size: contain;
}
</style>

</head>
<body>
<div id="container">
</div>
</body>
</html>
